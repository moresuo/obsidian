***
## 数组
### 1、二分查找

> [!NOTE]- [704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/)
>```java
class Solution {
    public int search(int[] nums, int target) {
        if(target<nums[0]||target>nums[nums.length-1]){//因为是有序数组，当目标值不在数组范围内就直接返回
            return -1;
        }
        int left=0;//左指针
        int right=nums.length-1;//右指针
        while(left<=right){//左闭右闭模式
            int mid=(left+right) >> 1;//右移一位相当于除以二，这种速度更快
            if(target<nums[mid]){//目标值在左边，缩小右边上限
                right=mid-1;
            }else if(target>nums[mid]){//目标值在右边，提升左边下限
                left=mid+1;
            }else{//找到目标值
                return mid;
            }
        }
        //循环结束，未找到
        return -1;
    }
}
>```
### 2、移除元素

> [!NOTE]- [27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/description/)
快慢指针
>```java
> class Solution {
    public int removeElement(int[] nums, int val) {
        int slowIndex=0;//慢指针，用于记录等于val的下标
        int fastIndex=0;//快指针
        for(;fastIndex<nums.length;fastIndex++){
            if(nums[fastIndex]!=val){//快指针的值不等于val值的话就覆盖慢指针的值
                nums[slowIndex++]=nums[fastIndex];
            }
        }
        return slowIndex;
    }
}
>```
### 3、有序数组平方

> [!NOTE]- [977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)
双向指针
>```java
> class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] result=new int[nums.length];//创建新数组
        int index=nums.length-1;//表示新数组末尾下标
        //双向指针判断出每次平方的最大值
        int left=0;
        int right=nums.length-1;
        while(left<=right){
            if(nums[left]*nums[left]>nums[right]*nums[right]){//负数平方大于后面的值的平方
                result[index--]=nums[left]*nums[left];//给新数组赋值，下标减一
                left++;//原数组前指针后移
            }else{
                result[index--]=nums[right]*nums[right];
                right--;
            }
        }
        return result;
    }
}
>```
### 4、长度最小的子数组

> [!NOTE]- [209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)
> 滑动窗口
> ```java
> class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left=0;//记录窗口最左的下标
        int result=Integer.MAX_VALUE;//窗口初始大小
        int sum=0;//记录窗口中值的和
        for(int right=0;right<nums.length;right++){
            sum+=nums[right];//扩大窗口，增值
            while(sum>=target){//循环缩小窗口至sum小于目标值
                result=Math.min(result,right-left+1);//判断出出窗口最小长度
                sum-=nums[left++];//窗口缩小同时sum要减小
            }
        }
        return result==Integer.MAX_VALUE?0:result;
    }
}
>```

### 5、螺旋矩阵

> [!NOTE]- [59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)
>```java
>class Solution {
    public int[][] generateMatrix(int n) {
        int loop=0;//循环次数
        int count=1;//从1开始
        int start=0;//每次循环起始位置
        int i,j=0;//横纵坐标
        int[][] res=new int[n][n];//结果数组
        while(loop++<n/2){//为什么loop从一开始，因为每次循环最后不包括边界值
            for(j=start;j<n-loop;j++){//上侧从左往右
                res[start][j]=count++;
            }
            for(i=start;i<n-loop;i++){//右侧从上往下
                res[i][j]=count++;
            }
            for(;j>start;j--){//下侧从右往左
                res[i][j]=count++;
            }
            for(;i>start;i--){//左侧从下往上
                res[i][j]=count++;
            }
            start++;
        }
        if(n%2==1){
            res[start][start]=count;
        }
        return res;
    }
}
>```

## 链表
### 1、移出链表元素

> [!NOTE]- [203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)
>```java
>class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head==null){
            return head;
        }
        ListNode dummy=new ListNode(-1,head);//设置虚拟头结点
        ListNode pre=dummy;//用来修改虚拟头结点
        ListNode cur=head;
        while(cur!=null){
            if(cur.val==val){
                pre.next=cur.next;
            }else{
                pre=cur;
            }
            cur=cur.next;
        }
        return dummy.next;
    }
}
>```

### 2、设计链表

> [!NOTE]- [707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/)
>```java
> class MyLinkedList {
    private int size;//链表节点个数
    private ListNode head;//虚拟头结点
    public MyLinkedList() {//初始化
        this.size=0;
        this.head=new ListNode(-1);
    }
    public int get(int index) {//根据下标获取元素值
        if(index<0||index>=size){
            return -1;
        }
        ListNode cur=head;
        for(int i=0;i<=index;i++){
            cur=cur.next;
        }
        return cur.val;
    }
    public void addAtHead(int val) {
        addAtIndex(0,val);
    }
    public void addAtTail(int val) {
        addAtIndex(size,val);
    }
    public void addAtIndex(int index, int val) {
        if(index>this.size){
            return;
        }
        if(index<0){
            index=0;
        }
        this.size++;
        ListNode pre=head;
        for(int i=0;i<index;i++){
            pre=pre.next;
        }
        ListNode newNode=new ListNode(val);
        newNode.next=pre.next;
        pre.next=newNode;
    }
    public void deleteAtIndex(int index) {
        if(index<0||index>=size){
            return;
        }
        this.size--;
        if(index==0){
            head=head.next;
            return;
        }
        ListNode pre=head;
        for(int i=0;i<index;i++){
            pre=pre.next;
        }
        pre.next=pre.next.next;
    }
}
class ListNode{//单链表
    int val;
    ListNode next;
    public ListNode(){
    public ListNode(int val){
        this.val=val;
    }
}
>```

### 3、反转链表

> [!NOTE]- [206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)
>```java
> class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null){
            return head;
        }
        ListNode cur=head;
        ListNode pre=null;
        ListNode temp=null;//保存cur的下一个节点
        while(cur!=null){
            temp=cur.next;//因为cur的next指针要指向前面的pre，所以要提前保存cur的下一个节点
            cur.next=pre;//链表向后指
            pre=cur;
            cur=temp;
        }
        return pre;
    }
}
>```

### 4、两两交换链表中的节点

> [!NOTE]- [24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/)
>```java
> class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head==null){
            return head;
        }
        ListNode dummy=new ListNode(-1,head);//设置虚拟头结点
        ListNode cur=dummy;//设置当前节点
        ListNode temp;//保存两个交换节点的下一个节点
        ListNode firstNode;//交换的第一个节点
        ListNode secondNode;//交换的第二个节点
        while(cur.next!=null&&cur.next.next!=null){//保证后面有两个节点可以进行交换
            temp=cur.next.next.next;//保存两个节点后面的一个节点，方便进行连接
            firstNode=cur.next;
            secondNode=cur.next.next;
            //转移链表指针
            cur.next=secondNode;
            secondNode.next=firstNode;
            firstNode.next=temp;
            cur=firstNode;//下一次交换的虚拟头结点
        }
        return dummy.next;
    }
}
>```

### 5、删除链表倒数第 n 个节点

> [!NOTE]- [19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
>```java
> class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head==null){
            return head;
        }
        ListNode dummy=new ListNode(-1,head);//设置虚拟头结点
        ListNode fast=dummy;
        ListNode slow=dummy;
        for(int i=0;i<=n;i++){//快指针前进n+1步
            fast=fast.next;
        }
        while(fast!=null){//当快指针为空时，慢指针的下一个节点就是将要删除的节点
            slow=slow.next;
            fast=fast.next;
        }
        slow.next=slow.next.next;
        return dummy.next
    }
}
>```

### 6、链表相交

> [!NOTE]- [面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)
>```java
> public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA=headA;
        ListNode curB=headB;
        //获取链表A和链表B的长度
        int lenA=0;
        int lenB=0;
        while(curA!=null){
            lenA++;
            curA=curA.next;
        }
        while(curB!=null){
            lenB++;
            curB=curB.next;
        }
        //恢复为初始状态
        curA=headA;
        curB=headB;
        //始终认为链表A长于链表B
        if(lenB>lenA){
            //交换链表长度
            int tempLen=lenA;
            lenA=lenB;
            lenB=tempLen;
            //交换头结点
            ListNode tempNode=curA;
            curA=curB;
            curB=tempNode;
        }
        //计算长度的差值
        int gap=lenA-lenB;
        //根据差值将链表A的头结点设置为同一起跑线
        while(gap-->0){
            curA=curA.next;
        }
        while(curA!=null){
            if(curA==curB){
                return curA;//找到相交节点
            }
            curA=curA.next;
            curB=curB.next;
        }
        //不相交
        return null;
    }
}
>```

### 7、环形链表 2

> [!NOTE]- [142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/)
>```java
> public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast=head;//快指针，每次移动两个节点
        ListNode slow=head;//慢指针，每次移动一个节点
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow){//存在环
                ListNode index1=fast;
                ListNode index2=head;
                //节点和头结点每次走一步，相交的位置就是环的入口
                while(index1!=index2){
                    index1=index1.next;
                    index2=index2.next;
                }
                return index1;
            }
        }
        return null;//不存在环
    }
}
>```

## 哈希表
### 1、有效的字母异位词

> [!NOTE]- [242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/)
>```java
> class Solution {
    public boolean isAnagram(String s, String t) {
        int[] count=new int[26];//把数组当做一个哈希表，容纳26个字母
        for(int i=0;i<s.length();i++){//将每个字母放入对应哈希表的位置，每出现一次就加一
            count[s.charAt(i)-'a']++;
        }
        for(int i=0;i<t.length();i++){//遍历字符串将出现的每个字母对应的数值减一
            count[t.charAt(i)-'a']--;
        }
        //遍历整个哈希表，如果存在有字母数值不为0的情况，说明并不是字母异位词
        for(int i=0;i<count.length;i++){
            if(count[i]!=0){
                return false;
            }
        }
        return true;
    }
}
>```

### 2、两个数组的交集

> [!NOTE]- [349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/)
```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        if(nums1==null||nums1.length==0||nums2==null||nums2.length==0){//如果存在一个数组为空，那么就不可能存在交集
            return new int[0];//返回空数组
        }
        Set<Integer> set=new HashSet<>();
        Set<Integer> resSet=new HashSet<>();
        //将nums1的元素存入set去重
        for(int num:nums1){
            set.add(num);
        }
        //遍历nums2,查看哪些元素存在set集合
        for(int num:nums2){
            if(set.contains(num)){
                resSet.add(num);
            }
        }
        //将保存交集的set集合转为数组
        return resSet.stream().mapToInt(x->x).toArray();
    }
}
```

### 3、快乐数

> [!NOTE]- [202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/)
```java
class Solution {
    public boolean isHappy(int n) {
        //本题关键点：不是快乐数的话会循环到起始值n
        Set<Integer> set=new HashSet<>();//set集合保存结果集
        while(n!=1&&!set.contains(n)){//如果n为1就是快乐数，如果结果重复就不是快乐数
            set.add(n);//保存每次结果
            n=getNextNumber(n);//获取每次结果
        }
        return n==1;
    }
    public Integer getNextNumber(int n){
        int res=0;
        while(n>0){
            int temp=n%10;
            res+=temp*temp;
            n/=10;
        }
        return res;
    }
}
```
      
### 4、两数之和

> [!NOTE]- [1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/)
>```java
> class Solution {
    public int[] twoSum(int[] nums, int target) {
        //数组中同一个元素在答案里不能重复出现,两个数的下标不能一样
        int[] res=new int[2];//结果集
        Map<Integer,Integer> map=new HashMap<>();//key为数值，value为下标
        for(int i=0;i<nums.length;i++){
            int gap=target-nums[i];//求每次遍历的差值
            if(map.containsKey(gap)){//当前差值与当前num的不正好是target吗
                res[0]=i;
                res[1]=map.get(gap);
                break;
            }
            map.put(nums[i],i);//有重复值无所谓，只需要一个结果
        }
        return res;
    }
}
>```

### 5、四数相加

> [!NOTE]- [454. 四数相加 II - 力扣（LeetCode）](https://leetcode.cn/problems/4sum-ii/description/)
>```java
> class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        int count=0;
        Map<Integer,Integer> sum=new HashMap<>();
        for(int i:nums1){//统计数组1和数组2两两相加和出现的次数
            for(int j:nums2){
                sum.put(i+j,sum.getOrDefault(i+j,0)+1);
            }
        }
        //判断sum集合中是否数组3和数组4两两相加之和的相反数
        for(int i:nums3){
            for(int j:nums4){
                count+=sum.getOrDefault(0-i-j,0);
            }
        }
        return count;
    }
}
>```

### 6、赎金信

> [!NOTE]- [383. 赎金信 - 力扣（LeetCode）](https://leetcode.cn/problems/ransom-note/)
>```java
> class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        //如果ransomNote长度大于magazine的话那肯定是无法构成的
        if(ransomNote.length()>magazine.length()){
            return false;
        }
        int[] res=new int[26];
        for(char c:magazine.toCharArray()){
            res[c-'a']+=1;
        }
        for(char c:ransomNote.toCharArray()){
            res[c-'a']-=1;
        }
        for(int i:res){
            if(i<0){//如果存在小于0的情况，说明ransomNote所需的某个字符个数大于magazine中字符的数量
                return false;
            }
        }
        return true;
    }
}
>```

### 7、三数之和

> [!NOTE]- [15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/description/)
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res=new ArrayList<>();
        int left;//左指针
        int right;//右指针
        //先将nums排序
        Arrays.sort(nums);
        for(int i=0;i<nums.length;i++){
            if(nums[i]>0){
                //最小的数都大于0,3数之和肯定大于0
                return res;
            }
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }
            left=i+1;
            right=nums.length-1;
            while(left<right){
                //3数之和大于0
                if(nums[i]+nums[left]+nums[right]>0){
                    right--;
                }else if(nums[i]+nums[left]+nums[right]<0){
                    left++;
                }else{
                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    while(left<right&&nums[right]==nums[right-1]){
                        right--;
                    }
                    while(left<right&&nums[left]==nums[left+1]){
                        left++;
                    }
                    right--;
                    left++;
                }
            }
        }
        return res;
    }
}
```
### 8、四数之和

> [!NOTE]- [18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/)
```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res=new ArrayList<>();
        Arrays.sort(nums);
        for(int i=0;i<nums.length;i++){
            if(nums[i] > 0&&nums[i]>target){
                return res;
            }
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }
            for(int j=i+1;j<nums.length;j++){
                if(j>i+1&&nums[j]==nums[j-1]){
                    continue;
                }
                int left=j+1;
                int right=nums.length-1;
                while(left<right){
                    long sum=(long)nums[i]+nums[j]+nums[left]+nums[right];
                    if(sum>target){
                        right--;
                    } else if(sum<target){
                        left++;
                    }else{
                        res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));
                        while(left<right&&nums[right]==nums[right-1]){
                            right--;
                        }
                        while(left<right&&nums[left]==nums[left+1]){
                            left++;
                        }
                        right--;
                        left++;
                    }
                }
            }
        }
        return res;
    }
}
```

## 字符串
### 1、反转字符串

> [!NOTE]- [344. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/)
>```java
> class Solution {
    public void reverseString(char[] s) {
        int left=0;
        int right=s.length-1;
        while(left<right){
            char temp=s[left];
            s[left]=s[right];
            s[right]=temp;
            left++;
            right--;
        }
    }
}
>```

### 2、反转字符串 2

> [!NOTE]- [541. 反转字符串 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string-ii/)
>```java
>class Solution {
    public String reverseStr(String s, int k) {
        //每隔2k个反转前k个，不足k个全部反转
        char[] c=s.toCharArray();
        for(int i=0;i<c.length;i+=2*k){//每次向前移动2k个
            int start=i;
            int end=Math.min(c.length-1,start+k-1);//判断剩余字符是否大于k个
            while(start<end){//异或方式进行交换
                c[start]^=c[end];
                c[end]^=c[start];
                c[start]^=c[end];
                start++;
                end--;
            }
        }
        return new String(c);
    }
} 
>```
### 3、反转字符中的单词

> [!NOTE]- [151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/)
>```java
>class Solution {
    public String reverseWords(String s) {
        char[] res=new char[s.length()+1];//为什么要加一，因为后面每次往数组里存入一个单词都会在后面加一个空格，直到加到最后一个单词，也就多了一个空格，因此加一是为了防止数组下标越界
        int resIndex=0;//字符数组下标
        //从后往前遍历字符串，空格作为分隔符
        int i=s.length()-1;
        while(i>=0){
            //从后向前去掉空格
            while(i>=0&&s.charAt(i)==' '){
                i--;
            }
            int end=i;//记录单词末尾字符下标
            while(i>=0&&s.charAt(i)!=' '){//计算单词起始下标
                i--;
            }
            for(int j=i+1;j<=end;j++){
                //将单词字符加入字符数组中
                res[resIndex++]=s.charAt(j);
                //当单词加入完毕后，要加空格
                if(j==end){
                    res[resIndex++]=' ';
                }
            }
        }
        return new String(res,0,resIndex-1);
    }
} 
>```

### 4、找出字符串中第一个匹配项的下标

> [!NOTE]- [28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)
>```java
>class Solution {
    public int strStr(String haystack, String needle) {
        if(needle.length()==0){
            return -1;
        }
        int j=-1;
        int[] next=new int[needle.length()];
        getNext(next,needle);
        for(int i=0;i<haystack.length();i++){
            while(j>=0&&haystack.charAt(i)!=needle.charAt(j+1)){
                j=next[j];
            }
            if(haystack.charAt(i)==needle.charAt(j+1)){
                j++;
            }
            if(j==needle.length()-1){
                return i-needle.length()+1;
            }
        }
        return -1;
    }
    public void getNext(int[] next,String needle){
        int j=-1;
        next[0]=j;
        for(int i=1;i<needle.length();i++){
            while(j>=0&&needle.charAt(i)!=needle.charAt(j+1)){
                j=next[j];
            }
            if(needle.charAt(i)==needle.charAt(j+1)){
                j++;
            }
            next[i]=j;
        }
    }
} 
>```
### 5、重复的子字符串

> [!NOTE]- [459. 重复的子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/repeated-substring-pattern/description/)
>```java
>class Solution {
    public boolean repeatedSubstringPattern(String s) {
        //判断字符串是否由重复子串组成，只要将两个s拼接起来，如果里面还出现一个一个s就说明是重复子串组成
        String res=s+s;
        return res.substring(1,res.length()-1).contains(s);
    }
} 
>```

## 双指针
### 1、移除元素

> [!NOTE]- [27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/)
>```java
>class Solution {
    public int removeElement(int[] nums, int val) {
        int slow=0;
        for(int fast=0;fast<nums.length;fast++){
            if(nums[fast]!=val){
                nums[slow++]=nums[fast];
                continue;
            }
        }
        return slow;
    }
} 
>```
### 2、反转字符串

> [!NOTE]- [344. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/)
>```java
>class Solution {
    public void reverseString(char[] s) {
        int left=0;
        int right=s.length-1;
        while(left<right){
            s[left]^=s[right];
            s[right]^=s[left];
            s[left]^=s[right];
            left++;
            right--;
        }
    }
} 
>```
### 3、反转字符串中的单词

> [!NOTE]- [151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/)
> class Solution {
    public String reverseWords(String s) {
        char[] res=new char[s.length()+1];
        int resIndex=0;
        for(int i=s.length()-1;i>=0;i--){
            while(i>=0&&s.charAt(i)==' '){
                i--;
            }
            int right=i;
            while(i>=0&&s.charAt(i)!=' '){
                i--;
            }
            for(int j=i+1;j<=right;j++){
                res[resIndex++]=s.charAt(j);
                if(j==right){
                    res[resIndex++]=' ';
                }
            }
        }
        return new String(res,0,resIndex-1);
    }
}
### 4、反转链表

> [!NOTE]- [206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)
>```java
>class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur=head;
        ListNode temp=null;
        ListNode pre=null;
        while(cur!=null){
            temp=cur.next;
            cur.next=pre;
            pre=cur;
            cur=temp;
        }
        return pre;
    }
} 
>```
### 5、删除链表中倒数第 n 个节点

> [!NOTE]- [19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
>```java
>class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy=new ListNode(-1,head);
        ListNode slow=dummy;
        ListNode fast=dummy;
        for(int i=0;i<n;i++){
            fast=fast.next;
        }
        while(fast.next!=null){
            slow=slow.next;
            fast=fast.next;
        }
        slow.next=slow.next.next;
        return dummy.next;
    }
} 
>```
### 6、链表相交

> [!NOTE]- [面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)
>```java
>public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA==null||headB==null){
            return null;
        }
        int lenA=0;
        int lenB=0;
        ListNode curA=headA;
        ListNode curB=headB;
        while(curA!=null){
            curA=curA.next;
            lenA++;
        }
        while(curB!=null){
            curB=curB.next;
            lenB++;
        }
        curA=headA;
        curB=headB;
        if(lenA<lenB){
            int tempLen=lenA;
            lenA=lenB;
            lenB=tempLen;
            ListNode tempNode=curA;
            curA=curB;
            curB=tempNode;
        }
        int gap=lenA-lenB;
        for(int i=0;i<gap;i++){
            curA=curA.next;
        }
        while(curA!=null){
            if(curA==curB){
                return curA;
            }
            curA=curA.next;
            curB=curB.next;
        }
        return null;
    }
} 
>```

### 7、环形链表 2

> [!NOTE]- [142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/)
>```java
>public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow=head;
        ListNode fast=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow){
                ListNode start=head;
                ListNode end=fast;
                while(start!=end){
                    start=start.next;
                    end=end.next;
                }
                return end;
            }
        }
        return null;
    }
} 
>```

### 8、三数之和

> [!NOTE]- [15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/)
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res=new ArrayList<>();
        Arrays.sort(nums);
        for(int i=0;i<nums.length;i++){
            if(nums[i]>0){
                return res;
            }
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }
            int left=i+1;
            int right=nums.length-1;
            while(left<right){
                int sum=nums[i]+nums[left]+nums[right];
                if(sum>0){
                    right--;
                }else if(sum<0){
                    left++;
                }else{
                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    while(left<right&&nums[right]==nums[right-1]){
                        right--;
                    }
                    while(left<right&&nums[left]==nums[left+1]){
                        left++;
                    }
                    right--;
                    left++;
                }
            }
        }
        return res;
    }
}
```
### 9、四数之和

> [!NOTE]- [18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/)
```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res=new ArrayList<>();
        Arrays.sort(nums);
        for(int i=0;i<nums.length;i++){
            if(nums[i]>0&&nums[i]>target){
                return res;
            }
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }
            for(int j=i+1;j<nums.length;j++){
                if(j>i+1&&nums[j]==nums[j-1]){
                    continue;
                }
                int left=j+1;
                int right=nums.length-1;
                while(left<right){
                    long sum=(long)nums[i]+nums[j]+nums[left]+nums[right];
                    if(sum>target){
                        right--;
                    }else if(sum<target){
                        left++;
                    }else{
                        res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));
                        while(left<right&&nums[right]==nums[right-1]){
                            right--;
                        }
                        while(left<right&&nums[left]==nums[left+1]){
                            left++;
                        }
                        right--;
                        left++;
                    }
                }
            }
        }
        return res;
    }
}
```
## 栈与队列
### 1、用栈实现队列

> [!NOTE]- [232. 用栈实现队列 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-queue-using-stacks/)
```java
class MyQueue {
    Stack<Integer> stackIn;//进入队列
    Stack<Integer> stackOut;//出队
    public MyQueue() {
        stackIn=new Stack<>();
        stackOut=new Stack<>();
    }
    //进队操作
    public void push(int x) {
        stackIn.push(x);
    }
    //出队操作
    public int pop() {
        //先将进入栈中的数据导入出队栈中
        dumpSatckIn();
        //将出队栈中顶部元素移出就是将模拟队列的首个元素移出
        return stackOut.pop();
    }
    //获取队列头元素
    public int peek() {
        //将进入栈中的数据导入出队栈
        dumpSatckIn();
        //获取出队栈中顶部元素
        return stackOut.peek();
    }
    
    public boolean empty() {
        return stackIn.isEmpty()&&stackOut.isEmpty();
    }
    public void dumpSatckIn(){
        //如果出队栈中还有数据，就直接移出，不用将进队栈中的数据导入
        if(!stackOut.isEmpty()){
            return;
        }
        //如果出队栈中没有数据才将进队栈中数据导入
        while(!stackIn.isEmpty()){
            stackOut.push(stackIn.pop());
        }
    }

}
```
### 2、用队列实现栈

> [!NOTE]- [225. 用队列实现栈 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-stack-using-queues/)
```java
class MyStack {
    Queue<Integer> queue1;//主队列
    Queue<Integer> queue2;//辅助队列
    public MyStack() {
        queue1=new LinkedList<>();
        queue2=new LinkedList<>();
    }
    //倒序加入
    public void push(int x) {
        queue2.offer(x);//先存入辅助队列
        //再将主队列中的元素加入辅助队列
        while(!queue1.isEmpty()){
            queue2.offer(queue1.poll());
        }
        //交换队列，此时queue2的队头就是栈顶
        Queue<Integer> queueTemp=queue2;
        queue2=queue1;
        queue1=queueTemp;
    }
    
    public int pop() {
        return queue1.poll();
    }
    
    public int top() {
        return queue1.peek();
    }
    
    public boolean empty() {
        return queue1.isEmpty();
    }
}
```

### 3、有效的括号

> [!NOTE]- [20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/)
```java
class Solution {
    public boolean isValid(String s) {
        //现有左括号在匹配右括号，一上来就是右括号那就无法匹配
        Deque<Character> stack=new LinkedList<>();
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='('){
                stack.push(')');
            }else if(s.charAt(i)=='['){
                stack.push(']');
            }else if(s.charAt(i)=='{'){
                stack.push('}');
            }else if(stack.isEmpty()||stack.peek()!=s.charAt(i)){//左括号还没出来右括号就先出来了，右括号与最近的左括号不匹配
                return false;
            }else{//左括号与右括号匹配
                stack.poll();
            }
        }
        //如果最后栈元素为空，说明所有括号都匹配了
        return stack.isEmpty();
    }
}
```
### 4、删除字符创中所有相邻的重复项

> [!NOTE]- [1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)
```java
class Solution {
    public String removeDuplicates(String s) {
        Deque<Character> stack=new ArrayDeque<>();
        for(int i=0;i<s.length();i++){
            char c=s.charAt(i);
            if(stack.isEmpty()||stack.peek()!=c){//栈为空或当前字符不等于栈顶字符，就可以加入
                stack.push(c);
            }else{//相等就去除
                stack.pop();
            }
        }
        String res="";
        while(!stack.isEmpty()){
            res=stack.pop()+res;
        }
        return res;
    }
}
```
### 5、逆波兰表达式求值

> [!NOTE]- [150. 逆波兰表达式求值 - 力扣（LeetCode）](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)
```java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> stack=new LinkedList<>();
        for(String s:tokens){
            if("+".equals(s)){
                stack.push(stack.pop()+stack.pop());
            }else if("-".equals(s)){
                stack.push(-stack.pop()+stack.pop());//先入栈的减去后入栈的
            }else if("*".equals(s)){
                stack.push(stack.pop()*stack.pop());
            }else if("/".equals(s)){//先入栈的除以后入栈的
                int second=stack.pop();
                int first=stack.pop();
                stack.push(first/second);
            }else{//不是运算符入栈
                stack.push(Integer.valueOf(s));
            }
        }
        return stack.pop();
    }
}
```
### 6、滑动窗口最大值

> [!NOTE]- [239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/)
```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> queue=new ArrayDeque<>();//模拟单调队列
        int len=nums.length;
        int[] res=new int[len-k+1];//结果数组，本以为是len-1,但len=1,k=1这种情况就不符合
        int index=0;//结果数组下标
        for(int i=0;i<nums.length;i++){
            //单调队列队头存放最大值下标
            //判断队头元素的下标是否在
            while(!queue.isEmpty()&&queue.peek()<i-k+1){
                queue.poll();//去掉头部元素
            }
            while(!queue.isEmpty()&&nums[queue.peekLast()]<nums[i]){//每次入队都大于前面的数的话，前面的数就永无翻身之日
                queue.pollLast();
            }
            queue.offer(i);
            if(i>=k-1){
                res[index++]=nums[queue.peek()];
            }
        }
        return res;
    }
}
```
### 7、前 k 个高频元素

> [!NOTE]- [347. 前 K 个高频元素 - 力扣（LeetCode）](https://leetcode.cn/problems/top-k-frequent-elements/)
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer,Integer> map=new HashMap<>();//key为值，value为出现次数
        int[] res=new int[k];
        for(int num:nums){//统计每个值出现的次数
            map.put(num,map.getOrDefault(num,0)+1);
        }
        //设置优先级队列，按照值的次数进行排序
        PriorityQueue<int[]> queue=new PriorityQueue<>((pair1,pair2)-> pair2[1]-pair1[1]);
        for(Map.Entry<Integer,Integer> entry:map.entrySet()){
            queue.add(new int[]{entry.getKey(),entry.getValue()});
        }
        //获取前k个值
        for(int i=0;i<k;i++){
            res[i]=queue.poll()[0];
        }
        return res;
    }
}
```
## 二叉树
### 1、二叉树前序遍历 (递归方式)

> [!NOTE]- [144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result=new ArrayList<>();
        preorder(root,result);
        return result;
    }
    private void preorder(TreeNode node,List<Integer> res){
        if(node==null){
            return;
        }
        res.add(node.val);//当前节点不为空，加入结果集合
        preorder(node.left,res);//先遍历左节点
        preorder(node.right,res);//再遍历右节点
    }
}
```
### 2、二叉树后序遍历 (递归方式)

> [!NOTE]- [145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/)
```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result=new ArrayList<>();
        postorder(root,result);
        return result;
    }
    private void postorder(TreeNode node,List<Integer> res){
        if(node==null){
            return;
        }
        postorder(node.left,res);
        postorder(node.right,res);
        res.add(node.val);
    }
}
```
### 3、二叉树中序遍历 (递归方式)

> [!NOTE]- [94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result=new ArrayList<>();
        inorder(root,result);
        return result;
    }
    private void inorder(TreeNode node,List<Integer> res){
        if(node==null){
            return;
        }
        inorder(node.left,res);
        res.add(node.val);
        inorder(node.right,res);
    }
}
```
### 4、二叉树前序遍历 (迭代方式)

> [!NOTE]- [144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result=new ArrayList<>();
        if(root==null){
            return result;
        }
        Stack<TreeNode> stack=new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode cur=stack.pop();
            result.add(cur.val);
            if(cur.right!=null){
                stack.push(cur.right);
            }
            if(cur.left!=null){
                stack.push(cur.left);
            }
        }
        return result;
    }
}
```
### 5、二叉树的中序遍历 (迭代方式)

> [!NOTE]- [94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result=new ArrayList<>();
        if(root==null){
            return result;
        }
        TreeNode cur=root;
        Stack<TreeNode> stack=new Stack<>();
        while(cur!=null||!stack.isEmpty()){
            if(cur!=null){
                stack.push(cur);
                cur=cur.left;
            }else{
                cur=stack.pop();
                result.add(cur.val);
                cur=cur.right;
            }
        }
        return result;
    }
}
```
### 6、二叉树后序遍历 (迭代方式)

> [!NOTE]- [145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/)
```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result=new ArrayList<>();
        if(root==null){
            return result;
        }
        Stack<TreeNode> stack=new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode cur=stack.pop();
            result.add(cur.val);
            if(cur.left!=null){
                stack.push(cur.left);
            }
            if(cur.right!=null){
                stack.push(cur.right);
            }
        }
        Collections.reverse(result);
        return result;
    }
}
```
### 7、二叉树层序遍历

> [!NOTE]- [102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result=new ArrayList<>();
        if(root==null){
            return result;
        }
        Queue<TreeNode> queue=new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> list=new ArrayList<>();
            int len=queue.size();
            while(len-->0){
                TreeNode cur=queue.poll();
                list.add(cur.val);
                if(cur.left!=null){
                    queue.offer(cur.left);
                }
                if(cur.right!=null){
                    queue.offer(cur.right);
                }
            }
            result.add(list);
        }
        return result;
    }
}
```
### 8、翻转二叉树 

> [!NOTE]- [226. 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/)
```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null){
            return null;
        }
        //前序遍历交换左右子节点
        swap(root);
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
    private void swap(TreeNode node){
        TreeNode temp=node.left;
        node.left=node.right;
        node.right=temp;
    }
}
```
### 9、对称二叉树

> [!NOTE]- [101. 对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/symmetric-tree/)
```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return compare(root.left,root.right);
    }
    private boolean compare(TreeNode left,TreeNode right){
        if(left==null&&right!=null){
            return false;
        }
        if(right==null&&left!=null){
            return false;
        }
        if(left==null&&right==null){
            return true;
        }
        if(left.val!=right.val){
            return false;
        }
        boolean compareOutside=compare(left.left,right.right);
        boolean compareInside=compare(left.right,right.left);
        return compareOutside&&compareInside;
    }
}
```
### 10、二叉树最大深度

> [!NOTE]- [104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null){
            return 0;
        }
        int depth=0;
        Deque<TreeNode> queue=new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int len=queue.size();
            depth++;
            while(len-->0){
                TreeNode cur=queue.poll();
                if(cur.left!=null){
                    queue.offer(cur.left);
                }
                if(cur.right!=null){
                    queue.offer(cur.right);
                }
            }
        }
        return depth;
    }
}
```
### 11、n 叉树的最大深度

> [!NOTE]- [559. N 叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)
```java
class Solution {
    public int maxDepth(Node root) {
        if(root==null){
            return 0;
        }
        Deque<Node> queue=new LinkedList<>();
        int depth=0;
        queue.offer(root);
        while(!queue.isEmpty()){
            int len=queue.size();
            depth++;
            while(len-->0){
                Node cur=queue.poll();
                for(int i=0;i<cur.children.size();i++){
                    if(cur.children.get(i)!=null){
                        queue.offer(cur.children.get(i));
                    }
                }
            }
        }
        return depth;
    }
}
```
### 12、二叉树的最小深度

> [!NOTE]- [111. 二叉树的最小深度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
```java
class Solution {
    public int minDepth(TreeNode root) {
    //只有左右子树都为空才满足叶子结点
        if(root==null){
            return 0;
        }
        int minLeft=minDepth(root.left);//获取左子树的最小深度
        int minRight=minDepth(root.right);//获取右子树的最小深度
        if(root.left==null&&root.right!=null){//如果左子树为空，右子树不为空，那么左子树肯定不满足叶子结点条件
            return minRight+1;
        }
        if(root.right==null&&root.left!=null){
            return minLeft+1;
        }
        return Math.min(minLeft,minRight)+1;
    }
}
```
### 13、完全二叉树的节点个数

> [!NOTE]- [222. 完全二叉树的节点个数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-complete-tree-nodes/)
```java
class Solution {
    public int countNodes(TreeNode root) {
        int result=0;//记录节点个数
        if(root==null){//根节点为空返回0
            return 0;
        }
        Deque<TreeNode> queue=new LinkedList<>();//层序遍历采用队列存储
        queue.offer(root);
        while(!queue.isEmpty()){
            int len=queue.size();//当前层的节点个数
            while(len-->0){
                result++;//每出队一个节点，记录一个一个节点
                TreeNode cur=queue.poll();
                if(cur.left!=null){
                    queue.offer(cur.left);
                }
                if(cur.right!=null){
                    queue.offer(cur.right);
                }
            }
        }
        return result;
    }
}
```
```java
class Solution {
    public int countNodes(TreeNode root) {
         if (root == null) return 0;
        TreeNode left = root.left;
        TreeNode right = root.right;
        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求子数方便
        while (left != null) {  // 求左子树深度
            left = left.left;
            leftDepth++;
        }
        while (right != null) { // 求右子树深度
            right = right.right;
            rightDepth++;
        }
        if (leftDepth == rightDepth) {
            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0
        }
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```

### 14、平衡二叉树

> [!NOTE] [110. 平衡二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/balanced-binary-tree/
```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        //平衡二叉树的左右子树高度差不能超过1
        return getHeight(root)!=-1;
    }
    private int getHeight(TreeNode root){//后序遍历求高度差
        if(root==null){
            return 0;
        }
        int leftHeight=getHeight(root.left);//求左子树的深度
        if(leftHeight==-1){
            return -1;//说明左子树的子树高度差超过了1
        }
        int rightHeight=getHeight(root.right);//求右子树深度
        if(rightHeight==-1){
            return -1;//说明右子树的子树高度差超过了1
        }
        //如果当前节点的左右子树高度差超过了1，那就返回-1
        if(Math.abs(leftHeight-rightHeight)>1){
            return -1;
        }
        //高度差没有超过1，深度加一
        return Math.max(leftHeight,rightHeight)+1;
    }
}
```

### 15、二叉树的所有路径
> [!NOTE] [257. 二叉树的所有路径 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-paths/)
```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res=new ArrayList<>();//结果集
        if(root==null){
            return null;
        }
        List<Integer> path=new ArrayList<>();
        traversal(root,path,res);
        return res;
    }
    private void traversal(TreeNode root,List<Integer> path,List<String> res){
        path.add(root.val);//前序遍历
        if(root.left==null&&root.right==null){
            //左右子节点都为空，将路径加入结果集
            StringBuilder sb=new StringBuilder();
            //将路径节点拼接为字符串
            int i=0;
            for(;i<path.size()-1;i++){
                sb.append(path.get(i)).append("->");
            }
            //加入最后一个节点
            sb.append(path.get(i));
            res.add(sb.toString());
            return;
        }
        if(root.left!=null){
            traversal(root.left,path,res);
            //回溯
            path.remove(path.size()-1);
        }
        if(root.right!=null){
            traversal(root.right,path,res);
            path.remove(path.size()-1);
        }
    }
}
```

### 16、左叶子之和

> [!NOTE] [404. 左叶子之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-left-leaves/)
```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root==null){
            return 0;
        }
        //后序遍历
        int leftValue=sumOfLeftLeaves(root.left);//左子树左叶子之和
        int rightValue=sumOfLeftLeaves(root.right);//右子树左叶子之和
        int midValue=0;
        //当前节点不为空且左节点的左节点为空，左节点的右节点为空
        if(root.left!=null&&root.left.left==null&&root.left.right==null){
            midValue=root.left.val;
        }
        int sum=midValue+rightValue+leftValue;
        return sum;
    }
}
```
### 17、找数左下角的值

> [!NOTE] [513. 找树左下角的值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-bottom-left-tree-value/)
```java
class Solution {
    private int maxDeep=0;//记录最大深度
    private int res;
    public int findBottomLeftValue(TreeNode root) {
        res=root.val;
        findLeftValue(root,0);
        return res;
    }
    private void findLeftValue(TreeNode root,int deep){
        if(root==null){
            return;//递归出口
        }
        //前序遍历获取值
        //当前深度大于最大深度，就替换最大深度，前提是叶子结点
        //注意：不是找最左叶子结点的值，而是找最底层最左边的值
        if(root.left==null&&root.right==null){
            if(deep>maxDeep){
                maxDeep=deep;
                res=root.val;
                return;
            }
        }
        findLeftValue(root.left,deep+1);
        findLeftValue(root.right,deep+1);
    }
}
```
### 18、路径总和

> [!NOTE] [112. 路径总和 - 力扣（LeetCode）](https://leetcode.cn/problems/path-sum/)
```java
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root==null){
            return false;
        }
        //每向下递归一次，targetSum都会减去上一个节点的val值，当到达叶子结点时，如果targetSum等于叶子结点值说明满足条件
        if(root.left==null&&root.right==null){//如果当前节点为叶子结点，且当前节点值等于targetSum
            return targetSum==root.val; 
        }
        if(hasPathSum(root.left,targetSum-root.val)){//遍历左子树
            return true;
        }
        if(hasPathSum(root.right,targetSum-root.val)){
            //遍历右子树
            return true;
        }
        return false;
    }
}
```
### 19、从中序与后序遍历序列构造二叉树

> [!NOTE] [106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
```java
class Solution {
    private Map<Integer,Integer> map=new HashMap<>();//存放元素和下标
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        for(int i=0;i<inorder.length;i++){
            map.put(inorder[i],i);
        }
        return findNode(inorder,0,inorder.length,postorder,0,postorder.length);
    }
    private TreeNode findNode(int[] inorder,int inBegin,int inEnd,int[] postorder,int postBegin,int postEnd){
        if(inBegin>=inEnd||postBegin>=postEnd){//没有元素了
            return null;
        }
        //找到后序数组中的最后一个元素，在根据該元素对中序数组进行分组
        //如何对后序数组进行分组？每次分出的中序数组个数与后序数组一致
        int index=map.get(postorder[postEnd-1]);
        TreeNode root=new TreeNode(inorder[index]);
        int leftLen=index-inBegin;//左边数组的个数
        root.left=findNode(inorder,inBegin,index,postorder,postBegin,postBegin+leftLen);
        root.right=findNode(inorder,index+1,inEnd,postorder,postBegin+leftLen,postEnd-1);//左闭右开,postEnd要减一，因为最后一个节点作为根节点
        return root;//返回根节点
    }
}
```
### 20、从前序与中序序列构造二叉树

> [!NOTE] [105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
```java
class Solution {
    private Map<Integer,Integer> map=new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for(int i=0;i<inorder.length;i++){
            map.put(inorder[i],i);
        }
        return findNode(preorder,0,preorder.length,inorder,0,inorder.length);
    }
    private TreeNode findNode(int[] preorder,int preBegin,int preEnd,int[] inorder,int inBegin,int inEnd){
        if(preBegin>=preEnd||inBegin>=inEnd){
            return null;
        }
        //获取前序数组第一个元素
        int first=preorder[preBegin];
        //获取在中序数组中对应的下标
        int index=map.get(first);
        TreeNode root=new TreeNode(inorder[index]);
        int leftLen=index-inBegin+1;
        root.left=findNode(preorder,preBegin+1,preBegin+leftLen,inorder,inBegin,index);
        root.right=findNode(preorder,preBegin+leftLen,preEnd,inorder,index+1,inEnd);
        return root;
    }
}
```

### 21、最大二叉树

> [!NOTE]- [654. 最大二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-binary-tree/)

```java
class Solution {

    public TreeNode constructMaximumBinaryTree(int[] nums) {

        return maxTree(nums,0,nums.length-1);

    }

    private TreeNode maxTree(int[] nums,int begin,int end){

        if(begin>end){

            return null;

        }

        if(begin==end){//数组不能在分割了

            return new TreeNode(nums[begin]);

        }

        //怎么找出最大值的下标

        int maxValue=0;//记录最大值

        int index=0;//记录最大值的下标

        for(int i=begin;i<=end;i++){

            if(nums[i]>maxValue){

                maxValue=nums[i];

                index=i;

            }

        }

        //构造根节点

        TreeNode root=new TreeNode(maxValue);

        root.left=maxTree(nums,begin,index-1);//构造左子树

        root.right=maxTree(nums,index+1,end);//构造右子树

        return root;

    }

}
```
### 22、合并二叉树

> [!NOTE]- [617. 合并二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-binary-trees/)
```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1==null){
            return root2;
        }
        if(root2==null){
            return root1;
        }
        root1.val+=root2.val;
        root1.left=mergeTrees(root1.left,root2.left);
        root1.right=mergeTrees(root1.right,root2.right);
        return root1;//将root1作为结果树
    }
}
```
### 23、二叉搜索树中的搜索

> [!NOTE]- [700. 二叉搜索树中的搜索 - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-a-binary-search-tree/)
```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if(root==null){
            return null;
        }
        if(root.val==val){
            return root;
        }else if(val<root.val){
            return searchBST(root.left,val);
        }else{
            return searchBST(root.right,val);
        }   
    }
}
```
### 24、验证二叉搜索树

> [!NOTE]- [98. 验证二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/)
```java
class Solution {//中序序列下，二叉搜索树节点值是递增的
    public boolean isValidBST(TreeNode root) {//树中节点个数大于0，不用进行判断根节点是否为空
        Stack<TreeNode> stack=new Stack<>();//使用迭代法
        TreeNode cur=root;//代表当前节点
        TreeNode pre=null;//代表上一个节点
        while(cur!=null||!stack.isEmpty()){//当stack为空，cur不为空时，说明根节点的左子树都遍历完了，右子树还有节点
            //前
            while(cur!=null){
                stack.push(cur);
                cur=cur.left;
            }
            //中,如果当前节点的值小于等于前一个节点的值，说明不满足二叉搜索树条件
            cur=stack.pop();
            if(pre!=null&&cur.val<=pre.val){//pre指的不是栈中的前一个节点，而是中序数组中的前一个节点
                return false;
            }
            //后，遍历右子树
            pre=cur;
            cur=cur.right;
        }
        return true;
    }
}
```
### 25、二叉搜索树的最小绝对差

> [!NOTE]- [530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)
```java
class Solution {//二叉搜索树中序遍历为有序数组
    public int getMinimumDifference(TreeNode root) {
        Stack<TreeNode> stack=new Stack<>();
        int res=Integer.MAX_VALUE;//记录最小值
        TreeNode cur=root;//记录当前节点
        TreeNode pre=null;
        while(cur!=null||!stack.isEmpty()){//中序遍历
            while(cur!=null){
                stack.push(cur);
                cur=cur.left;
            }
            cur=stack.pop();//获取栈顶元素
            if(pre!=null){
                res=Math.min(res,cur.val-pre.val);//获取最小差值
            }
            pre=cur;
            cur=cur.right;
        }
        return res;
    }
}
```
### 26、二叉搜索树中的众数

> [!NOTE]- [501. 二叉搜索树中的众数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)
```java
class Solution {
    public int[] findMode(TreeNode root) {
        Stack<TreeNode> stack=new Stack<>();
        List<Integer> res=new ArrayList<>();//保存出现频率最高的元素，不能确定其元素个数所以用集合
        int maxCount=0;
        int count=0;//记录遍历过程中每个数出现的次数
        TreeNode cur=root;
        TreeNode pre=null;
        while(cur!=null||!stack.isEmpty()){
            if(cur!=null){
                stack.push(cur);
                cur=cur.left;
            }else{
                cur=stack.pop();
                if(pre==null||cur.val!=pre.val){
                    count=1;
                }else{
                    count++;
                }
                //注意：可能存在多个数出现的频率一致
                if(count>maxCount){
                    maxCount=count;
                    //清空集合
                    res.clear();
                    res.add(cur.val);
                }else if(count==maxCount){
                    res.add(cur.val);
                }
                pre=cur;
                cur=cur.right;
            }
        }
        return res.stream().mapToInt(Integer::intValue).toArray();
    }
}
```
### 27、二叉树的最近公共祖先

> [!NOTE]- [236. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //递归出口
        if(root==null||p==root||q==root){
            return root;
        }
        //后序遍历。从下往上遍历
        TreeNode left=lowestCommonAncestor(root.left,p,q);//如果遍历左子树的时候已经找到了最近公共祖先，那么右子树一定为空，因为不包含重复的节点
        TreeNode right=lowestCommonAncestor(root.right,p,q);
        if(left==null&&right==null){
            return null;
        }else if(left!=null&&right==null){
            return left;
        }else if(right!=null&&left==null){
            return right;
        }else{
            return root;
        }
    }
}
```
### 28、二叉搜索树的最近公共祖先

> [!NOTE]- [235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        //向下遍历第一个介于pq数值之间(包括相等)的节点就是最近公共祖先
        while(true){
            if(root.val>p.val&&root.val>q.val){
                root=root.left;
            }else if(root.val<p.val&&root.val<q.val){
                root=root.right;
            }else{//相当于介于pq数值之间，不管pq谁的数值大，还需要注意的是祖先可能是自己，所以要包括等于的情况
                break;
            }
        }
        return root;
    }
}
```

### 29、二叉搜索树中的插入操作

> [!NOTE]- [701. 二叉搜索树中的插入操作 - 力扣（LeetCode）](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)
```java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        //遍历到叶子结点
        if(root==null){//根节点为空
            return new TreeNode(val);
        }
        TreeNode cur=root;//记录当前节点
        TreeNode pre=root;//记录前一个节点
        while(cur!=null){//当cur为空时，说明到了叶子结点
            pre=cur;
            if(val<cur.val){//目标值小于当前值，应该插入左子树
                cur=cur.left;
            }else{
                cur=cur.right;
            }
        }
        //此时pre为叶子结点，判断是插在左节点还是右节点
        if(val<pre.val){//插入左节点
            pre.left=new TreeNode(val);
        }else{
            pre.right=new TreeNode(val);//因为节点值是不重复的，不用考虑相等的情况
        }
        return root;//返回根节点
    }
}
```

### 30、删除二叉搜索树中的节点

> [!NOTE]- [450. 删除二叉搜索树中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-node-in-a-bst/)
```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root==null){//如果遍历到为空的情况，说明key不存在与二叉搜索树中
            return null;
        }
        if(key==root.val){
            if(root.left==null){
                return root.right;
            }else if(root.right==null){
                return root.left;
            }else{
                TreeNode cur=root.right;
                TreeNode parent=root.right;
                while(cur.left!=null){
                    cur=cur.left;
                }
                cur.left=root.left;
                return parent;
            }
        }
        if(key<root.val){
            root.left=deleteNode(root.left,key);
        }
        if(key>root.val){
            root.right=deleteNode(root.right,key);
        }
        return root;
    }
}
```

### 31、修建二叉搜索树
> [!NOTE]- [669. 修剪二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/trim-a-binary-search-tree/description/)
```java
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root==null){
            return null;
        }
        //如果当前节点小于最小值，，那就将右子树返回
        if(root.val<low){
            return trimBST(root.right,low,high);
        }
        //如果当前节点大于最大值，那就返回左子树
        if(root.val>high){
            return trimBST(root.left,low,high);
        }
        
        //在范围内，就遍历左子树
        root.left=trimBST(root.left,low,high);
        //遍历右子树
        root.right=trimBST(root.right,low,high);
        return root;
    }
}
```

### 32、将有序数组转为二叉搜索树

> [!NOTE]- [108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/)
```java
class Solution {//关键点：将中间节点作为根节点
    public TreeNode sortedArrayToBST(int[] nums) {
        return sortedArrayToBST(nums,0,nums.length-1);
    }
    private TreeNode sortedArrayToBST(int[] nums,int begin,int end){
        //因为要求平衡二叉树，所以根节点一定是中间节点
        //每次找中间节点作为根节点
        if(begin>end){//左闭右闭区间
            return null;
        }
        if(begin==end){
            return new TreeNode(nums[begin]);
        }
        int mid=(begin+end)>>1;//获取中间结点下标
        TreeNode root=new TreeNode(nums[mid]);//将中间节点作为根节点
        //获取左节点和右节点
        root.left=sortedArrayToBST(nums,begin,mid-1);
        root.right=sortedArrayToBST(nums,mid+1,end);
        return root;
    }
}
```
### 33、把二叉搜索树转为累加树

> [!NOTE]- [538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-bst-to-greater-tree/)
```java
class Solution {//右中左遍历
    int sum;
    public TreeNode convertBST(TreeNode root) {
        sum=0;
        traverse(root);//我们只需要在遍历的过程中将节点的值进行修改，不需要返回值
        return root;
    }
    private void traverse(TreeNode root){
        if(root==null){
            return;
        }
        traverse(root.right);
        sum+=root.val;//记录每次累加的和，将累加的和赋给当前节点
        root.val=sum;
        traverse(root.left);
    }
}
```

## 回溯
### 1、组合

> [!NOTE]- [77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/)
```java
class Solution {
    LinkedList<Integer> list=new LinkedList<>();//存储每个组合,用LinkedList方便删除最后一个·元素
    List<List<Integer>> res=new ArrayList<>();//存放结果组合
    public List<List<Integer>> combine(int n, int k) {
        combineHelper(1,n,k);
        return res;
    }
    private void combineHelper(int startIndex,int n,int k){
        //当集合元素个数到达k个时，进行回溯
        if(list.size()==k){
            res.add(new ArrayList<>(list));
            return;
        }
        //组合不包含顺序，每次组合不能重头开始
        for( int i=startIndex;i<=n;i++){
            list.add(i);
            combineHelper(i+1,n,k);
            list.removeLast();//删除最后一个元素
        }
    }
}
```
### 2、组合总和 III

> [!NOTE]- [216. 组合总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iii/)
```java
class Solution {
    LinkedList<Integer> list=new LinkedList<>();//存放组合数组
    List<List<Integer>> res=new ArrayList<>();//结果数组
    public List<List<Integer>> combinationSum3(int k, int n) {
        combinHelper(1,k,n,0);
        return res;
    }
    private void combinHelper(int startIndex,int k,int n,int sum){
      if(list.size()>k||sum>n){
        return;
      }
      if(list.size()==k&&sum==n){
          res.add(new ArrayList<>(list));
          return;
      }
      for(int i=startIndex;i<=9;i++){
          list.add(i);
          combinHelper(i+1,k,n,sum+i);
          list.removeLast();
      }
    }
}
```

### 3、电话号码的字母组合

> [!NOTE]- [17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)
```java
class Solution {
    List<String> res=new ArrayList<>();//结果集
    StringBuilder sb=new StringBuilder();//存放每次的组合
    public List<String> letterCombinations(String digits) {
        if(digits==null||digits.length()==0){
            return res;
        }
        //使用map集合或者数组存放数字与字母的映射关系
        String[] numString={"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
        //使用回溯算法进行组合
        letterCombin(digits,numString,0);
        return res;
    }
    private void letterCombin(String digits,String[] numString,int num){//num代表digits字符串的下标
        if(num==digits.length()){
            res.add(sb.toString());
            return;
        }
        //根据num获取didits的数字,根据数字找到对应的字母字符串
        String str=numString[digits.charAt(num)-'0'];
        for(int i=0;i<str.length();i++){
            sb.append(str.charAt(i));
            letterCombin(digits,numString,num+1);
            //剪枝
            sb.deleteCharAt(sb.length()-1);
        }
    }
}
```
### 4、组合总和

> [!NOTE]- [39. 组合总和 - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum/)
```java
class Solution {
    List<List<Integer>> res=new ArrayList<>();//结果集
    LinkedList<Integer> list=new LinkedList<>();//存放组合
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);//将数组进行排序，方便剪枝
        combinationSum(candidates,target,0,0);
        return res;
    }
    private void combinationSum(int[] candidates,int target,int num,int startIndex){
        if(num==target){
            res.add(new ArrayList<>(list));
            return;
        }
        for(int i=startIndex;i<candidates.length;i++){
            if(num+candidates[i]>target){
                break;//因为进行了排序操作，所以后面数的都会大于target,直接结束循环
            }
            list.add(candidates[i]);
            combinationSum(candidates,target,num+candidates[i],i);
            list.removeLast();//剪枝
        }
    }
}
```

### 5、组合总和 II

> [!NOTE]- [40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/)
```java
class Solution {
    List<List<Integer>> res=new ArrayList<>();//保存结果集
    LinkedList<Integer> list=new LinkedList<>();//保存组合
    boolean[] userd;//标记数组，用来表示同层树中节点是否遍历
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        userd=new boolean[candidates.length];
        //默认标记数组全为false
        Arrays.fill(userd,false);
        Arrays.sort(candidates);//排序
        combinationSum2(candidates,target,0,0);
        return res;
    }
    private void combinationSum2(int[] candidates,int target,int sum,int startIndex){
        if(sum==target){
            res.add(new ArrayList<>(list));
            return;
        }
        for(int i=startIndex;i<candidates.length;i++){
            if(sum+candidates[i]>target){//因为排序过，当前节点不满足，那后续节点也不会满足
                break;
            }
            //如果出现且被遍历过,同层节点
            if(i>0&&candidates[i]==candidates[i-1]&&!userd[i-1]){
                continue;
            }
            userd[i]=true;//代表当前节点已被遍历
            list.add(candidates[i]);
            combinationSum2(candidates,target,sum+candidates[i],i+1);
            userd[i]=false;
            list.removeLast();//剪枝
        }
    }
}
```
### 6、分割回文串

> [!NOTE]- [131. 分割回文串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-partitioning/)
```java
class Solution {
    List<List<String>> res=new ArrayList<>();//结果集
    LinkedList<String> list=new LinkedList<>();
    public List<List<String>> partition(String s) {
        partition(s,0);
        return res;
    }
    private void partition(String s,int startIndex){//startIndex就是分割线
        //分割线到达了字符串长度就分割完毕
        if(startIndex==s.length()){
            res.add(new ArrayList<>(list));
            return;
        }
        for(int i=startIndex;i<s.length();i++){
            //判断是否是回文串
            if(isPalindrome(s,startIndex,i)){
                String str=s.substring(startIndex,i+1);
                list.add(str);
            }else{
                continue;
            }
            partition(s,i+1);
            list.removeLast();
        }
    }
    //判断是否是回文子串
    private boolean isPalindrome(String s,int startIndex,int end){
        int i=startIndex;
        int j=end;
        while(i<j){
            if(s.charAt(i)!=s.charAt(j)){
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
}
```

### 7、复原 ip 地址😭

> [!NOTE]- [93. 复原 IP 地址 - 力扣（LeetCode）](https://leetcode.cn/problems/restore-ip-addresses/)
```java
class Solution {
    List<String> res=new ArrayList<>();//保存结果集
    public List<String> restoreIpAddresses(String s) {
        backTrack(s,0,0);
        return res;
    }
    private void backTrack(String s,int startIndex,int pointNum){//startIndex代表分割位置，pointNum代表分割点的个数
        //如果分割点个数达到了3个，那剩余的字符串作为最后一个ip地址占位符
        if(pointNum==3){
            //判断最后的字符串是否可以作为ip地址
            if(isValid(s,startIndex,s.length()-1)){
                //纳入结果集
                res.add(s);
            }
            return;
        }
        for(int i=startIndex;i<s.length();i++){
            if(isValid(s,startIndex,i)){
                s=s.substring(0,i+1)+"."+s.substring(i+1);
                backTrack(s,i+2,pointNum+1);//因为多加了'.'，所以下次分割要多移一位
                s=s.substring(0,i+1)+s.substring(i+2);//去掉'.'
            }else{
                break;
            }
        }
    }
    //判断字符串是否可以作为ip地址
    private boolean isValid(String s,int start,int end){
        if(start>end){
            return false;
        }
        if(s.charAt(start)=='0'&&start!=end){
            return false;
        }//如果字符串以0开始且包含不为0的字符
        int num=0;//用来记录ip数值
        for(int i=start;i<=end;i++){
            //遇到非法字符
            if(s.charAt(i)>'9'||s.charAt(i)<'0'){
                return false;
            }
            num=num*10+(s.charAt(i)-'0');
            //如果ip数值大于255
            if(num>255){
                return false;
            }
        }
        return true;
    }
}
```

### 8、子集

> [!NOTE]- [78. 子集 - 力扣（LeetCode）](https://leetcode.cn/problems/subsets/)
```java
class Solution {
    LinkedList<Integer> list=new LinkedList<>();
    List<List<Integer>> res=new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        combine(nums,0);
        return res;
    }
    private void combine(int[] nums,int startIndex){
        res.add(new ArrayList<>(list));
        if(startIndex==nums.length){
            return;
        }
        for(int i=startIndex;i<nums.length;i++){
            list.add(nums[i]);
            combine(nums,i+1);
            list.removeLast();
        }
    }
}
```

### 9、子集 II

> [!NOTE]- [90. 子集 II - 力扣（LeetCode）](https://leetcode.cn/problems/subsets-ii/) 
```java
class Solution {
    List<List<Integer>> res=new ArrayList<>();
    LinkedList<Integer> list=new LinkedList<>();
    boolean[] userd;//标识数组
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        userd=new boolean[nums.length];
        Arrays.sort(nums);
        combine(nums,0);
        return res;
    }
    private void combine(int[] nums,int startIndex){
        res.add(new ArrayList<>(list));
        if(startIndex==nums.length){
            return;
        }
        for(int i=startIndex;i<nums.length;i++){
            //同层是否遍历过
            if(i>0&&nums[i]==nums[i-1]&&!userd[i-1]){
                continue;
            }
            userd[i]=true;
            list.add(nums[i]);
            combine(nums,i+1);
            userd[i]=false;
            list.removeLast();//剪枝
            
        }
    }
}
```

### 10、递增子序列

> [!NOTE]- [491. 递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/non-decreasing-subsequences/)
```java
class Solution {
    List<List<Integer>> res=new ArrayList<>();//结果集
    LinkedList<Integer> list=new LinkedList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        backTrace(nums,0);
        return res;
    }
    private void backTrace(int[] nums,int startIndex){
        //当序列长度大于等于2时，满足条件
        if(list.size()>=2){
            res.add(new ArrayList<>(list));
        }
        //当startIndex等于nums的长度时结束递归，其实可以不用写，但必须要体现出递归的思想
        if(startIndex==nums.length){
            return;
        }
        boolean[] used=new boolean[201];//标记数组，用来标记同层中访问过的元素，因题目要求nums[i]数值范围在-100到100,局部变量每次递归重新赋值
        for(int i=startIndex;i<nums.length;i++){
            //判断当前元素是否大于前面序列的最后一个元素，以及在同层遍历中前面是否遍历过相同的元素
            //这个判断既判断了同一树枝，也判断了同层节点
            if(!list.isEmpty()&&nums[i]<list.get(list.size()-1)||used[nums[i]+100]){
                continue;
            }
            used[nums[i]+100]=true;//标记访问过
            list.add(nums[i]);//当前节点满足条件
            backTrace(nums,i+1);
            list.removeLast();//剪枝
        }
    }
}
```

### 11、全排列

> [!NOTE]- [46. 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/)
```java
class Solution {
    List<List<Integer>> res=new ArrayList<>();
    LinkedList<Integer> list=new LinkedList<>();
    boolean[] used;
    public List<List<Integer>> permute(int[] nums) {
        if(nums.length==0){
            return res;
        }
        used=new boolean[nums.length];
        backTrace(nums);
        return res;
    }
    private void backTrace(int[] nums){
        //递归结束条件：排列个数达到了nums数组个数
        if(list.size()==nums.length){
            res.add(new ArrayList<>(list));
            return;
        }
        for(int i=0;i<nums.length;i++){
            if(used[i]){//被遍历过了
                continue;
            }
            list.add(nums[i]);
            used[i]=true;
            backTrace(nums);
            list.removeLast();
            used[i]=false;
        }
    }
}
```
### 12、全排列 II

> [!NOTE]- 全排列
```java
class Solution {
    List<List<Integer>> res=new ArrayList<>();
    LinkedList<Integer> list=new LinkedList<>();
    boolean[] used;
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        used=new boolean[nums.length];
        backTrace(nums);
        return res;
    }
    private void backTrace(int[] nums){
        if(list.size()==nums.length){
            //排列的结束条件都是叶子结点，集合元素个数等于总个数
            res.add(new ArrayList<>(list));
            return;
        }
        for(int i=0;i<nums.length;i++){
            //判断是否与前面的元素相同，且前面的元素已经遍历过了
            if(i>0&&nums[i]==nums[i-1]&&!used[i-1]){
                continue;
            }
            if(!used[i]){//同枝被遍历过得元素
                list.add(nums[i]);
                used[i]=true;
                backTrace(nums);
                used[i]=false;
                list.removeLast();
            }
            
        }
    }
}
```
### 13、N 皇后问题

> [!NOTE]- [51. N 皇后 - 力扣（LeetCode）](https://leetcode.cn/problems/n-queens/)
```java
class Solution {
    List<List<String>> res=new ArrayList<>();//结果集
    //同一行，同一列，同一45度只能出现一个皇后
    public List<List<String>> solveNQueens(int n) {
        //用一个二维字符数组表示一个棋盘
        char[][] chessboard=new char[n][n];
        //所有字符开始默认为.
        for(char[] c:chessboard){
            Arrays.fill(c,'.');
        }
        backTrace(chessboard,0,n);
        return res;
    }
    private void backTrace(char[][] chessboard,int row,int n){
        //每次递归向下一行遍历，行数等于n时结束递归
        if(row==n){
            //将棋盘加入结果集，注意结果集的每一行是字符串，先将字符数组转为字符串
            res.add(array2List(chessboard));
            return;
        }

        for(int i=0;i<n;i++){//遍历当前行的每个元素
            //判断当前是否皇后位置是否合法
            if(isValid(chessboard,row,i,n)){
                chessboard[row][i]='Q';
                backTrace(chessboard,row+1,n);
                chessboard[row][i]='.';
            }
        }
    }
    private List<String> array2List(char[][] chessboard){
        List<String> list=new ArrayList<>();
        //将二维字符数组的每一行转为字符串保存至list集合
        for(char[] c:chessboard){
            list.add(String.copyValueOf(c));
        }
        return list;
    }
    private boolean isValid(char[][] chessboard,int row,int col,int n){
        //同一列不能重复
        for(int i=0;i<row;i++){
            if(chessboard[i][col]=='Q'){
                return false;
            }
        }

        //检查45度对角线
        for(int i=row-1,j=col+1;i>=0&&j<n;i--,j++){
            if(chessboard[i][j]=='Q'){
                return false;
            }
        }
        //检查135度对角线
        for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--){
            if(chessboard[i][j]=='Q'){
                return false;
            }
        }
        return true;
    }
}
```

### 14、解数独

> [!NOTE]- [37. 解数独 - 力扣（LeetCode）](https://leetcode.cn/problems/sudoku-solver/description/)
```java
class Solution {
    public void solveSudoku(char[][] board) {
        backTrace(board);
    }
    private boolean backTrace(char[][] board){//再回溯的过程中不断填充棋盘
        //不需要递归结束条件，棋盘满了自动一层一层的返回true
        //遍历棋盘中每一个位置
        for(int i=0;i<9;i++){//遍历行
            for(int j=0;j<9;j++){//遍历列
                //在递归的过程中发现当前位置已经有数字了
                if(board[i][j]!='.'){
                    continue;
                }
                //将1-9分别尝试填充到当前位置
                for(char c='1';c<='9';c++){
                    //判断当前填充的数字是否合法
                    if(isVaild(i,j,board,c)){
                        board[i][j]=c;
                        boolean res=backTrace(board);
                        //如果返回的是一个true,说明后续的递归已经找到了一个解，逐层向上返回true即可
                        if(res){
                            return true;
                        }
                        board[i][j]='.';
                    }
                }
                //9个数都遍历完了，遍历到叶节点，没有返回true说明不满足条件
                return false;
            }
        }
        return true;
    } 
    private boolean isVaild(int row,int col,char[][] board,char c){
        //判断同一行是否存在相同数字
        for(int i=0;i<9;i++){
            if(board[row][i]==c){
                return false;
            }
        }
        //判断同一列是否存在相同数字
        for(int i=0;i<9;i++){
            if(board[i][col]==c){
                return false;
            }
        }
        //判断同一个九宫格是否存在相同字符
        //获取当前九宫格所在的位置
        int startRow=(row/3)*3;
        int startCol=(col/3)*3;
        for(int i=startRow;i<startRow+3;i++){
            for(int j=startCol;j<startCol+3;j++){
                if(board[i][j]==c){
                    return false;
                }
            }
        }
        return true;//历经千难万险终于返回true
    }
}
```

## 贪心
### 1、分发饼干

> [!NOTE]- [455. 分发饼干 - 力扣（LeetCode）](https://leetcode.cn/problems/assign-cookies/)
```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);//将胃口排序
        Arrays.sort(s);//将饼干排序
        //小饼干满足小胃口
        int count=0;//记录满足胃口的个数
        int start=0;
        for(int i=0;i<s.length&&start<g.length;i++){
           if(s[i]>=g[start]){
               count++;
               start++;
           }
        }
        return count;
    }
}
```
### 2、摆动序列

> [!NOTE] [376. 摆动序列 - 力扣（LeetCode）](https://leetcode.cn/problems/wiggle-subsequence/)
```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if(nums.length<=1){
            return 1;
        }
        int perdiff=0;//计算上一个发生摆动的坡的差值
        int curdiff=0;//计算当前坡的差值
        int count=1;//摆动序列至少有一个，第一个元素默认当做摆动序列
        for(int i=1;i<nums.length;i++){
            //计算当前坡的差值
            curdiff=nums[i]-nums[i-1];
            if((curdiff>0&&perdiff<=0)||(curdiff<0&&perdiff>=0)){
                count++;
                perdiff=curdiff;
            }
        }
        return count;
    }
}
```
### 3、最大子数组和

> [!NOTE] [力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台](https://leetcode.cn/problems/maximum-subarray/submissions/)
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int res=Integer.MIN_VALUE;//最大和
        int count=0;
        for(int i=0;i<nums.length;i++){
            count+=nums[i];//如果连续和小于0，那么接下来的连续和也一定递减
            if(count>res){
                res=count;
            }
            if(count<0){
                count=0;
                continue;
            }
        }
        return res;
    }
}
```
### 4、买股票的最佳时机

> [!NOTE] [122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)
```java
class Solution {
    public int maxProfit(int[] prices) {//贪心·，局部最优推出全局最优
        int res=0;
        for(int i=1;i<prices.length;i++){
            res+=Math.max(prices[i]-prices[i-1],0);
        }
        return res;
    }
}
```
### 5、跳跃游戏

> [!NOTE] [55. 跳跃游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game/)
```java
class Solution {
    public boolean canJump(int[] nums) {
        int maxJump=0;//最大跳跃范围
        for(int i=0;i<=maxJump;i++){
            maxJump=Math.max(maxJump,i+nums[i]);
            if(maxJump>=nums.length-1){
                return true;
            }
        }
        return false;
    }
}
```

### 6、跳跃游戏 II

> [!NOTE] [45. 跳跃游戏 II - 力扣（LeetCode）](https://leetcode.cn/problems/jump-game-ii/)
```java
class Solution {
    public int jump(int[] nums) {
        if(nums==null||nums.length==0||nums.length==1){
            return 0;
        }
        int count=0;//记录走的步数,其实就是记录更新为最大范围的次数
        int maxDistance=0;//下标移动过程中不断更新的最大范围
        int curDistance=0;//当前下标的可走的最大范围
        //如果下标遍历到当前最大范围，就更新当前最大范围，并且步数加一，不用关心是从哪个元素开始
        for(int i=0;i<nums.length;i++){
            maxDistance=Math.max(maxDistance,i+nums[i]);
            if(maxDistance>=nums.length-1){
                count++;
                break;
            }
            if(curDistance==i){//更新当前最大范围，其实就是步数加一
                count++;
                curDistance=maxDistance;
            }
        }
        return count;
    }
}
```
### 7、k 次取反后最大化的数组和

> [!NOTE] [1005. K 次取反后最大化的数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)
```java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        //按照元素绝对值大小从大到小排序
        //从前向后遍历，遇到负数且k大于0则将nums[i]取反
        //如果负数全部取反后，k还大于0，就将最小的正数进行取反
        nums=IntStream.of(nums)
        .boxed()
        .sorted((o1,o2)->Math.abs(o2)-Math.abs(o1))
        .mapToInt(Integer::intValue).toArray();
        int len=nums.length;
        for(int i=0;i<len;i++){
            if(nums[i]<0&&k>0){
                nums[i]=-nums[i];
                k--;
            }
        }
        //如果k大于0且为奇数的话，就将最小的正数取反，相当与对最小正数反复取反
        if(k%2==1){
            nums[len-1]=-nums[len-1];
        }
        //求和
        return Arrays.stream(nums).sum();
    }
}
```
### 8、加油站

> [!NOTE] [力扣（LeetCode）官网 - 全球极客挚爱的技术成长平台](https://leetcode.cn/problems/gas-station/)
```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        //1.如果gas总和小于cost总和，那一定跑不了一圈
        //2.如果cursum小于0，那i之前的都不会满足
        int cursum=0;
        int totalsum=0;
        int index=0;
        for(int i=0;i<gas.length;i++){
            totalsum+=gas[i]-cost[i];
            cursum+=gas[i]-cost[i];
            if(cursum<0){
                index=i+1;
                cursum=0;
            }
        }
        if(totalsum<0){
            return -1;
        }
        return index;
    }
}
```

### 9、分发糖果

> [!NOTE] [135. 分发糖果 - 力扣（LeetCode）](https://leetcode.cn/problems/candy/)
```java
class Solution {
    public int candy(int[] ratings) {
        //从下标1开始，从左往右，只要左边的值大于右边的值，左边的值等于右边的值加一
        //从下标len-2开始，从右往左，只要右边的值大于左边的值，右边的值等于左边的值加一
        int[] candyTemp=new int[ratings.length];
        Arrays.fill(candyTemp,1);
        //从左往右遍历
        for(int i=1;i<ratings.length;i++){
            if(ratings[i]>ratings[i-1]){
                candyTemp[i]=candyTemp[i-1]+1;
            }else{
                candyTemp[i]=1;
            }
        }
        //从右往左遍历
        for(int i=ratings.length-2;i>=0;i--){
            if(ratings[i]>ratings[i+1]){
                candyTemp[i]=Math.max(candyTemp[i],candyTemp[i+1]+1);
            }
        }
        int sum=0;//求和,你等我把stream流学完再来找你
        for(int i=0;i<candyTemp.length;i++){
            sum+=candyTemp[i];
        }
        return sum;
    }
}
```

### 10、柠檬水找零

> [!NOTE] [860. 柠檬水找零 - 力扣（LeetCode）](https://leetcode.cn/problems/lemonade-change/)
```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int five=0;//记录5元的个数
        int ten=0;//记录10元的个数
        //用户支付5元，直接存入不用找零
        //用户支付10元，5元个数减一,10元个数加一
        //用户支付20元，先将10元和5元各减一，如果没有10元，则减去三个5元
        for(int i=0;i<bills.length;i++){
            if(bills[i]==5){
                five++;
            }else if(bills[i]==10){
                five--;
                ten++;
            }else{
                if(ten>0){
                    ten--;
                    five--;
                }else{
                    five-=3;
                }
            }
            if(five<0){
                return false;
            }
        }
        return true;
    }
}
```
### 11、根据身高重建队列

> [!NOTE] [406. 根据身高重建队列 - 力扣（LeetCode）](https://leetcode.cn/problems/queue-reconstruction-by-height/)
```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        //身高从大到小排序（身高相同的，k小的排前面）
        Arrays.sort(people,(a,b)->{
            if(a[0]==b[0]){
                return a[1]-b[1];
            }
            return b[0]-a[0];
        });
        //使用贪心的方式将元素插到对应k值的下标
        //为什么这样就可以呢，因为插入到指定位置一定是保证前面的元素是大于等于当前元素的
        LinkedList<int[]> list=new LinkedList<>();
        for(int[] p:people){
            list.add(p[1],p);//将数组插入到指定位置，使用链表更方便插入操作
        }
        //最后将链表转为二维数组
        return list.toArray(new int[people.length][]);
    }
}
```
### 12、用最少数量的箭引爆气球

> [!NOTE] [452. 用最少数量的箭引爆气球 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/)
```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        //根据气球左边界数值进行排序
        Arrays.sort(points,(a,b)->Integer.compare(a[0],b[0]));//不能a[0]-b[0],结果可能超出int范围变成负数
        int count=1;//至少移至箭
        for(int i=1;i<points.length;i++){
            if(points[i][0]>points[i-1][1]){//当前左边界大于前一个气球的右边界
                //没有重叠，箭数加一
                count++;
            }else{//当前左边界小于等于上一个右边界，可以重叠穿射
                //难点，下一个气球也可能重叠
                //记录最小右边界
                points[i][1]=Math.min(points[i][1],points[i-1][1]);
            }
        }
        return count;
    }
}
```
### 13、无重叠区间

> [!NOTE] [435. 无重叠区间 - 力扣（LeetCode）](https://leetcode.cn/problems/non-overlapping-intervals/)
```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        Arrays.sort(intervals,(a,b)->{
            return Integer.compare(a[0],b[0]);
        });
        int count=0;//重叠区间
        for(int i=1;i<intervals.length;i++){
            if(intervals[i][0]<intervals[i-1][1]){
                intervals[i][1]=Math.min(intervals[i][1],intervals[i-1][1]);
                count++;
            }
        }
        return count;
    }
}
```
### 14、划分字母区间

> [!NOTE] [763. 划分字母区间 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-labels/)
```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        List<Integer> list=new ArrayList<>();
        int[] edge=new int[26];
        for(int i=0;i<s.length();i++){
            edge[s.charAt(i)-'a']=i;
        }//求出每个字母最远下标
        int left=0;
        int right=-1;
        for(int i=0;i<s.length();i++){
            //更新右区间
            right=Math.max(right,edge[s.charAt(i)-'a']);
            if(i==right){
                list.add(right-left+1);
                left=i+1;
                continue;
            }
        }
        return list;
    }
}
```
### 15、合并区间

> [!NOTE] [56. 合并区间 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-intervals/)
```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,(a,b)->{
            return Integer.compare(a[0],b[0]);
        });
        List<int[]> list=new ArrayList<>();
        int start=intervals[0][0];
        int right=intervals[0][1];
        for(int i=1;i<intervals.length;i++){
            if(intervals[i][0]>right){
                //未重叠，将之前的区间纳入集合
                list.add(new int[]{start,right});
                start=intervals[i][0];
                right=intervals[i][1];
            }else{
                right=Math.max(right,intervals[i][1]);
            }
        }
        list.add(new int[]{start,right});//纳入最后一个区间
        return list.toArray(new int[list.size()][]);
    }
}
```
### 16、单调递增的数字

> [!NOTE] [738. 单调递增的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/monotone-increasing-digits/)
```java
class Solution {
    public int monotoneIncreasingDigits(int n) {
        String str=String.valueOf(n);//将整数转为字符串
        char[] chars=str.toCharArray();//将字符串转为字符数组，方便遍历
        //从后向前遍历
        int start=chars.length;//记录后面需要转为9的初始下标
        for(int i=chars.length-2;i>=0;i--){
            if(chars[i]>chars[i+1]){
                chars[i]--;
                start=i+1;
            }
        }
        for(int i=start;i<chars.length;i++){
            chars[i]='9';
        }
        return Integer.parseInt(String.valueOf(chars));
    }
}
```
### 17、监控二叉树

> [!NOTE] [968. 监控二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-cameras/)
```java
class Solution {
    int res=0;//摄像头个数
    public int minCameraCover(TreeNode root) {
        //最阴险的一步，根节点最后可能是无覆盖状态
        if(minCame(root)==0){
            res++;
        }
        return res;
    }
    //三种状态
    //0-无覆盖状态
    //1-有摄像头
    //2-覆盖状态
    private int minCame(TreeNode root){
        //遍历到空节点，设置为覆盖状态
        if(root==null){
            return 2;
        }
        //后序遍历
        int left=minCame(root.left);//返回左节点的状态
        int right=minCame(root.right);//返回右节点的状态
        //如果左右节点都是覆盖状态，那么给当前节点的父节点安装摄像头,当前节点为无覆盖状态
        if(left==2&&right==2){
            return 0;
        }else if(left==0||right==0){//左右节点至少有一个无覆盖，父节点必须安装摄像头
            res++;
            return 1;
        }else{//左右节点有摄像头和被覆盖，那么该节点一定也被覆盖
            return 2;
        }
    }
}
```
## 动态规划
### 1、斐波那契数列

> [!NOTE] [509. 斐波那契数 - 力扣（LeetCode）](https://leetcode.cn/problems/fibonacci-number/)
```java
class Solution {
    public int fib(int n) {
        if(n<=1){
            return n;
        }
        //1.确定dp数组及其下标含义
        int[] dp=new int[n+1];//dp[i]表示第i个斐波那契数列值
        //2. 确定递推公式
        //dp[i]=dp[i-1]+dp[i-2]
        //3. dp数组初始化
        dp[0]=0;
        dp[1]=1;
        //4.确定遍历顺序，从前往后
        //5.举例推到递推公式，0,1,1,2,3,5,8,13
        for(int i=2;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
}
```
### 2、爬楼梯
```java
class Solution {
    public int climbStairs(int n) {
        if(n<=1){
            return n;
        }
        //1.确定dp数组及其下标含义
        int[] dp=new int[n+1];//dp[i]表示达到第i个台阶的方法个数
        //2.递推公式：dp[i]=dp[i-1]+dp[i-2]
        //3.dp数组初始化
        dp[0]=1;
        dp[1]=1;
        //4.确定遍历顺序：从前往后
        //5.举例推导公式：1,2,3,5,8,13
        for(int i=2;i<=n;i++){
            dp[i]=dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
}
```
### 3、使用最小花费爬楼梯

> [!NOTE] [746. 使用最小花费爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/min-cost-climbing-stairs/)
```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        //1.确定dp数组及其下标含义
        int[] dp=new int[cost.length+1];//dp[i]表示到达第i个台阶所花费的最少体力
        //2.确定递推公式：dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
        //3.dp数组初始化
        dp[0]=0;
        dp[1]=0;
        for(int i=2;i<=cost.length;i++){
            dp[i]=Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
        }
        return dp[cost.length];
    }
}
```
### 4、不同路径

> [!NOTE] [62. 不同路径 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths/)
```java
class Solution {
    public int uniquePaths(int m, int n) {
        //1.确定dp数组及其下标含义
        int[][] dp=new int[m][n];
        //2.确定递推公式:dp[i][j]=d[i][j-1]+dp[i-1][j]
        //3.dp数组初始化
        for(int i=0;i<m;i++){
            dp[i][0]=1;
        }
        for(int i=0;i<n;i++){
            dp[0][i]=1;
        }
        //4.遍历顺序：从左往右一层一层遍历
        //5.推到举例：
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j]=dp[i][j-1]+dp[i-1][j];
            }
        }
        return dp[m-1][n-1];
    }
}
```
### 5、不同路径 II

> [!NOTE] [63. 不同路径 II - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-ii/)
```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        //1.确定dp数组及其下标含义
        int m=obstacleGrid.length;
        int n=obstacleGrid[0].length;
        int[][] dp=new int[m][n];//dp[i][j]表示到达当前位置的路径总数
        //2.确定递推公式:没有障碍物的情况：dp[i][j]=dp[i][j-1]+dp[i-1][j]
        //3.dp数组初始化
        for(int i=0;i<m;i++){
            if(obstacleGrid[i][0]==1){
                break;
            }
            dp[i][0]=1;
        }
        for(int i=0;i<n;i++){
            if(obstacleGrid[0][i]==1){
                break;
            }
            dp[0][i]=1;
        }
        //4.从左往右一层一层遍历
        //5.举例推导
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                if(obstacleGrid[i][j]==0){
                    dp[i][j]=dp[i][j-1]+dp[i-1][j];
                }else{
                    dp[i][j]=0;
                }
            }
        }
        return dp[m-1][n-1];
    }
}
```
### 6、整数拆分

> [!NOTE] [343. 整数拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/integer-break/description/)
```java
class Solution {
    public int integerBreak(int n) {
        //1.确定dp数组及其下标含义
        int[] dp=new int[n+1];//dp[i]表示第i个数的最大乘积
        //2.确定递推公式:dp[i]=max(j*(i-j),j*dp[i-j],dp[i])
        //3.dp数组初始化
        dp[2]=1;
        //4.遍历顺序：从前向后
        //5.推导举例：1，2,4,
        for(int i=3;i<=n;i++){
            for(int j=1;j<i;j++){
                dp[i]=Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));
            }
        }
        return dp[n];
    }
}
```
### 7、不同的二叉搜索树

> [!NOTE] [96. 不同的二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-binary-search-trees/)
```java
class Solution {
    public int numTrees(int n) {
        //确定dp数组及其下标含义
        int[] dp=new int[n+1];//dp[i]表示由i个节点组成的二叉搜索树的个数
        //确定递推公式:dp[i]+=dp[j-1]*dp[i-j]
        //初始化dp数组
        dp[0]=1;
        dp[1]=1;
        //遍历顺序：从前往后遍历
        for(int i=2;i<=n;i++){
            for(int j=1;j<=i;j++){
                dp[i]+=dp[j-1]*dp[i-j];//左子树和右子树形成的二叉搜索树个数相乘就是以当前j为头结点所形成的结构总数，累加1-i为头结点的结构总数
            }
        }
        return dp[n];
    }
}
```
### 8、分割等和子集

> [!NOTE] [416. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/partition-equal-subset-sum/)
```java
class Solution {
    public boolean canPartition(int[] nums) {
        //思路：01背包问题，将数组求和除以2，看是否存在子集和等于target,target相当于背包容量，nums[i]相当于重量和价值
        int sum=Arrays.stream(nums).sum();
        if(sum%2==1){
            return false;
        }
        int target=sum/2;
        int[] dp=new int[target+1];
        for(int i=0;i<nums.length;i++){
            for(int j=target;j>=nums[i];j--){
                dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i]);
            }
            if(dp[target]==target){
                return true;
            }
        }
        return dp[target]==target;
    }
}
```
### 9、最后一块石头的重量

> [!NOTE] [1049. 最后一块石头的重量 II - 力扣（LeetCode）](https://leetcode.cn/problems/last-stone-weight-ii/)
```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        //要想最后剩余的石头重量最小，那就必须找出两份重量差不多的子集，重量和除以二，找出重量最接近target的子集和
        int sum=Arrays.stream(stones).sum();
        int target=sum/2;
        int[] dp=new int[target+1];
        dp[0]=0;
        for(int i=0;i<stones.length;i++){
            for(int j=target;j>=stones[i];j--){
                dp[j]=Math.max(dp[j],dp[j-stones[i]]+stones[i]);
            }
        }
        return sum-dp[target]-dp[target];
    }
}
```
### 10、目标和
> [!NOTE] [494. 目标和 - 力扣（LeetCode）](https://leetcode.cn/problems/target-sum/)
```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum=Arrays.stream(nums).sum();
        if(target>sum||(target<0&&-target>sum)){
            return 0;
        }
        if((target+sum)%2!=0){
            return 0;
        }
        int size=(target+sum)/2;
        if(size<0){
            size=-size;
        }
        int[] dp=new int[size+1];
        dp[0]=1;
        for(int i=0;i<nums.length;i++){
            for(int j=size;j>=nums[i];j--){
                dp[j]+=dp[j-nums[i]];
            }
        }
        return dp[size];
    }
}
```
### 11、1 和 0

> [!NOTE] [474. 一和零 - 力扣（LeetCode）](https://leetcode.cn/problems/ones-and-zeroes/description/)
```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp=new int[m+1][n+1];//dp[i][j]表示容量为i个0，j个1的物品个数
        int zero,one;
        for(String s:strs){
            zero=0;
            one=0;
            for(char c:s.toCharArray()){
                if(c=='0'){
                    zero++;
                }else{
                    one++;
                }
            }
            for(int i=m;i>=zero;i--){
                for(int j=n;j>=one;j--){
                    dp[i][j]=Math.max(dp[i][j],dp[i-zero][j-one]+1);
                }
            }
        }
        return dp[m][n];
    }
}
```
### 12、零钱兑换 II

> [!NOTE] [518. 零钱兑换 II - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change-ii/)
```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp=new int[amount+1];//dp[i]表示金额为i的组合数
        dp[0]=1;
        for(int i=0;i<coins.length;i++){
            for(int j=coins[i];j<=amount;j++){
                dp[j]+=dp[j-coins[i]];
            }
        }
        return dp[amount];
    }
}
```

### 13、组合总和

> [!NOTE] [377. 组合总和 Ⅳ - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iv/)
```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp=new int[target+1];//dp[i]表示目标和为i的排列个数
        //递推公式：dp[j]+=dp[j-nums[i]]
        //求组合物品在外，求排列背包在外
        dp[0]=1;
        for(int i=0;i<=target;i++){
            for(int j=0;j<nums.length;j++){
                if(i>=nums[j]){
                    dp[i]+=dp[i-nums[j]];
                }
            }
        }
        return dp[target];
    }
}
```
### 14、零钱兑换

> [!NOTE] [322. 零钱兑换 - 力扣（LeetCode）](https://leetcode.cn/problems/coin-change/)
```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp=new int[amount+1];//dp[i]表示第总金为i的组成硬币最少数
        dp[0]=0;
        for(int i=1;i<dp.length;i++){
            dp[i]=Integer.MAX_VALUE;
        }
        for(int i=0;i<coins.length;i++){
            for(int j=coins[i];j<=amount;j++){
                if(dp[j-coins[i]]!=Integer.MAX_VALUE){
                     dp[j]=Math.min(dp[j-coins[i]]+1,dp[j]);
                }
            }
        }
        return dp[amount]==Integer.MAX_VALUE ? -1:dp[amount];
    }
}
```
### 15、完全平方数

> [!NOTE] [279. 完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/perfect-squares/description/)
```java
class Solution {
    public int numSquares(int n) {
        int[] dp=new int[n+1];
        //递推公式：dp[j]=min(dp[j-i*i]+1,dp[j])
        for(int i=1;i<=n;i++){
            dp[i]=Integer.MAX_VALUE;
        }
        for(int i=1;i*i<=n;i++){
            for(int j=i*i;j<=n;j++){
                dp[j]=Math.min(dp[j-i*i]+1,dp[j]);
            }
        }
        return dp[n];
    }
}
```
### 16、单词拆分

> [!NOTE] [139. 单词拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/word-break/description/)
```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set=new HashSet<>(wordDict);//将列表转为集合
        boolean[] dp=new boolean[s.length()+1];//dp[i]表示下标为i之前的字符串是否可以在字典中找到
        dp[0]=true;//没有实际意义，只是为了防止后面的递推都为false
        //字符串作为背包，字典元素作为物品
        //组合物品在外，背包在内
        //排列背包在外，物品在内
        for(int i=1;i<=s.length();i++){
            for(int j=0;j<i;j++){
                if(set.contains(s.substring(j,i))&&dp[j]){
                    dp[i]=true;
                }
            }
        }
        return dp[s.length()];
    }
}
```
### 17、打家劫舍

> [!NOTE] [198. 打家劫舍 - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber/)
```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length==0){
            return 0;
        }
        if(nums.length==1){
            return nums[0];
        }
        //确定dp数组及其含义
        int[] dp=new int[nums.length];//dp[i]表示第i个房间所能偷的最大金额
        //确定递推公式：dp[i]=max(dp[i-2]+nums[i],dp[i-1])
        //初始化
        dp[0]=nums[0];
        dp[1]=Math.max(nums[0],nums[1]);
        for(int i=2;i<nums.length;i++){
            dp[i]=Math.max(dp[i-2]+nums[i],dp[i-1]);
        }
        return dp[nums.length-1];
    }
}
```
### 18、打家劫舍 II

> [!NOTE] [213. 打家劫舍 II - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-ii/)
```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length==0){
            return 0;
        }
        if(nums.length==1){
            return nums[0];
        }
        if(nums.length==2){
            return Math.max(nums[0],nums[1]);
        }
        return Math.max(robMax(nums,0,nums.length-1),robMax(nums,1,nums.length));
    }
    private int robMax(int[] nums,int start,int end){
        int len=end-start;
        int[] dp=new int[len];
        dp[0]=nums[start];
        dp[1]=Math.max(nums[start],nums[start+1]);
        for(int i=2;i<len;i++){
            if(start==0){
                dp[i]=Math.max(dp[i-2]+nums[i],dp[i-1]);
            }else if (start==1){
                dp[i]=Math.max(dp[i-2]+nums[i+1],dp[i-1]);
            }
        }
        return dp[len-1];
    }
}
```
### 19、打家劫舍 III

> [!NOTE] [337. 打家劫舍 III - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber-iii/)
```java
class Solution {
    public int rob(TreeNode root) {
        int[] res=robAction(root);
        return Math.max(res[0],res[1]);
    }
    private int[] robAction(TreeNode root){
        //后序遍历，每个节点有偷与不偷两种状态
        int[] dp=new int[2];
        if(root==null){
            return dp;
        }
        int[] left=robAction(root.left);
        int[] right=robAction(root.right);
        dp[0]=root.val+left[1]+right[1];//偷=当前节点值+子节点不偷的值
        dp[1]=Math.max(left[0],left[1])+Math.max(right[0],right[1]);//不偷=左右子节点的最大值
        return dp;
    }
}
```
### 20、买卖股票最佳时机

> [!NOTE] [121. 买卖股票的最佳时机 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)
```java
class Solution {
    public int maxProfit(int[] prices) {
        //确定dp数组。dp[i][0]表示第i天持有股票的金额，dp[i][1]表示第i天未持有股票的金额
        int[][] dp=new int[prices.length][2];
        //递推公式：dp[i][0]=max(dp[i-1][0],-price[i]),dp[i][1]=max(dp[i-1][1],dp[i-1][0]+price[i])
        //初始化
        dp[0][0]=-prices[0];
        dp[0][1]=0;
        for(int i=1;i<prices.length;i++){
            dp[i][0]=Math.max(dp[i-1][0],-prices[i]);
            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return dp[prices.length-1][1];
    }
}
```
### 21、买卖股票最佳时机 II

> [!NOTE] [122. 买卖股票的最佳时机 II - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)
```java
class Solution {
    public int maxProfit(int[] prices) {
        //确定dp数组,dp[i][0]表示第i天持有股票的金额，dp[i][1]表示第i天未持有股票的金额
        int[][] dp=new int[prices.length][2];
        //递推公式：dp[i][0]=max(dp[i-1][0],dp[i-1][1]-price[i]),dp[i][1]=max(dp[i-1][1],dp[i-1][0]+price[i])
        dp[0][0]=-prices[0];
        dp[0][1]=0;
        for(int i=1;i<prices.length;i++){
            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);
            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return dp[prices.length-1][1];
    }
}
```

### 22、买卖股票最佳时机 III

> [!NOTE] [123. 买卖股票的最佳时机 III - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)
```java
class Solution {
    public int maxProfit(int[] prices) {
        //确定dp数组
        int[][] dp=new int[prices.length][5];
        dp[0][1]=-prices[0];
        dp[0][3]=-prices[0];
        for(int i=1;i<prices.length;i++){
            dp[i][1]=Math.max(dp[i-1][1],-prices[i]);
            dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]+prices[i]);
            dp[i][3]=Math.max(dp[i-1][3],dp[i-1][2]-prices[i]);
            dp[i][4]=Math.max(dp[i-1][4],dp[i-1][3]+prices[i]);
        }
        return dp[prices.length-1][4];
    }
}
```
### 23、买卖股票最佳时机 IV

> [!NOTE] [188. 买卖股票的最佳时机 IV - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)
```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        //确定dp数组：dp[i][2k]，为什么是2k，因为每一笔交易有两个状态，持有和未持有
        int[][] dp=new int[prices.length][2*k+1];
        //确定递推公式：dp[i][j+1]=max(dp[i-1][j+1],dp[i-1][j]-price[i])
        //dp[i][j+2]=max(dp[i-1][j+2],dp[i-1][j+1]+prices[i])
        //dp[j+1]表示持有股票状态，dp[j+2]表示未持有股票状态
        for(int i=1;i<2*k;i+=2){//奇数都是持有股票状态
            dp[0][i]=-prices[0];
        }
        for(int i=1;i<prices.length;i++){
            for(int j=0;j<2*k;j+=2){
                dp[i][j+1]=Math.max(dp[i-1][j+1],dp[i-1][j]-prices[i]);
                dp[i][j+2]=Math.max(dp[i-1][j+2],dp[i-1][j+1]+prices[i]);
            }
        }
        return dp[prices.length-1][2*k];
    }
}
```
### 24、买卖股票最佳时机含冷冻期

> [!NOTE] [309. 买卖股票的最佳时机含冷冻期 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
```java
class Solution {
    public int maxProfit(int[] prices) {
        //确定dp数组
        int[][] dp=new int[prices.length][4];
        //确定递推公式：dp[i][0]=max(dp[i-1][0],dp[i-1][1]-prices[i],dp[i-1][3]-prices[i])
        //dp[i][1]=max(dp[i-1][1],dp[i-1][3])
        //dp[i][2]=dp[i-1][0]+prices[i]
        //dp[i][3]=dp[i-1][2]
        dp[0][0]=-prices[0];
        for(int i=1;i<prices.length;i++){
            dp[i][0]=Math.max(dp[i-1][0],Math.max(dp[i-1][1]-prices[i],dp[i-1][3]-prices[i]));
            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][3]);
            dp[i][2]=dp[i-1][0]+prices[i];
            dp[i][3]=dp[i-1][2];
        }
        return Math.max(dp[prices.length-1][3],Math.max(dp[prices.length-1][1],dp[prices.length-1][2]));
    }
}
```

### 25、买卖股票最佳时机含手续费

> [!NOTE] [714. 买卖股票的最佳时机含手续费 - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int[][] dp=new int[prices.length][2];//dp[i][0]表示第i天持有股票的最大利润，dp[i][1]表示第i天未持有股票的最大利润
        dp[0][0]=-prices[0];
        dp[0][1]=0;
        for(int i=1;i<prices.length;i++){
            dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);
            dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]+prices[i]-fee);
        }
        return dp[prices.length-1][1];
    }
}
```
### 26、最长递增子序列

> [!NOTE] [300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/)
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        //确定dp数组，dp[i]表示nums[i]之前的最长递增子序列长度
        int[] dp=new int[nums.length];
        //确定递推公式:dp[i]=max(dp[j]+1,dp[i])
        //初始化
        Arrays.fill(dp,1);
        int res=1;
        for(int i=1;i<nums.length;i++){
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i]){
                    dp[i]=Math.max(dp[j]+1,dp[i]);
                }
                res=Math.max(dp[i],res);//注意：dp[i]表示的是以nums[i]结尾的最长子序列长度，并不是整个nums数组的最长子序列长度
            }
        }
        return res;
    }
}
```
### 27、最长连续递增序列

> [!NOTE] [674. 最长连续递增序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)
```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        //确定dp数组，dp[i]表示以nums[i]结尾的最长连续子序列长度
        int[] dp=new int[nums.length];
        //确定递推公式：if(nums[i]>nums[i-1]){dp[i]=dp[i-1]+1}
        //初始化
        Arrays.fill(dp,1);
        int res=1;
        for(int i=1;i<nums.length;i++){
            if(nums[i]>nums[i-1]){
                dp[i]=dp[i-1]+1;
            }
            res=Math.max(res,dp[i]);
        }
        return res;
    }
}
```

### 28、最长重复子数组

> [!NOTE] [718. 最长重复子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)
```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        //定义dp数组，dp[i][j]表示以i-1结尾和以j-1结尾的最长子数组长度
        int[][] dp=new int[nums1.length+1][nums2.length+1];
        //初始化，dp[i][0]=0,dp[0][j]=0
        //递推公式：dp[i][j]=dp[i-1][j-1]+1
        int res=0;
        for(int i=1;i<=nums1.length;i++){
            for(int j=1;j<=nums2.length;j++){
                if(nums1[i-1]==nums2[j-1]){
                    dp[i][j]=dp[i-1][j-1]+1;
                    res=Math.max(res,dp[i][j]);
                }
            }
        }
        return res;
    }
}
```
### 29、最长公共子序列

> [!NOTE] [1143. 最长公共子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-subsequence/)
```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int[][] dp=new int[text1.length()+1][text2.length()+1];
        for(int i=1;i<=text1.length();i++){
            char s=text1.charAt(i-1);
            for(int j=1;j<=text2.length();j++){
                char c=text2.charAt(j-1);
                if(s==c){
                    dp[i][j]=dp[i-1][j-1]+1;
                }else{
                    dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j]);
                }
            }
        }
        return dp[text1.length()][text2.length()];
    }
}
```
### 30、不相交的线

> [!NOTE] [1035. 不相交的线 - 力扣（LeetCode）](https://leetcode.cn/problems/uncrossed-lines/)
```java
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int[][] dp=new int[nums1.length+1][nums2.length+1];
        for(int i=1;i<=nums1.length;i++){
            for(int j=1;j<=nums2.length;j++){
                if(nums1[i-1]==nums2[j-1]){
                    dp[i][j]=dp[i-1][j-1]+1;
                }else{
                    dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j]);
                }
            }
        }
        return dp[nums1.length][nums2.length];
    }
}
```

### 31、最大子数组和

> [!NOTE] [53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp=new int[nums.length];
        dp[0]=nums[0];
        int res=nums[0];
        for(int i=1;i<nums.length;i++){
            dp[i]=Math.max(dp[i-1]+nums[i],nums[i]);
            res=Math.max(res,dp[i]);
        }
        return res;
    }
}
```
### 32、判断子序列

> [!NOTE] [392. 判断子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/is-subsequence/)
```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        //确定dp数组，dp[i][j]表示以下标i-1结尾的s和以下标j-1结尾的t所拥有的最长子序列长度
        int[][] dp=new int[s.length()+1][t.length()+1];
        //确定递推公式：if(s[i-1]==t[j-1]){dp[i][j]=dp[i-1][j-1]+1};if(s[i-1]!=t[j-1]){dp[i][j]=dp[i][j-1]}
        //初始化，因为dp[i][j]是由dp[i-1][j-1]和dp[i][j-1]得到,所以dp[0][0]和dp[i][0]初始化为0
        for(int i=1;i<=s.length();i++){
            char c1=s.charAt(i-1);
            for(int j=1;j<=t.length();j++){
                char c2=t.charAt(j-1);
                if(c1==c2){
                    dp[i][j]=dp[i-1][j-1]+1;
                }else{
                    dp[i][j]=dp[i][j-1];
                }
            }
        }
        return dp[s.length()][t.length()]==s.length();
    }
}
```
### 33、不同的子序列

> [!NOTE] [115. 不同的子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/distinct-subsequences/)
```java
class Solution {
    public int numDistinct(String s, String t) {
        int[][] dp=new int[s.length()+1][t.length()+1];
        for(int i=0;i<=s.length();i++){
            dp[i][0]=1;
        }
        for(int i=1;i<=s.length();i++){
            char c1=s.charAt(i-1);
            for(int j=1;j<=t.length();j++){
                char c2=t.charAt(j-1);
                if(c1==c2){
                    dp[i][j]=dp[i-1][j-1]+dp[i-1][j];
                }else{
                    dp[i][j]=dp[i-1][j];
                }
            }
        }
        return dp[s.length()][t.length()];
    }
}
```
### 34、两个字符串的删除操作

> [!NOTE] [583. 两个字符串的删除操作 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-operation-for-two-strings/)
```java
class Solution {
    public int minDistance(String word1, String word2) {
        int[][] dp=new int[word1.length()+1][word2.length()+1];
        for(int i=0;i<=word1.length();i++){
            dp[i][0]=i;
        }
        for(int j=0;j<=word2.length();j++){
            dp[0][j]=j;
        }
        for(int i=1;i<=word1.length();i++){
            char c1=word1.charAt(i-1);
            for(int j=1;j<=word2.length();j++){
                char c2=word2.charAt(j-1);
                if(c1==c2){
                    dp[i][j]=dp[i-1][j-1];
                }else{
                    dp[i][j]=Math.min(dp[i-1][j]+1,Math.min(dp[i][j-1]+1,dp[i-1][j-1]+2));
                }
            }
        }
        return dp[word1.length()][word2.length()];
    }
}
```
### 35、编辑距离

> [!NOTE] [72. 编辑距离 - 力扣（LeetCode）](https://leetcode.cn/problems/edit-distance/)
```java
class Solution {
    public int minDistance(String word1, String word2) {
        int[][] dp=new int[word1.length()+1][word2.length()+1];
        for(int i=0;i<=word1.length();i++){
            dp[i][0]=i;
        }
        for(int j=0;j<=word2.length();j++){
            dp[0][j]=j;
        }
        for(int i=1;i<=word1.length();i++){
            char c1=word1.charAt(i-1);
            for(int j=1;j<=word2.length();j++){
                char c2=word2.charAt(j-1);
                if(c1==c2){
                    dp[i][j]=dp[i-1][j-1];
                }else{
                    dp[i][j]=Math.min(dp[i-1][j]+1,Math.min(dp[i][j-1]+1,dp[i-1][j-1]+1));
                }
            }
        }
        return dp[word1.length()][word2.length()];
    }
}
```
### 36、回文子串

> [!NOTE] [647. 回文子串 - 力扣（LeetCode）](https://leetcode.cn/problems/palindromic-substrings/)
```java
class Solution {
    public int countSubstrings(String s) {
        boolean[][] dp=new boolean[s.length()][s.length()];
        int res=0;
        for(int i=s.length()-1;i>=0;i--){
            for(int j=i;j<s.length();j++){
                if(s.charAt(i)==s.charAt(j)){
                    if(j-i<=1){
                        res++;
                        dp[i][j]=true;      
                    }else if(dp[i+1][j-1]){
                        res++;
                        dp[i][j]=true;
                    }
                }
            }
        }
        return res;
    }
}
```
### 37、最长回文子序列

> [!NOTE] [516. 最长回文子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-subsequence/)
```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        //确定dp数组，dp[i][j]表示在下标i到j之间的最长回文子序列
        int[][] dp=new int[s.length()][s.length()];
        //确定递推公式：如果s[i]=s[j],那么dp[i][j]=dp[i+1][j-1]+2;
        //如果s[i]!=s[j],dp[i][j]=max(dp[i+1][j],dp[i][j-1])
        //初始化dp数组，只有当i和j相同时，一个字符也代表回文子序列
        for(int i=0;i<s.length();i++){
            dp[i][i]=1;
        }
        for(int i=s.length()-1;i>=0;i--){
            char c1=s.charAt(i);
            for(int j=i+1;j<s.length();j++){
                char c2=s.charAt(j);
                if(c1==c2){
                    dp[i][j]=dp[i+1][j-1]+2;
                }else{
                    dp[i][j]=Math.max(dp[i+1][j],dp[i][j-1]);
                }
            }
        }
        return dp[0][s.length()-1];
    }
}
```
## 单调栈
### 1、每日温度

> [!NOTE] [739. 每日温度 - 力扣（LeetCode）](https://leetcode.cn/problems/daily-temperatures/)
```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        //设置单调栈
        Deque<Integer> stack=new LinkedList<>();
        //设置结果数组
        int[] res=new int[temperatures.length];
        //初始化单调栈
        stack.push(0);//存入下标0
        for(int i=1;i<temperatures.length;i++){
            if(temperatures[i]<=temperatures[stack.peek()]){
                stack.push(i);
            }else{
                while(!stack.isEmpty()&&temperatures[stack.peek()]<temperatures[i]){
                    res[stack.peek()]=i-stack.peek();
                    stack.pop();
                }
                stack.push(i);
            }
        }
        return res;
    }
}
```
### 2、下一个更大元素 I

> [!NOTE] [496. 下一个更大元素 I - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-i/)
```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        HashMap<Integer,Integer> map=new HashMap<>();//存放nums1元素与nums2相同元素下标的映射关系
        //声明单调栈
        Deque<Integer> stack=new LinkedList<>();
        stack.push(0);
        //声明结果数组
        int[] res=new int[nums1.length];
        Arrays.fill(res,-1);
        //初始化映射关系
        for(int i=0;i<nums1.length;i++){
            map.put(nums1[i],i);
        }
        for(int i=1;i<nums2.length;i++){
            if(nums2[i]<=nums2[stack.peek()]){
                stack.push(i);
            }else{
                while(!stack.isEmpty()&&nums2[i]>nums2[stack.peek()]){
                    if(map.containsKey(nums2[stack.peek()])){
                        Integer index=map.get(nums2[stack.peek()]);
                        res[index]=nums2[i];
                    }
                    stack.pop();
                }
                stack.push(i);
            }
        }
        return res;
    }
}
```
### 3、下一个更大元素 II

> [!NOTE] [503. 下一个更大元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-element-ii/)
```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        Deque<Integer> stack=new LinkedList<>();
        stack.push(0);
        int[] res=new int[nums.length];
        Arrays.fill(res,-1);
        for(int i=1;i<nums.length*2;i++){
            if(nums[i%nums.length]<=nums[stack.peek()]){
                stack.push(i%nums.length);
            }else{
                while(!stack.isEmpty()&&nums[i%nums.length]>nums[stack.peek()]){
                    int index=stack.peek();
                    res[index]=nums[i%nums.length];
                    stack.pop();
                }
                stack.push(i%nums.length);
            }
        }
        return res;
    }
}
```
### 4、接雨水

> [!NOTE] [42. 接雨水 - 力扣（LeetCode）](https://leetcode.cn/problems/trapping-rain-water/)
```java
class Solution {
    public int trap(int[] height) {
        if(height.length<=2){//长度小于等于2就无法存储雨水
            return 0;
        }
        //定义单调栈
        Deque<Integer> stack=new LinkedList<>();
        stack.push(0);
        int res=0;
        for(int i=1;i<height.length;i++){
            if(height[i]<=height[stack.peek()]){
                stack.push(i);
            }else{
                while(!stack.isEmpty()&&height[i]>height[stack.peek()]){
                    //获取中间元素
                    int mid=stack.pop();
                    if(!stack.isEmpty()){
                        //获取左边元素
                        int left=stack.peek();
                        //获取高度
                        int h=Math.min(height[left],height[i])-height[mid];
                        //获取宽度
                        int w=i-left-1;
                        res+=h*w;
                    }
                }
                stack.push(i);
            }
        }
        return res;
    }
}
```
### 5、柱状图中最大矩形

> [!NOTE] [84. 柱状图中最大的矩形 - 力扣（LeetCode）](https://leetcode.cn/problems/largest-rectangle-in-histogram/)
```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Deque<Integer> stack=new LinkedList<>();
        int[] newHeights=new int[heights.length+2];
        for(int i=0;i<heights.length;i++){
            newHeights[i+1]=heights[i];
        }
        int res=0;
        stack.push(0);
        for(int i=1;i<newHeights.length;i++){
            if(newHeights[i]>=newHeights[stack.peek()]){
                stack.push(i);
            }else{
                while(!stack.isEmpty()&&newHeights[i]<newHeights[stack.peek()]){
                    int mid=stack.pop();
                    int left=stack.peek();
                    int right=i;
                    int h=newHeights[mid];
                    int w=right-left-1;
                    res=Math.max(res,w*h);
                }
                stack.push(i);
            }
        }
        return res;
    }
}
```


































