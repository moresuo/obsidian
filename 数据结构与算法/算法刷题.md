***
## 数组
### 1、二分查找

> [!NOTE]- [704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/)
>```java
class Solution {
    public int search(int[] nums, int target) {
        if(target<nums[0]||target>nums[nums.length-1]){//因为是有序数组，当目标值不在数组范围内就直接返回
            return -1;
        }
        int left=0;//左指针
        int right=nums.length-1;//右指针
        while(left<=right){//左闭右闭模式
            int mid=(left+right) >> 1;//右移一位相当于除以二，这种速度更快
            if(target<nums[mid]){//目标值在左边，缩小右边上限
                right=mid-1;
            }else if(target>nums[mid]){//目标值在右边，提升左边下限
                left=mid+1;
            }else{//找到目标值
                return mid;
            }
        }
        //循环结束，未找到
        return -1;
    }
}
>```
### 2、移除元素

> [!NOTE]- [27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/description/)
快慢指针
>```java
> class Solution {
    public int removeElement(int[] nums, int val) {
        int slowIndex=0;//慢指针，用于记录等于val的下标
        int fastIndex=0;//快指针
        for(;fastIndex<nums.length;fastIndex++){
            if(nums[fastIndex]!=val){//快指针的值不等于val值的话就覆盖慢指针的值
                nums[slowIndex++]=nums[fastIndex];
            }
        }
        return slowIndex;
    }
}
>```
### 3、有序数组平方

> [!NOTE]- [977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)
双向指针
>```java
> class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] result=new int[nums.length];//创建新数组
        int index=nums.length-1;//表示新数组末尾下标
        //双向指针判断出每次平方的最大值
        int left=0;
        int right=nums.length-1;
        while(left<=right){
            if(nums[left]*nums[left]>nums[right]*nums[right]){//负数平方大于后面的值的平方
                result[index--]=nums[left]*nums[left];//给新数组赋值，下标减一
                left++;//原数组前指针后移
            }else{
                result[index--]=nums[right]*nums[right];
                right--;
            }
        }
        return result;
    }
}
>```
### 4、长度最小的子数组

> [!NOTE]- [209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)
> 滑动窗口
> ```java
> class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left=0;//记录窗口最左的下标
        int result=Integer.MAX_VALUE;//窗口初始大小
        int sum=0;//记录窗口中值的和
        for(int right=0;right<nums.length;right++){
            sum+=nums[right];//扩大窗口，增值
            while(sum>=target){//循环缩小窗口至sum小于目标值
                result=Math.min(result,right-left+1);//判断出出窗口最小长度
                sum-=nums[left++];//窗口缩小同时sum要减小
            }
        }
        return result==Integer.MAX_VALUE?0:result;
    }
}
>```

### 5、螺旋矩阵

> [!NOTE]- [59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)
>```java
>class Solution {
    public int[][] generateMatrix(int n) {
        int loop=0;//循环次数
        int count=1;//从1开始
        int start=0;//每次循环起始位置
        int i,j=0;//横纵坐标
        int[][] res=new int[n][n];//结果数组
        while(loop++<n/2){//为什么loop从一开始，因为每次循环最后不包括边界值
            for(j=start;j<n-loop;j++){//上侧从左往右
                res[start][j]=count++;
            }
            for(i=start;i<n-loop;i++){//右侧从上往下
                res[i][j]=count++;
            }
            for(;j>start;j--){//下侧从右往左
                res[i][j]=count++;
            }
            for(;i>start;i--){//左侧从下往上
                res[i][j]=count++;
            }
            start++;
        }
        if(n%2==1){
            res[start][start]=count;
        }
        return res;
    }
}
>```

## 链表
### 1、移出链表元素

> [!NOTE]- [203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)
>```java
>class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head==null){
            return head;
        }
        ListNode dummy=new ListNode(-1,head);//设置虚拟头结点
        ListNode pre=dummy;//用来修改虚拟头结点
        ListNode cur=head;
        while(cur!=null){
            if(cur.val==val){
                pre.next=cur.next;
            }else{
                pre=cur;
            }
            cur=cur.next;
        }
        return dummy.next;
    }
}
>```

### 2、设计链表

> [!NOTE]- [707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/)
>```java
> class MyLinkedList {
    private int size;//链表节点个数
    private ListNode head;//虚拟头结点
    public MyLinkedList() {//初始化
        this.size=0;
        this.head=new ListNode(-1);
    }
    public int get(int index) {//根据下标获取元素值
        if(index<0||index>=size){
            return -1;
        }
        ListNode cur=head;
        for(int i=0;i<=index;i++){
            cur=cur.next;
        }
        return cur.val;
    }
    public void addAtHead(int val) {
        addAtIndex(0,val);
    }
    public void addAtTail(int val) {
        addAtIndex(size,val);
    }
    public void addAtIndex(int index, int val) {
        if(index>this.size){
            return;
        }
        if(index<0){
            index=0;
        }
        this.size++;
        ListNode pre=head;
        for(int i=0;i<index;i++){
            pre=pre.next;
        }
        ListNode newNode=new ListNode(val);
        newNode.next=pre.next;
        pre.next=newNode;
    }
    public void deleteAtIndex(int index) {
        if(index<0||index>=size){
            return;
        }
        this.size--;
        if(index==0){
            head=head.next;
            return;
        }
        ListNode pre=head;
        for(int i=0;i<index;i++){
            pre=pre.next;
        }
        pre.next=pre.next.next;
    }
}
class ListNode{//单链表
    int val;
    ListNode next;
    public ListNode(){
    public ListNode(int val){
        this.val=val;
    }
}
>```

### 3、反转链表

> [!NOTE]- [206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)
>```java
> class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null){
            return head;
        }
        ListNode cur=head;
        ListNode pre=null;
        ListNode temp=null;//保存cur的下一个节点
        while(cur!=null){
            temp=cur.next;//因为cur的next指针要指向前面的pre，所以要提前保存cur的下一个节点
            cur.next=pre;//链表向后指
            pre=cur;
            cur=temp;
        }
        return pre;
    }
}
>```

### 4、两两交换链表中的节点

> [!NOTE]- [24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/)
>```java
> class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head==null){
            return head;
        }
        ListNode dummy=new ListNode(-1,head);//设置虚拟头结点
        ListNode cur=dummy;//设置当前节点
        ListNode temp;//保存两个交换节点的下一个节点
        ListNode firstNode;//交换的第一个节点
        ListNode secondNode;//交换的第二个节点
        while(cur.next!=null&&cur.next.next!=null){//保证后面有两个节点可以进行交换
            temp=cur.next.next.next;//保存两个节点后面的一个节点，方便进行连接
            firstNode=cur.next;
            secondNode=cur.next.next;
            //转移链表指针
            cur.next=secondNode;
            secondNode.next=firstNode;
            firstNode.next=temp;
            cur=firstNode;//下一次交换的虚拟头结点
        }
        return dummy.next;
    }
}
>```

### 5、删除链表倒数第 n 个节点

> [!NOTE]- [19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
>```java
> class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head==null){
            return head;
        }
        ListNode dummy=new ListNode(-1,head);//设置虚拟头结点
        ListNode fast=dummy;
        ListNode slow=dummy;
        for(int i=0;i<=n;i++){//快指针前进n+1步
            fast=fast.next;
        }
        while(fast!=null){//当快指针为空时，慢指针的下一个节点就是将要删除的节点
            slow=slow.next;
            fast=fast.next;
        }
        slow.next=slow.next.next;
        return dummy.next
    }
}
>```

### 6、链表相交

> [!NOTE]- [面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)
>```java
> public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA=headA;
        ListNode curB=headB;
        //获取链表A和链表B的长度
        int lenA=0;
        int lenB=0;
        while(curA!=null){
            lenA++;
            curA=curA.next;
        }
        while(curB!=null){
            lenB++;
            curB=curB.next;
        }
        //恢复为初始状态
        curA=headA;
        curB=headB;
        //始终认为链表A长于链表B
        if(lenB>lenA){
            //交换链表长度
            int tempLen=lenA;
            lenA=lenB;
            lenB=tempLen;
            //交换头结点
            ListNode tempNode=curA;
            curA=curB;
            curB=tempNode;
        }
        //计算长度的差值
        int gap=lenA-lenB;
        //根据差值将链表A的头结点设置为同一起跑线
        while(gap-->0){
            curA=curA.next;
        }
        while(curA!=null){
            if(curA==curB){
                return curA;//找到相交节点
            }
            curA=curA.next;
            curB=curB.next;
        }
        //不相交
        return null;
    }
}
>```

### 7、环形链表 2

> [!NOTE]- [142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/)
>```java
> public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast=head;//快指针，每次移动两个节点
        ListNode slow=head;//慢指针，每次移动一个节点
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow){//存在环
                ListNode index1=fast;
                ListNode index2=head;
                //节点和头结点每次走一步，相交的位置就是环的入口
                while(index1!=index2){
                    index1=index1.next;
                    index2=index2.next;
                }
                return index1;
            }
        }
        return null;//不存在环
    }
}
>```

## 哈希表
### 1、有效的字母异位词

> [!NOTE]- [242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/)
>```java
> class Solution {
    public boolean isAnagram(String s, String t) {
        int[] count=new int[26];//把数组当做一个哈希表，容纳26个字母
        for(int i=0;i<s.length();i++){//将每个字母放入对应哈希表的位置，每出现一次就加一
            count[s.charAt(i)-'a']++;
        }
        for(int i=0;i<t.length();i++){//遍历字符串将出现的每个字母对应的数值减一
            count[t.charAt(i)-'a']--;
        }
        //遍历整个哈希表，如果存在有字母数值不为0的情况，说明并不是字母异位词
        for(int i=0;i<count.length;i++){
            if(count[i]!=0){
                return false;
            }
        }
        return true;
    }
}
>```

### 2、两个数组的交集

> [!NOTE]- [349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/)
```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        if(nums1==null||nums1.length==0||nums2==null||nums2.length==0){//如果存在一个数组为空，那么就不可能存在交集
            return new int[0];//返回空数组
        }
        Set<Integer> set=new HashSet<>();
        Set<Integer> resSet=new HashSet<>();
        //将nums1的元素存入set去重
        for(int num:nums1){
            set.add(num);
        }
        //遍历nums2,查看哪些元素存在set集合
        for(int num:nums2){
            if(set.contains(num)){
                resSet.add(num);
            }
        }
        //将保存交集的set集合转为数组
        return resSet.stream().mapToInt(x->x).toArray();
    }
}
```

### 3、快乐数

> [!NOTE]- [202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/)
```java
class Solution {
    public boolean isHappy(int n) {
        //本题关键点：不是快乐数的话会循环到起始值n
        Set<Integer> set=new HashSet<>();//set集合保存结果集
        while(n!=1&&!set.contains(n)){//如果n为1就是快乐数，如果结果重复就不是快乐数
            set.add(n);//保存每次结果
            n=getNextNumber(n);//获取每次结果
        }
        return n==1;
    }
    public Integer getNextNumber(int n){
        int res=0;
        while(n>0){
            int temp=n%10;
            res+=temp*temp;
            n/=10;
        }
        return res;
    }
}
```
      
### 4、两数之和

> [!NOTE]- [1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/)
>```java
> class Solution {
    public int[] twoSum(int[] nums, int target) {
        //数组中同一个元素在答案里不能重复出现,两个数的下标不能一样
        int[] res=new int[2];//结果集
        Map<Integer,Integer> map=new HashMap<>();//key为数值，value为下标
        for(int i=0;i<nums.length;i++){
            int gap=target-nums[i];//求每次遍历的差值
            if(map.containsKey(gap)){//当前差值与当前num的不正好是target吗
                res[0]=i;
                res[1]=map.get(gap);
                break;
            }
            map.put(nums[i],i);//有重复值无所谓，只需要一个结果
        }
        return res;
    }
}
>```

### 5、四数相加

> [!NOTE]- [454. 四数相加 II - 力扣（LeetCode）](https://leetcode.cn/problems/4sum-ii/description/)
>```java
> class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        int count=0;
        Map<Integer,Integer> sum=new HashMap<>();
        for(int i:nums1){//统计数组1和数组2两两相加和出现的次数
            for(int j:nums2){
                sum.put(i+j,sum.getOrDefault(i+j,0)+1);
            }
        }
        //判断sum集合中是否数组3和数组4两两相加之和的相反数
        for(int i:nums3){
            for(int j:nums4){
                count+=sum.getOrDefault(0-i-j,0);
            }
        }
        return count;
    }
}
>```

### 6、赎金信

> [!NOTE]- [383. 赎金信 - 力扣（LeetCode）](https://leetcode.cn/problems/ransom-note/)
>```java
> class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        //如果ransomNote长度大于magazine的话那肯定是无法构成的
        if(ransomNote.length()>magazine.length()){
            return false;
        }
        int[] res=new int[26];
        for(char c:magazine.toCharArray()){
            res[c-'a']+=1;
        }
        for(char c:ransomNote.toCharArray()){
            res[c-'a']-=1;
        }
        for(int i:res){
            if(i<0){//如果存在小于0的情况，说明ransomNote所需的某个字符个数大于magazine中字符的数量
                return false;
            }
        }
        return true;
    }
}
>```

### 7、三数之和

> [!NOTE]- [15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/description/)
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res=new ArrayList<>();
        int left;//左指针
        int right;//右指针
        //先将nums排序
        Arrays.sort(nums);
        for(int i=0;i<nums.length;i++){
            if(nums[i]>0){
                //最小的数都大于0,3数之和肯定大于0
                return res;
            }
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }
            left=i+1;
            right=nums.length-1;
            while(left<right){
                //3数之和大于0
                if(nums[i]+nums[left]+nums[right]>0){
                    right--;
                }else if(nums[i]+nums[left]+nums[right]<0){
                    left++;
                }else{
                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    while(left<right&&nums[right]==nums[right-1]){
                        right--;
                    }
                    while(left<right&&nums[left]==nums[left+1]){
                        left++;
                    }
                    right--;
                    left++;
                }
            }
        }
        return res;
    }
}
```
### 8、四数之和

> [!NOTE]- [18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/)
```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res=new ArrayList<>();
        Arrays.sort(nums);
        for(int i=0;i<nums.length;i++){
            if(nums[i] > 0&&nums[i]>target){
                return res;
            }
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }
            for(int j=i+1;j<nums.length;j++){
                if(j>i+1&&nums[j]==nums[j-1]){
                    continue;
                }
                int left=j+1;
                int right=nums.length-1;
                while(left<right){
                    long sum=(long)nums[i]+nums[j]+nums[left]+nums[right];
                    if(sum>target){
                        right--;
                    } else if(sum<target){
                        left++;
                    }else{
                        res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));
                        while(left<right&&nums[right]==nums[right-1]){
                            right--;
                        }
                        while(left<right&&nums[left]==nums[left+1]){
                            left++;
                        }
                        right--;
                        left++;
                    }
                }
            }
        }
        return res;
    }
}
```

## 字符串
### 1、反转字符串

> [!NOTE]- [344. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/)
>```java
> class Solution {
    public void reverseString(char[] s) {
        int left=0;
        int right=s.length-1;
        while(left<right){
            char temp=s[left];
            s[left]=s[right];
            s[right]=temp;
            left++;
            right--;
        }
    }
}
>```

### 2、反转字符串 2

> [!NOTE]- [541. 反转字符串 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string-ii/)
>```java
>class Solution {
    public String reverseStr(String s, int k) {
        //每隔2k个反转前k个，不足k个全部反转
        char[] c=s.toCharArray();
        for(int i=0;i<c.length;i+=2*k){//每次向前移动2k个
            int start=i;
            int end=Math.min(c.length-1,start+k-1);//判断剩余字符是否大于k个
            while(start<end){//异或方式进行交换
                c[start]^=c[end];
                c[end]^=c[start];
                c[start]^=c[end];
                start++;
                end--;
            }
        }
        return new String(c);
    }
} 
>```
### 3、反转字符中的单词

> [!NOTE]- [151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/)
>```java
>class Solution {
    public String reverseWords(String s) {
        char[] res=new char[s.length()+1];//为什么要加一，因为后面每次往数组里存入一个单词都会在后面加一个空格，直到加到最后一个单词，也就多了一个空格，因此加一是为了防止数组下标越界
        int resIndex=0;//字符数组下标
        //从后往前遍历字符串，空格作为分隔符
        int i=s.length()-1;
        while(i>=0){
            //从后向前去掉空格
            while(i>=0&&s.charAt(i)==' '){
                i--;
            }
            int end=i;//记录单词末尾字符下标
            while(i>=0&&s.charAt(i)!=' '){//计算单词起始下标
                i--;
            }
            for(int j=i+1;j<=end;j++){
                //将单词字符加入字符数组中
                res[resIndex++]=s.charAt(j);
                //当单词加入完毕后，要加空格
                if(j==end){
                    res[resIndex++]=' ';
                }
            }
        }
        return new String(res,0,resIndex-1);
    }
} 
>```

### 4、找出字符串中第一个匹配项的下标

> [!NOTE]- [28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)
>```java
>class Solution {
    public int strStr(String haystack, String needle) {
        if(needle.length()==0){
            return -1;
        }
        int j=-1;
        int[] next=new int[needle.length()];
        getNext(next,needle);
        for(int i=0;i<haystack.length();i++){
            while(j>=0&&haystack.charAt(i)!=needle.charAt(j+1)){
                j=next[j];
            }
            if(haystack.charAt(i)==needle.charAt(j+1)){
                j++;
            }
            if(j==needle.length()-1){
                return i-needle.length()+1;
            }
        }
        return -1;
    }
    public void getNext(int[] next,String needle){
        int j=-1;
        next[0]=j;
        for(int i=1;i<needle.length();i++){
            while(j>=0&&needle.charAt(i)!=needle.charAt(j+1)){
                j=next[j];
            }
            if(needle.charAt(i)==needle.charAt(j+1)){
                j++;
            }
            next[i]=j;
        }
    }
} 
>```
### 5、重复的子字符串

> [!NOTE]- [459. 重复的子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/repeated-substring-pattern/description/)
>```java
>class Solution {
    public boolean repeatedSubstringPattern(String s) {
        //判断字符串是否由重复子串组成，只要将两个s拼接起来，如果里面还出现一个一个s就说明是重复子串组成
        String res=s+s;
        return res.substring(1,res.length()-1).contains(s);
    }
} 
>```

## 双指针
### 1、移除元素

> [!NOTE]- [27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/)
>```java
>class Solution {
    public int removeElement(int[] nums, int val) {
        int slow=0;
        for(int fast=0;fast<nums.length;fast++){
            if(nums[fast]!=val){
                nums[slow++]=nums[fast];
                continue;
            }
        }
        return slow;
    }
} 
>```
### 2、反转字符串

> [!NOTE]- [344. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/)
>```java
>class Solution {
    public void reverseString(char[] s) {
        int left=0;
        int right=s.length-1;
        while(left<right){
            s[left]^=s[right];
            s[right]^=s[left];
            s[left]^=s[right];
            left++;
            right--;
        }
    }
} 
>```
### 3、反转字符串中的单词

> [!NOTE]- [151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/)
> class Solution {
    public String reverseWords(String s) {
        char[] res=new char[s.length()+1];
        int resIndex=0;
        for(int i=s.length()-1;i>=0;i--){
            while(i>=0&&s.charAt(i)==' '){
                i--;
            }
            int right=i;
            while(i>=0&&s.charAt(i)!=' '){
                i--;
            }
            for(int j=i+1;j<=right;j++){
                res[resIndex++]=s.charAt(j);
                if(j==right){
                    res[resIndex++]=' ';
                }
            }
        }
        return new String(res,0,resIndex-1);
    }
}
### 4、反转链表

> [!NOTE]- [206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)
>```java
>class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur=head;
        ListNode temp=null;
        ListNode pre=null;
        while(cur!=null){
            temp=cur.next;
            cur.next=pre;
            pre=cur;
            cur=temp;
        }
        return pre;
    }
} 
>```
### 5、删除链表中倒数第 n 个节点

> [!NOTE]- [19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
>```java
>class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy=new ListNode(-1,head);
        ListNode slow=dummy;
        ListNode fast=dummy;
        for(int i=0;i<n;i++){
            fast=fast.next;
        }
        while(fast.next!=null){
            slow=slow.next;
            fast=fast.next;
        }
        slow.next=slow.next.next;
        return dummy.next;
    }
} 
>```
### 6、链表相交

> [!NOTE]- [面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)
>```java
>public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA==null||headB==null){
            return null;
        }
        int lenA=0;
        int lenB=0;
        ListNode curA=headA;
        ListNode curB=headB;
        while(curA!=null){
            curA=curA.next;
            lenA++;
        }
        while(curB!=null){
            curB=curB.next;
            lenB++;
        }
        curA=headA;
        curB=headB;
        if(lenA<lenB){
            int tempLen=lenA;
            lenA=lenB;
            lenB=tempLen;
            ListNode tempNode=curA;
            curA=curB;
            curB=tempNode;
        }
        int gap=lenA-lenB;
        for(int i=0;i<gap;i++){
            curA=curA.next;
        }
        while(curA!=null){
            if(curA==curB){
                return curA;
            }
            curA=curA.next;
            curB=curB.next;
        }
        return null;
    }
} 
>```

### 7、环形链表 2

> [!NOTE]- [142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/)
>```java
>public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow=head;
        ListNode fast=head;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            slow=slow.next;
            if(fast==slow){
                ListNode start=head;
                ListNode end=fast;
                while(start!=end){
                    start=start.next;
                    end=end.next;
                }
                return end;
            }
        }
        return null;
    }
} 
>```

### 8、三数之和

> [!NOTE]- [15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/)
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res=new ArrayList<>();
        Arrays.sort(nums);
        for(int i=0;i<nums.length;i++){
            if(nums[i]>0){
                return res;
            }
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }
            int left=i+1;
            int right=nums.length-1;
            while(left<right){
                int sum=nums[i]+nums[left]+nums[right];
                if(sum>0){
                    right--;
                }else if(sum<0){
                    left++;
                }else{
                    res.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    while(left<right&&nums[right]==nums[right-1]){
                        right--;
                    }
                    while(left<right&&nums[left]==nums[left+1]){
                        left++;
                    }
                    right--;
                    left++;
                }
            }
        }
        return res;
    }
}
```
### 9、四数之和

> [!NOTE]- [18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/)
```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res=new ArrayList<>();
        Arrays.sort(nums);
        for(int i=0;i<nums.length;i++){
            if(nums[i]>0&&nums[i]>target){
                return res;
            }
            if(i>0&&nums[i]==nums[i-1]){
                continue;
            }
            for(int j=i+1;j<nums.length;j++){
                if(j>i+1&&nums[j]==nums[j-1]){
                    continue;
                }
                int left=j+1;
                int right=nums.length-1;
                while(left<right){
                    long sum=(long)nums[i]+nums[j]+nums[left]+nums[right];
                    if(sum>target){
                        right--;
                    }else if(sum<target){
                        left++;
                    }else{
                        res.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));
                        while(left<right&&nums[right]==nums[right-1]){
                            right--;
                        }
                        while(left<right&&nums[left]==nums[left+1]){
                            left++;
                        }
                        right--;
                        left++;
                    }
                }
            }
        }
        return res;
    }
}
```
## 栈与队列
### 1、用栈实现队列

> [!NOTE]- [232. 用栈实现队列 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-queue-using-stacks/)
```java
class MyQueue {
    Stack<Integer> stackIn;//进入队列
    Stack<Integer> stackOut;//出队
    public MyQueue() {
        stackIn=new Stack<>();
        stackOut=new Stack<>();
    }
    //进队操作
    public void push(int x) {
        stackIn.push(x);
    }
    //出队操作
    public int pop() {
        //先将进入栈中的数据导入出队栈中
        dumpSatckIn();
        //将出队栈中顶部元素移出就是将模拟队列的首个元素移出
        return stackOut.pop();
    }
    //获取队列头元素
    public int peek() {
        //将进入栈中的数据导入出队栈
        dumpSatckIn();
        //获取出队栈中顶部元素
        return stackOut.peek();
    }
    
    public boolean empty() {
        return stackIn.isEmpty()&&stackOut.isEmpty();
    }
    public void dumpSatckIn(){
        //如果出队栈中还有数据，就直接移出，不用将进队栈中的数据导入
        if(!stackOut.isEmpty()){
            return;
        }
        //如果出队栈中没有数据才将进队栈中数据导入
        while(!stackIn.isEmpty()){
            stackOut.push(stackIn.pop());
        }
    }

}
```
### 2、用队列实现栈

> [!NOTE]- [225. 用队列实现栈 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-stack-using-queues/)
```java
class MyStack {
    Queue<Integer> queue1;//主队列
    Queue<Integer> queue2;//辅助队列
    public MyStack() {
        queue1=new LinkedList<>();
        queue2=new LinkedList<>();
    }
    //倒序加入
    public void push(int x) {
        queue2.offer(x);//先存入辅助队列
        //再将主队列中的元素加入辅助队列
        while(!queue1.isEmpty()){
            queue2.offer(queue1.poll());
        }
        //交换队列，此时queue2的队头就是栈顶
        Queue<Integer> queueTemp=queue2;
        queue2=queue1;
        queue1=queueTemp;
    }
    
    public int pop() {
        return queue1.poll();
    }
    
    public int top() {
        return queue1.peek();
    }
    
    public boolean empty() {
        return queue1.isEmpty();
    }
}
```

### 3、有效的括号

> [!NOTE]- [20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/)
```java
class Solution {
    public boolean isValid(String s) {
        //现有左括号在匹配右括号，一上来就是右括号那就无法匹配
        Deque<Character> stack=new LinkedList<>();
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='('){
                stack.push(')');
            }else if(s.charAt(i)=='['){
                stack.push(']');
            }else if(s.charAt(i)=='{'){
                stack.push('}');
            }else if(stack.isEmpty()||stack.peek()!=s.charAt(i)){//左括号还没出来右括号就先出来了，右括号与最近的左括号不匹配
                return false;
            }else{//左括号与右括号匹配
                stack.poll();
            }
        }
        //如果最后栈元素为空，说明所有括号都匹配了
        return stack.isEmpty();
    }
}
```
### 4、删除字符创中所有相邻的重复项

> [!NOTE]- [1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)
```java
class Solution {
    public String removeDuplicates(String s) {
        Deque<Character> stack=new ArrayDeque<>();
        for(int i=0;i<s.length();i++){
            char c=s.charAt(i);
            if(stack.isEmpty()||stack.peek()!=c){//栈为空或当前字符不等于栈顶字符，就可以加入
                stack.push(c);
            }else{//相等就去除
                stack.pop();
            }
        }
        String res="";
        while(!stack.isEmpty()){
            res=stack.pop()+res;
        }
        return res;
    }
}
```
### 5、逆波兰表达式求值

> [!NOTE]- [150. 逆波兰表达式求值 - 力扣（LeetCode）](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)
```java
class Solution {
    public int evalRPN(String[] tokens) {
        Deque<Integer> stack=new LinkedList<>();
        for(String s:tokens){
            if("+".equals(s)){
                stack.push(stack.pop()+stack.pop());
            }else if("-".equals(s)){
                stack.push(-stack.pop()+stack.pop());//先入栈的减去后入栈的
            }else if("*".equals(s)){
                stack.push(stack.pop()*stack.pop());
            }else if("/".equals(s)){//先入栈的除以后入栈的
                int second=stack.pop();
                int first=stack.pop();
                stack.push(first/second);
            }else{//不是运算符入栈
                stack.push(Integer.valueOf(s));
            }
        }
        return stack.pop();
    }
}
```
### 6、滑动窗口最大值

> [!NOTE]- [239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/)
```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> queue=new ArrayDeque<>();//模拟单调队列
        int len=nums.length;
        int[] res=new int[len-k+1];//结果数组，本以为是len-1,但len=1,k=1这种情况就不符合
        int index=0;//结果数组下标
        for(int i=0;i<nums.length;i++){
            //单调队列队头存放最大值下标
            //判断队头元素的下标是否在
            while(!queue.isEmpty()&&queue.peek()<i-k+1){
                queue.poll();//去掉头部元素
            }
            while(!queue.isEmpty()&&nums[queue.peekLast()]<nums[i]){//每次入队都大于前面的数的话，前面的数就永无翻身之日
                queue.pollLast();
            }
            queue.offer(i);
            if(i>=k-1){
                res[index++]=nums[queue.peek()];
            }
        }
        return res;
    }
}
```
### 7、前 k 个高频元素

> [!NOTE]- [347. 前 K 个高频元素 - 力扣（LeetCode）](https://leetcode.cn/problems/top-k-frequent-elements/)
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer,Integer> map=new HashMap<>();//key为值，value为出现次数
        int[] res=new int[k];
        for(int num:nums){//统计每个值出现的次数
            map.put(num,map.getOrDefault(num,0)+1);
        }
        //设置优先级队列，按照值的次数进行排序
        PriorityQueue<int[]> queue=new PriorityQueue<>((pair1,pair2)-> pair2[1]-pair1[1]);
        for(Map.Entry<Integer,Integer> entry:map.entrySet()){
            queue.add(new int[]{entry.getKey(),entry.getValue()});
        }
        //获取前k个值
        for(int i=0;i<k;i++){
            res[i]=queue.poll()[0];
        }
        return res;
    }
}
```
## 二叉树
### 1、二叉树前序遍历 (递归方式)

> [!NOTE]- [144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result=new ArrayList<>();
        preorder(root,result);
        return result;
    }
    private void preorder(TreeNode node,List<Integer> res){
        if(node==null){
            return;
        }
        res.add(node.val);//当前节点不为空，加入结果集合
        preorder(node.left,res);//先遍历左节点
        preorder(node.right,res);//再遍历右节点
    }
}
```
### 2、二叉树后序遍历 (递归方式)

> [!NOTE]- [145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/)
```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result=new ArrayList<>();
        postorder(root,result);
        return result;
    }
    private void postorder(TreeNode node,List<Integer> res){
        if(node==null){
            return;
        }
        postorder(node.left,res);
        postorder(node.right,res);
        res.add(node.val);
    }
}
```
### 3、二叉树中序遍历 (递归方式)

> [!NOTE]- [94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result=new ArrayList<>();
        inorder(root,result);
        return result;
    }
    private void inorder(TreeNode node,List<Integer> res){
        if(node==null){
            return;
        }
        inorder(node.left,res);
        res.add(node.val);
        inorder(node.right,res);
    }
}
```
### 4、二叉树前序遍历 (迭代方式)

> [!NOTE]- [144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result=new ArrayList<>();
        if(root==null){
            return result;
        }
        Stack<TreeNode> stack=new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode cur=stack.pop();
            result.add(cur.val);
            if(cur.right!=null){
                stack.push(cur.right);
            }
            if(cur.left!=null){
                stack.push(cur.left);
            }
        }
        return result;
    }
}
```
### 5、二叉树的中序遍历 (迭代方式)

> [!NOTE]- [94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result=new ArrayList<>();
        if(root==null){
            return result;
        }
        TreeNode cur=root;
        Stack<TreeNode> stack=new Stack<>();
        while(cur!=null||!stack.isEmpty()){
            if(cur!=null){
                stack.push(cur);
                cur=cur.left;
            }else{
                cur=stack.pop();
                result.add(cur.val);
                cur=cur.right;
            }
        }
        return result;
    }
}
```
### 6、二叉树后序遍历 (迭代方式)

> [!NOTE]- [145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/)
```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result=new ArrayList<>();
        if(root==null){
            return result;
        }
        Stack<TreeNode> stack=new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode cur=stack.pop();
            result.add(cur.val);
            if(cur.left!=null){
                stack.push(cur.left);
            }
            if(cur.right!=null){
                stack.push(cur.right);
            }
        }
        Collections.reverse(result);
        return result;
    }
}
```
### 7、二叉树层序遍历

> [!NOTE]- [102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result=new ArrayList<>();
        if(root==null){
            return result;
        }
        Queue<TreeNode> queue=new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            List<Integer> list=new ArrayList<>();
            int len=queue.size();
            while(len-->0){
                TreeNode cur=queue.poll();
                list.add(cur.val);
                if(cur.left!=null){
                    queue.offer(cur.left);
                }
                if(cur.right!=null){
                    queue.offer(cur.right);
                }
            }
            result.add(list);
        }
        return result;
    }
}
```
### 8、翻转二叉树 

> [!NOTE]- [226. 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/)
```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null){
            return null;
        }
        //前序遍历交换左右子节点
        swap(root);
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
    private void swap(TreeNode node){
        TreeNode temp=node.left;
        node.left=node.right;
        node.right=temp;
    }
}
```
### 9、对称二叉树

> [!NOTE]- [101. 对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/symmetric-tree/)
```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return compare(root.left,root.right);
    }
    private boolean compare(TreeNode left,TreeNode right){
        if(left==null&&right!=null){
            return false;
        }
        if(right==null&&left!=null){
            return false;
        }
        if(left==null&&right==null){
            return true;
        }
        if(left.val!=right.val){
            return false;
        }
        boolean compareOutside=compare(left.left,right.right);
        boolean compareInside=compare(left.right,right.left);
        return compareOutside&&compareInside;
    }
}
```
### 10、二叉树最大深度

> [!NOTE]- [104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null){
            return 0;
        }
        int depth=0;
        Deque<TreeNode> queue=new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            int len=queue.size();
            depth++;
            while(len-->0){
                TreeNode cur=queue.poll();
                if(cur.left!=null){
                    queue.offer(cur.left);
                }
                if(cur.right!=null){
                    queue.offer(cur.right);
                }
            }
        }
        return depth;
    }
}
```
### 11、n 叉树的最大深度

> [!NOTE]- [559. N 叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)
```java
class Solution {
    public int maxDepth(Node root) {
        if(root==null){
            return 0;
        }
        Deque<Node> queue=new LinkedList<>();
        int depth=0;
        queue.offer(root);
        while(!queue.isEmpty()){
            int len=queue.size();
            depth++;
            while(len-->0){
                Node cur=queue.poll();
                for(int i=0;i<cur.children.size();i++){
                    if(cur.children.get(i)!=null){
                        queue.offer(cur.children.get(i));
                    }
                }
            }
        }
        return depth;
    }
}
```
### 12、二叉树的最小深度

> [!NOTE]- [111. 二叉树的最小深度 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
```java
class Solution {
    public int minDepth(TreeNode root) {
    //只有左右子树都为空才满足叶子结点
        if(root==null){
            return 0;
        }
        int minLeft=minDepth(root.left);//获取左子树的最小深度
        int minRight=minDepth(root.right);//获取右子树的最小深度
        if(root.left==null&&root.right!=null){//如果左子树为空，右子树不为空，那么左子树肯定不满足叶子结点条件
            return minRight+1;
        }
        if(root.right==null&&root.left!=null){
            return minLeft+1;
        }
        return Math.min(minLeft,minRight)+1;
    }
}
```
### 13、完全二叉树的节点个数

> [!NOTE]- [222. 完全二叉树的节点个数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-complete-tree-nodes/)
```java
class Solution {
    public int countNodes(TreeNode root) {
        int result=0;//记录节点个数
        if(root==null){//根节点为空返回0
            return 0;
        }
        Deque<TreeNode> queue=new LinkedList<>();//层序遍历采用队列存储
        queue.offer(root);
        while(!queue.isEmpty()){
            int len=queue.size();//当前层的节点个数
            while(len-->0){
                result++;//每出队一个节点，记录一个一个节点
                TreeNode cur=queue.poll();
                if(cur.left!=null){
                    queue.offer(cur.left);
                }
                if(cur.right!=null){
                    queue.offer(cur.right);
                }
            }
        }
        return result;
    }
}
```
```java
class Solution {
    public int countNodes(TreeNode root) {
         if (root == null) return 0;
        TreeNode left = root.left;
        TreeNode right = root.right;
        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求子数方便
        while (left != null) {  // 求左子树深度
            left = left.left;
            leftDepth++;
        }
        while (right != null) { // 求右子树深度
            right = right.right;
            rightDepth++;
        }
        if (leftDepth == rightDepth) {
            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0
        }
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
}
```

### 14、平衡二叉树

> [!NOTE] [110. 平衡二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/balanced-binary-tree/
```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        //平衡二叉树的左右子树高度差不能超过1
        return getHeight(root)!=-1;
    }
    private int getHeight(TreeNode root){//后序遍历求高度差
        if(root==null){
            return 0;
        }
        int leftHeight=getHeight(root.left);//求左子树的深度
        if(leftHeight==-1){
            return -1;//说明左子树的子树高度差超过了1
        }
        int rightHeight=getHeight(root.right);//求右子树深度
        if(rightHeight==-1){
            return -1;//说明右子树的子树高度差超过了1
        }
        //如果当前节点的左右子树高度差超过了1，那就返回-1
        if(Math.abs(leftHeight-rightHeight)>1){
            return -1;
        }
        //高度差没有超过1，深度加一
        return Math.max(leftHeight,rightHeight)+1;
    }
}
```

### 15、二叉树的所有路径
> [!NOTE] [257. 二叉树的所有路径 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-paths/)
```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res=new ArrayList<>();//结果集
        if(root==null){
            return null;
        }
        List<Integer> path=new ArrayList<>();
        traversal(root,path,res);
        return res;
    }
    private void traversal(TreeNode root,List<Integer> path,List<String> res){
        path.add(root.val);//前序遍历
        if(root.left==null&&root.right==null){
            //左右子节点都为空，将路径加入结果集
            StringBuilder sb=new StringBuilder();
            //将路径节点拼接为字符串
            int i=0;
            for(;i<path.size()-1;i++){
                sb.append(path.get(i)).append("->");
            }
            //加入最后一个节点
            sb.append(path.get(i));
            res.add(sb.toString());
            return;
        }
        if(root.left!=null){
            traversal(root.left,path,res);
            //回溯
            path.remove(path.size()-1);
        }
        if(root.right!=null){
            traversal(root.right,path,res);
            path.remove(path.size()-1);
        }
    }
}
```

### 16、左叶子之和

> [!NOTE] [404. 左叶子之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-left-leaves/)
```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if(root==null){
            return 0;
        }
        //后序遍历
        int leftValue=sumOfLeftLeaves(root.left);//左子树左叶子之和
        int rightValue=sumOfLeftLeaves(root.right);//右子树左叶子之和
        int midValue=0;
        //当前节点不为空且左节点的左节点为空，左节点的右节点为空
        if(root.left!=null&&root.left.left==null&&root.left.right==null){
            midValue=root.left.val;
        }
        int sum=midValue+rightValue+leftValue;
        return sum;
    }
}
```









