***
## MySQL 体系结构和存储引擎
### 定义数据和实例
**数据库**：数据库文件的集合，保存数据的容器
**数据库实例**：系统上的一个进程，一个程序
<mark style="background: #ABF7F7A6;">数据库是数据文件的集合，想对这些文件进行增删改查，需要通过数据库实例来操作</mark>
数据库实例启动时，回去读取配置文件，获取启动的参数，如果没有配置文件，就按默认的启动参数启动
在 linux 下 MySQL 的配置文件默认在/etc/my.cnf 下，可以修改这个配置文件
<mark style="background: #FFF3A3A6;">问题：如果多个配置文件有相同配置参数，那么以哪个配置文件的参数为准</mark>
- 以读取到的最后一个配置文件的参数为准
### MySQL 体系结构
![[Pasted image 20231115225138.png]]
**存储引擎是基于表的，而不是数据库**
### MySQL 的存储引擎
<mark style="background: #ABF7F7A6;">存储引擎的好处就是，能够根据不同的需求建立不同的存储引擎表</mark>
#### InnoDB 存储引擎
- InnoDB 通过使用多版本并发控制 (MVCC)具有高并发的特性，同时也支持事务机制，实现了 SQL 的四种隔离级别，默认的隔离级别是 RR (可重复读)
- InnoDB 还提供了插入缓冲、二次写、自适应哈希、预读等高性能，高可用的功能
- InnoDB 必须存在主键，如果没有主键或非空唯一索引，那么就会自动生成一个 6 字节的主键 (用户不可见)
- InnoDB 的表都存放在一个 idb 文件中
#### MyISAM 存储引擎
- MyISAM 不支持事务机制，也不支持行锁
- MyISAM 支持全文索引
- MyISAM 的缓冲池只缓存索引文件，而不缓存数据文件
- MyISAM 的表存储在两个文件中，一个单独存放索引文件，一个单独存放数据文件
#### NDB 存储引擎
- NDB 存储引擎就是一个集群存储引擎，也没有怎么用过，不多加赘述
#### Memory 存储引擎
- Memory 引擎存储的数据都在内存上，如果数据库突然宕机，那么数据都会消失，所以 Memory 引擎安全性不高，但效率十分的高
- Memory 引擎通常用来存放临时表
- Memory 引擎采用哈希索引，所以查询速度十分的快
- Memoey 引擎只支持表锁，并发性较低，但一般也不会采用 Memory 做一些高并发的工作，因为有更好的选择 (InnoDB)
- Memory 引擎中的变长字段 (varchar)会以定长字段 (char)的方式存储，会造成额外的内存浪费，这点十分不合理
### 总结
- 数据库由数据库实例来完成读写操作
- 用户应根据不同的需求选择合适的存储引擎
## InnoDB 存储引擎
### InnoDB 存储引擎概述
MySQL 5.5 开始默认的存储引擎就是 InnoDB, 是第一个支持完整 ACID 事物的 MySQL 存储引擎 
特点：支持行锁、支持 MVCC、支持外键、提供非一致性锁定读、索引结构为 B+树
如果想使用 MySQL 保证高并发，高性能，就用 InnoDB👍

### InnoDB 体系结构
![[Pasted image 20231117004616.png]]
<mark style="background: #ADCCFFA6;">后台线程用来刷新内存中的数据吗，同时将修改的数据文件刷新到磁盘上，保证数据的一致性</mark>
#### 后台线程
**Master Thread**
- 后台核心线程，主要将缓冲池中的数据刷新到磁盘中，保证数据的一致性
**IO Thread**
- 在 InnoDB 存储引擎中使用大量的 AIO 来处理 IO 请求，这样可以极大提高数据库的性能，IO Thread 就是负责这些 IO 请求的回调
**Purge Thread**
- 事务提交后，undo log 不再需要，可以通过 Purge Thread 回收分配的 undo log 空间
**Page Cleaner Thread**
- 脏页的刷新由该进程异步完成

#### 内存池
数据是存放在磁盘上的，通过 CPU 访问磁盘获取数据是在浪费性能，因此引入缓冲池，缓冲池就是一块内存，通过内存与 CPU 的交互将大大提升数据库的性能
数据库进行读取时，会先判断缓冲池中是否存在相同页，如果有就返回，没有则继续访问磁盘，每次访问磁盘得到的页都将存入缓冲池中
数据库在进行写时，首先修改缓冲池中的页，然后再刷新回磁盘

> [!tip]- LRU List
> 通常来说数据库的缓冲池是通过 LRU 算法来管理的，可以把它想成一个链表，经常使用的页放在链表的前面，最少使用的页放在后面，当缓冲池满时优先处理掉链表尾部的页
> 但在 InnoDB 存储引擎中做了一些优化，在 LRU 列表中加入了一个标记 midpoint (默认为列表的 5/8 处)位置，midpoint 之前的为 new 列表，之后的为 old 列表

脏页：缓冲池上的页和内存中的页数据产生了不一致
Flush 列表存储脏页，执行后台线程将 flush 列表中脏页异步刷新到磁盘
<mark style="background: #ABF7F7A6;">注意：LRU 列表中也会有脏页，当 LRU 中的脏页达到一定比例时，会触发 checkppoint 机制将脏页刷新到磁盘</mark>



