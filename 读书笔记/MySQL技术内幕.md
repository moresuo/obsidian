***
## MySQL 体系结构和存储引擎
### 定义数据和实例
**数据库**：数据库文件的集合，保存数据的容器
**数据库实例**：系统上的一个进程，一个程序
<mark style="background: #ABF7F7A6;">数据库是数据文件的集合，想对这些文件进行增删改查，需要通过数据库实例来操作</mark>
数据库实例启动时，回去读取配置文件，获取启动的参数，如果没有配置文件，就按默认的启动参数启动
在 linux 下 MySQL 的配置文件默认在/etc/my.cnf 下，可以修改这个配置文件
<mark style="background: #FFF3A3A6;">问题：如果多个配置文件有相同配置参数，那么以哪个配置文件的参数为准</mark>
- 以读取到的最后一个配置文件的参数为准
### MySQL 体系结构
![[Pasted image 20231115225138.png]]
**存储引擎是基于表的，而不是数据库**
### MySQL 的存储引擎
<mark style="background: #ABF7F7A6;">存储引擎的好处就是，能够根据不同的需求建立不同的存储引擎表</mark>
#### InnoDB 存储引擎
- InnoDB 通过使用多版本并发控制 (MVCC)具有高并发的特性，同时也支持事务机制，实现了 SQL 的四种隔离级别，默认的隔离级别是 RR (可重复读)
- InnoDB 还提供了插入缓冲、二次写、自适应哈希、预读等高性能，高可用的功能
- InnoDB 必须存在主键，如果没有主键或非空唯一索引，那么就会自动生成一个 6 字节的主键 (用户不可见)
- InnoDB 的表都存放在一个 idb 文件中
#### MyISAM 存储引擎
- MyISAM 不支持事务机制，也不支持行锁
- MyISAM 支持全文索引
- MyISAM 的缓冲池只缓存索引文件，而不缓存数据文件
- MyISAM 的表存储在两个文件中，一个单独存放索引文件，一个单独存放数据文件
#### NDB 存储引擎
- NDB 存储引擎就是一个集群存储引擎，也没有怎么用过，不多加赘述
#### Memory 存储引擎
- Memory 引擎存储的数据都在内存上，如果数据库突然宕机，那么数据都会消失，所以 Memory 引擎安全性不高，但效率十分的高
- Memory 引擎通常用来存放临时表
- Memory 引擎采用哈希索引，所以查询速度十分的快
- Memoey 引擎只支持表锁，并发性较低，但一般也不会采用 Memory 做一些高并发的工作，因为有更好的选择 (InnoDB)
- Memory 引擎中的变长字段 (varchar)会以定长字段 (char)的方式存储，会造成额外的内存浪费，这点十分不合理
### 总结
- 数据库由数据库实例来完成读写操作
- 用户应根据不同的需求选择合适的存储引擎
## InnoDB 存储引擎
### InnoDB 存储引擎概述
MySQL 5.5 开始默认的存储引擎就是 InnoDB, 是第一个支持完整 ACID 事物的 MySQL 存储引擎 
特点：支持行锁、支持 MVCC、支持外键、提供非一致性锁定读、索引结构为 B+树
如果想使用 MySQL 保证高并发，高性能，就用 InnoDB👍

### InnoDB 体系结构
![[Pasted image 20231117004616.png]]
<mark style="background: #ADCCFFA6;">后台线程用来刷新内存中的数据吗，同时将修改的数据文件刷新到磁盘上，保证数据的一致性</mark>
#### 后台线程
**Master Thread**
- 后台核心线程，主要将缓冲池中的数据刷新到磁盘中，保证数据的一致性
**IO Thread**
- 在 InnoDB 存储引擎中使用大量的 AIO 来处理 IO 请求，这样可以极大提高数据库的性能，IO Thread 就是负责这些 IO 请求的回调
**Purge Thread**
- 事务提交后，undo log 不再需要，可以通过 Purge Thread 回收分配的 undo log 空间
**Page Cleaner Thread**
- 脏页的刷新由该进程异步完成

#### 内存池
数据是存放在磁盘上的，通过 CPU 访问磁盘获取数据是在浪费性能，因此引入缓冲池，缓冲池就是一块内存，通过内存与 CPU 的交互将大大提升数据库的性能
数据库进行读取时，会先判断缓冲池中是否存在相同页，如果有就返回，没有则继续访问磁盘，每次访问磁盘得到的页都将存入缓冲池中
数据库在进行写时，首先修改缓冲池中的页，然后再刷新回磁盘

> [!tip]- LRU List
> 通常来说数据库的缓冲池是通过 LRU 算法来管理的，可以把它想成一个链表，经常使用的页放在链表的前面，最少使用的页放在后面，当缓冲池满时优先处理掉链表尾部的页
> 但在 InnoDB 存储引擎中做了一些优化，在 LRU 列表中加入了一个标记 midpoint (默认为列表的 5/8 处)位置，midpoint 之前的为 new 列表，之后的为 old 列表

脏页：缓冲池上的页和内存中的页数据产生了不一致
Flush 列表存储脏页，执行后台线程将 flush 列表中脏页异步刷新到磁盘
<mark style="background: #ABF7F7A6;">注意：LRU 列表中也会有脏页，当 LRU 中的脏页达到一定比例时，会触发 checkppoint 机制将脏页刷新到磁盘</mark>
InnoDB 存储引擎的内存区域除了有缓冲池外，还有 redo log 缓冲，redo log 只记录事务日志，用来恢复数据，保障持久性
### Checkpoint 技术
Checkpoint 解决的问题：
- 缩短数据库恢复时间
- 缓冲池不够用时，将脏页刷新到磁盘
- 重做日志不可用时，刷新脏页
当数据库突然发生了宕机，不需要将 redo log 所有日志都刷新一遍，只需要将 chectpoint 标记之后的刷新到磁盘就行了，<mark style="background: #ABF7F7A6;">所以 checkpoint 是已刷新页的标记</mark>
在 InnoDB 引擎中有两种执行 checkpoint 的方式：
- Sharp Checkpoint: 数据库关闭时，将所有脏页刷新到磁盘
- Fuzzy Checkpoint: 每次只刷新一部分脏页，而不是刷新所有脏页回磁盘
### InnoDB 关键特性
#### 插入缓冲
对于非聚集索引的插入或更新操作，不是每一次都直接插入到索引页中，而是先判断插入的索引页是否在缓冲池中，若在，则直接插入，若不在，就先放入一个 Insert Buffer 中，<mark style="background: #ABF7F7A6;">欺骗数据库已经将索引插入到叶子结点 (其实还没有)</mark>
<mark style="background: #FFB86CA6;">那 Insert Buffer 有什么作用？</mark>
简而言之就是将多个插入操作进行合并，同时操作一个索引页，大大提高了插入的效率
<mark style="background: #FFB86CA6;">使用 Insert Buffer 有什么条件？</mark>
- 索引是辅助索引
- 索引不是唯一的
#### 两次写
如果说 Insert Buffer 给 InnoDB 带来了性能上的提升，那么 DoubleWrite 就给 InnoDB 带来了数据页的可靠性
<mark style="background: #FFB86CA6;">Double Write 有什么作用？</mark>
<mark style="background: #ABF7F7A6;">因为存储引擎缓冲池内的数据页大小默认为16KB，而文件系统一页大小为4KB</mark>，所以在进行刷盘操作时，就有可能发生如下场景：
![[Pasted image 20231118123550.png]]
如图所示，数据库准备刷新脏页时，需要四次 IO 才能将16KB 的数据页刷入磁盘。
但当执行完第二次IO时，数据库发生意外宕机，导致此时才刷了2个文件系统里的页，这种情况被称为写失效（partial page write）。
此时重启后，磁盘上就是不完整的数据页，就算使用 redo log 也是无法进行恢复的。所以 InnoDB 就提出了 Double Wirte 的特性来保障数据完整性
<mark style="background: #ABF7F7A6;">其实就是在重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是 double write。</mark>
![[Pasted image 20231118124449.png]]
如图，如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB 存储引擎可以从共享表空间中的 Double write 中找到该页的一个副本，将其复制到表空间文件，再应用重做日志。
#### 自适应哈希
哈希是一种非常快的查找算法，一般情况下查找的时间复杂度为 O (1), B+树的查找取决于树的高度 
<mark style="background: #D2B3FFA6;">InnoDB 存储引擎会监控对表上各个索引页的查询，如果观察到可以通过哈希索引来提高速度，则建立哈希索引，称之为自适应哈希索引，这个过程是由 InnoDB 引擎完成的，用户不能自己创建哈希索引
</mark>
#### 异步 IO
为提高数据库磁盘操作性能，采用异步 IO 的方式进行磁盘交互
<mark style="background: #D2B3FFA6;">与异步 IO 对应的是同步 IO, 当用户发出一条索引扫描的 SQL, 那可能就需要扫描多个页，只有扫描完前面一个才能扫描后面一个页，这是没有必要的，可以多个线程同时对不同的页进行扫描，实现异步 IO</mark>
#### 刷新邻接页
<mark style="background: #D2B3FFA6;">当刷新一个脏页时，InnoDB 存储引擎会检测该页所在区的所有页，如果存在脏页，那么就一并刷新</mark>





