***
## 1、说说内连接，外连接😀
> - 内连接就是几张表的匹配结果的交集作为结果集
> - 外连接会保存驱动表的所有记录作为结果集，没有匹配的以null值存储

## 2、说说三大范式😀
> - 第一范式：表中的每一个字段都不可以再拆分
> - 第二范式：在第一范式的基础上，非主键字段要完全依赖与主键字段，不能部分依赖于主键
> - 第三范式：在第二范式的基础上，非主键字段只能依赖于主键，不能依赖于其他非主键字段
> 
三大范式是为了控制数据库的冗余，节省空间，但是在实际设计时，我们可以通过一些冗余的字段，避免进行分表分库操作，利用空间换时间

## 3、 varchar和char的区别😇
> - char表示定长的字符串，长度是固定的，varchar是变长的字符串
> - 因此char类型的字段在存取时要快于varchar类型的字段，但是会有额外的空间浪费
> 
对于长度固定的字段尽量用char类型，对于长度不确定的字段尽量用varchar

## 4、blob和text有什么区别😃
> - blob用于存储二进制数据，text一般用于存储字符串数据
> - blob没有字符集，text有字符集，可以根据字符集的校对规则进行排序和比较

## 5、DATETIME和TIMESTAMP有什么区别😍
> - 时间范围：datetime时间表示范围更大
> - 存储空间：datetime存储空间8个字节，timestamp存储空间4个字节
> - 时区的依赖关系：datetime存储时间与时区无关，timestamp存储时间与时区有关
> - 默认值：datetime默认值为null,timestamp默认值为当前时间

## 6、in和exixts的区别😄
> 当我们使用in语句进行子查询时，其实就是将外表和内表做hash连接，当使用exists做子查询时，就会对外表做loop循环，每次loop循环都会对内表进行查询
> - 如果两个表数据量差不多的话，用谁都无所谓
> - 如果子表较大就用exists,子表较小就用in
> - not in无论表的大小都是全表扫描，not exists子查询会用到索引，所以都推荐not exists

## 7、MySQL怎么存储表情😁
> MySQL中的utf-8编码是阉割版，最多存储3个字节，可以把字符集设置为utf-8mb4，最多存储4个字节

## 8、drop、delete和truncate的区别😆
> - drop就是删除整张表的数据以及表结构
> - truncate会删除整张表的数据但是保留表的结构
> - delete就是删除制定的记录

## 9、UNION和UNION ALL的区别😀
> - union all不会合并重复的记录行
> - union 效率高于union all

## 10、count(*)、count(1)和count(列名)的区别😃
> - count(*)包括了所有的列，相当于统计表的行数，不会忽略null值
> - count(1)包括了忽略所有列，用1代表代码行，不会忽略null值
> - count(列名)只统计列名的那一列，在统计结果、时会忽略null值
> 
执行速度：count(主键)>count(1)>count(列名)

## 11、说说MySQL的基础架构😅
> MySQL的基础架构主要分为3层，从上到下依次是客户端层，server层，存储引擎层
> 客户端层主要的功能就是连接处理，授权认证，保证安全等功能
> MySQL的核心服务功能都在server层，包括解析,分析sql,优化sql,查询缓存等功能，所有跨存储引擎的功能都在这一层实现，比如触发器，视图等功能
> 存储引擎层主要负责MySQL的数据存储和提取，server层通过api与存储引擎层进行通信

## 12、一条sql查询语句在MySQL中如何执行的😙
> - 先判断这条sql语句是否具有权限，如果有权限的话再去查询缓存
> - 如果没有缓存的话，就会进行sql语句进行语法分析，判断语法是否出错
> - 语法解析完之后，会对sql语句进行优化，MySQL选择执行方案，调用存储引擎的接口，返回执行结果

## 13、MySQL有哪些常见的存储引擎😁
> InnoDB:大多数情况下使用InnoDB存储引擎就够了，InnoDB存储引擎支持事务机制，保障业务的安全性
> MyISAM:数据表主要用来插入和查询记录的话，MyISAM提供了较高的处理效率
> MEMORY:主要用来存储临时数据和安全性要求不高的数据，因为MEMORY存储的数据保存在内存上，不能够持久化

## 14、InnoDB和MyISAM有什么区别😴
> - 存储结构，MyISAM在磁盘上存储了3个文件，InnoDB的表都保存在一个文件中
> - MyISAM不支持事务机制，InnoDB支持事务机制
> - MyISAM只支持表锁，更新时会锁住整张表，导致其他查询或更新都会被阻塞
> - MyISAM的索引是聚簇索引，没有二级索引，索引结构是B树，InnoDB的索引是非聚簇索引，索引结构是B+树
> - MyISAM可以存在没有主键的情况，InnoDB如果没有主键或非空唯一索引，则会自动生成一个用户不可见的主键
> - MyISAM保存了表的行数，当使用count(*)查询表的行数时，会直接取出保存的值，InnoDB查询表的行数就回去遍历整张表
> - MyISAM不支持外键，InnoDB支持外键

## 15、MySQL的日志文件有哪些，分别介绍一下作用😁
> error log:错误日志文件能够帮助我们快速定位出现错误的位置
> 慢查询日志：慢查询日志是用来记录查询时间超过阈值的sql语句，通过慢查询语句我们可以快速知道哪些查询语句花费的时间较长，以便于我们进行sql优化
> 一般查询日志：一般查询日志用来记录所有对MySQL数据库请求的信息，无论是否正确执行
> 二进制日志：二进制日志记录了数据库所有执行的DDL语句和DML语句，将他们保存在二进制文件中
> 重做日志：重做日志是用来存储关于事务的日志
> 回滚日志：顾名思义回滚日志是用来进行回滚操作的，当一个事务想要进行回滚时，就利用回滚日志中的信息进行回滚

## 16、bin log和redo log有什么区别😆
> - bin log它存储日志的范围更广，他可以存储各种存储引擎下的信息，redo log只能存储InnoDB下关于事务的信息
> - bin log 记录的是一个事物的具体操作，redo log记录的是每个页更改的物理情况
> - bin log只在事务提交前提交，提交以追加的方式进行写入，redo log在事务执行过程中就会不断地进行更新，写入的记录会将以前的记录覆盖

## 17、说说一条更新语句的执行过程😴
> - 执行器调用存储引擎接口，先去内存中查找满足更新条件的记录，如果内存未命中就去磁盘中查找读入到内存中，返回数据行
> - 返回的记录在server层进行更新操作，更新之后刷新到内存中，同时将更新操作记录到redo log中，此时redo log处于prepare状态，可以随时提交事务，在事务提交前把执行的操作写入到bin log持久化到磁盘中，事务提交后redo log的状态改为commit

## 18、为什么要两阶段提交😆
> 如果采用单阶段提交方式的话，在redo log写入之后发生了宕机的话，bin log就没有记录对应的日志，当使用bin log进行数据恢复时就缺失了更新语句，**导致原先数据库的状态与被恢复后的数据库状态不一致**




## 19、redo log 怎么刷入磁盘
>Redo log 不是直接刷入到磁盘，而是先刷入内存中的 redo log 日志缓冲区，由 redo log 日志缓冲区刷入到磁盘中
>- 当缓冲区空间日志容量超过总容量的一半时，会把缓冲区的日志信息刷入到磁盘中
>- 事务提交时，会把缓冲区所有日志信息刷入到磁盘中 
>- 后台线程异步刷新缓冲区信息到磁盘中
>- 正常关闭服务器会刷新缓冲区日志信息到磁盘中
>- **触发 chectpoint 规则**
## 20、chectpoint 规则
>当缓冲区存在的脏页达到了一个阈值，就会触发 chectpoint, 脏页就是缓存池上的页与磁盘上的页数据产生了不一致，checkpoint 机制就会把脏页刷新到磁盘上
## 21、慢 SQL 如何定位
>- 可以通过开启慢查询日志来定位查询时间较长的 SQL 语句
>- 也可以在业务的基建中加入对慢 SQL 的的监控
## 22、哪些方式优化慢 SQL
>- **避免不必要的列**: 不要写 select *这种格式，只需要查询需要的列
>- **在数据量比较大时，进行分页操作时避免直接 order by**: 他会将分页数据之前的所有数据遍历一遍，最后只截取一小部分数据作为分页数据
>	- 延迟关联：可以先将分页数据的主键提取出来，用主键进行关联匹配
>	- 书签方式：找到 limit 第一个参数的主键值，在根据主键过滤
>- **索引优化**：合理利用联合索引，可以避免回表操作，联合索引是一个二级索引，叶子结点只存放了索引列和主键值，如果查找非联合索引的字段就要根据主键到聚簇索引中再遍历一次 B+树
>- **避免使用不等号**：在查询过程中如果有不等号操作符的话，查询引擎就会放弃查询索引，而进行全文索引
>- **适当使用前缀索引**：有的字段占的空间较大，可以根据字段的特点设置前缀索引，如果对整个字段都做索引的话就会占用很多空间，从而导致查询效率也会减慢，但是前缀索引无法做 order by ,group by 操作
>- **避免与索引列做运算**：可能会导致索引失效，索引列要单独存在才不会失效
>- **尽量使用 join 代替子查询**：子查询是嵌套查询，会生成一张临时表，而临时表的创建与销毁会占用一定的系统资源和时间，使用 join 进行关联查询时尽量使用小表驱动大表，因为会先遍历一遍驱动表再去与被驱动表进行连接查询，这只对于外连接，内连接的话两张表都可以作为驱动表
>- **可以增加冗余字段**：增加冗余字段可以减少表的关联查询，用空间换时间
>- **排序的字段作为索引**：B+树的叶子结点也是根据索引字段排序的，如果是多个字段进行排序的话，要注意索引字段的顺序要与排序字段顺序一致，首先根据第一个索引字段排序，如果一个索引字段相等再根据第二字索引字段排序
## 23、解释一下执行计划 explain 各个字段的含义
![[Pasted image 20231115215123.png]]
>**id**: MySQL 会为每个 select 语句分配一个 id
>**select_type**: 查询的类型，比如关联查询，子查询，主键查询等等
>**table**: 表示正在访问哪个表
>**type**: 表示 MySQL 是如何查找记录的
>	- system: 当表只有一行的情况下，速度最快，不需要进行 IO
>	- const: 当按照主键或唯一索引进行查找时, 速度非常快
>**possible key**: 表示可能使用到的索引
>**key**: 表示实际使用的索引
>**ref**: 与索引列做等值匹配的值
>**rows**：MySQL 估计要查询的行数
>**Extra**: 额外信息，可以查看是否使用关联索引，查看是否生成临时表
## 24、简单说一下索引的分类
>主键索引：一张表只能有一个主键，不允许重复，也不能为空
>唯一索引：不允许重复，但可以为空
>普通索引：就是基本的索引类型，没有唯一性限制，也可以为空
>联合索引：多个字段作为一个索引，通常用于组合搜索，减少回表
## 25、创建索引应注意什么
>- 索引应该创建在频繁查询的字段上，不要什么字段都加索引，这会占用很多内存，反而查询效率变慢
>- 离散度低的字段不要创建索引，比如性别，只有男女就不用创建索引
>- 容量大的字段可以使用前缀索引，减少空间的开销，通过截取字段的前面一部分内容建立索引
>- 不建议使用无序的字段作为索引，可能会造成页分裂现象
## 26、索引哪些情况会失效
>- 查询条件包含 or 可能会失效
>- 模糊查询时可能会失效
>- 联合索引，查询时的条件没有满足最左匹配原则
>- 在查询时对索引列做运算
>- 查询时出现不等号
>- MySQL 的优化器认为全表扫描要比索引的速度更快，而不用索引

## 27、索引不适合那些场景😀
>- 数据量比较少的表不适合加索引
>- 更新比较频繁的字段不适合加索引
>- 离散度低的字段不适合加索引
## 28、索引是不是越多越好😀
>当然不是
>- 创建过多的索引会占用大量磁盘空间
>- 索引虽然会提高查询的效率，但是会降低更新的效率

## 29、MySQL 索引用的什么数据结构😀
>MySQL 默认的存储引擎是 InnoDB, 索引采用的数据结构是 B+树
>- B+树只有叶子结点才会存放数据，非叶子节点存放索引值
>- - B+树的叶子结点是一个双向链表，并且根据默认根据索引字段的值升序排序
## 30、为什么要用 B+树，而不是普通二叉树😀
>- 普通二叉树存在退化的现象，它的最坏情况可能退化成一个链表，那么查询时就相当于全表扫描了
## 31、那为什么不用平衡二叉树呢😀
>- 首先 B+树在相同高度下存储的数据量更大
>- 其次就是 B+树的高度不算很高，那么访问磁盘的次数也会下降，查询效率更快

## 32、那为什么不用 B 树呢😀
>B+树相对于 B 树而言，B 树能解决的问题，B+树都能解决
>当我们进行全表扫描时，我们只需要遍历 B+树的叶子结点就行了，不需要遍历整颗 B+树
>因为 B+树的非叶子节点不存储数据，那么就可存储更多索引信息, 可以降低树的高度，减少 IO 次数
>因为叶子结点是根据索引字段值进行排序的，所以使用 B+树比 B 树的排序能力更强
>B+树永远是在叶子结点获取数据，IO 次数是稳定的，因此使用 B+树查询效率更稳定一些

## 33、Hash 索引和 B+树索引的区别是什么😀
>- B+树索引可以进行范围查询，Hash 索引只能进行等值查询
>- B+树支持联合索引的最左匹配原则，Hash 索引不支持
>- B+树支持 order by 排序，Hash 索引不支持
>- Hash 索引在等值查询上的效率要比 B+树快

## 34、聚簇索引和非聚簇索引的区别😀
>- 聚簇索引索引信息和数据存储在一颗树上，非聚簇索引索引数据和表数据分别存储在不同的树上，比如 InnoDB 就是聚簇索引，MyISAM 就是非聚簇索引
>- 一个表只能有只能拥有一个聚簇索引，而非聚簇索引一个表可以有多个
>- 聚簇索引物理存储按照索引排序，非聚簇索引物理存储不按照索引排序

## 35、回表了解吗😀
>在 InnoDB 存储引擎中，利用非主键索引对 B+树进行查询主键，根据查询到的主键值作为索引再到主键索引查询完整的数据，比基于主键索引的查询多扫描了一颗 B+树

## 36、覆盖索引了解吗😀
>覆盖索引就是我们查询的字段刚好是索引字段，或者包含于索引字段，那么通过扫描非主键索引得出的值恰恰是我们需要的值，这时候就不用进行回表操作了


