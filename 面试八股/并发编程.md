***
<a name="luYXT"></a>
## 1.并发与并行有什么区别😀
> - 并行就是同一时刻可以有多个线程在执行
> - 并发就是同一时刻只有一个线程在执行，并发的实现依赖于CPU的快速切换线程，对于用户来说是没有感知的

<a name="yP2a0"></a>
## 2.什么是进程什么是线程😀
> - 进程是代码在数据集合上的一次运行活动，是系统资源分配的基本单位
> - 线程是进程的一个执行路径，一个进程可以包含多个线程，线程共享进程中的资源(堆区和方法区)

<a name="EGUdo"></a>
## 3.线程创建有哪几种方式😄
> - 继承Thread类，重写run方法，通过调用start方法来启动一个线程
> - 实现Runnable接口，重写run()方法
> - 实现Callable接口，重写call()方法，通过FutureTask来执行异步任务并返回结果

<a name="XRSWv"></a>
## 4.既然调用start方法会会执行run方法，那为何不直接调用run方法😅
> 直接调用run方法并不会开启一个线程，还是在原来的线程中执行run方法
> 调用start方法会先创建一个线程，用创建后的线程去执行run方法，这样才起到多线程的效果

<a name="yeS8G"></a>
## 5.线程有哪些常用的调度方法😀
> - wait方法，当一个线程调用共享变量的wait方法时，该线程会进入等待状态
> - notify和notifyAll方法：notify是唤醒在当前共享变量上等待的一个线程，notifyAll是唤醒所有在共享变量上等待的线程
> - join方法：是Thread类的一个方法，只有等调用join方法的线程执行完毕后当前线程才能往下执行
> - sleep方法：也是Thread类的一个静态方法，会让当前线程睡眠指定时间，放弃对cpu的占用，但不会释放锁
> - yield方法：Thread类的静态方法，就是请求当前线程让出cpu的执行权，交给优先级更高的线程执行，但是线程调度器可以忽略这个请求
> - interrupt方法：中断线程，当线程在执行时，其他线程可以调用interrupt方法来中断当前线程，但线程实际并没有被中断，只是将线程中断标志设置为true

<a name="QF3pO"></a>
## 6.线程有哪几种状态😁
> 在java中线程共有6中状态
> - 初始状态，线程被创建，还没有调用start方法
> - 运行状态，将操作系统中的就绪状态和运行状态统称为运行状态
> - 阻塞状态，等待锁而进入阻塞
> - 等待状态，调用了wait和join等方法进入阻塞状态
> - 超时等待状态，该状态在等待状态的基础上加上了时间限制
> - 终止状态，线程执行完毕

<a name="I2mgE"></a>
## 7.什么是线程上下文切换😅
> 当一个CPU应付多个线程时，会采用时间片轮转机制给每个线程分配相应的时间片，当一个线程的时间片执行完之后会进入就绪状态，让出cpu资源给其他线程执行，这个过程对于用户来说是没有感知的

<a name="uwcUO"></a>
## 8.什么是守护线程😏
> java中线程分为用户线程和守护线程，守护线程会随着绑定的用户线程停止而停止，比如mian函数所在的线程就是一个用户线程，垃圾回收线程就是守护线程

<a name="vFTKC"></a>
## 9.线程间的通信方式😅
> - volatile和synchornized:volatile可以用来修饰变量，对修饰变量的读是从共享内存读，对变量的写也要同步到共享内存中，保证其他线程访问的可见性。synchornized作用于方法和代码块上，保证在多线程情况下只有一个线程可以执行方法和代码块，它保证了对变量访问的可见性和排他性
> - 等待通知机制：使用wait/notify进行线程间的通信
> - 管道输入/输出流：用于线程间的数据传输，PipedOutputStream,PipedInputStream
> - ThreadLocal:用于保存一个线程本地变量，他是线程隔离的，存储的格式是键值对，通过set方法设置值，get方法获取值

<a name="IDzWP"></a>
## 10.在项目中ThreadLocal的使用场景😄
> - 可以用在用户登录之后将用户信息存储在Threadlocal中，这样可以保证我们在任何地方都可取出用户信息
> - 数据库连接池的连接也可以用ThreadLocal来保存，保证在同一个线程下操作的是同一个连接

<a name="viZTG"></a>
## 11.ThreadLocal的原理🙂
> - 每个Thread类中都有一个ThreadLocalMap的实例变量
> - ThreadLocalMap维护一个键值对，key值是ThreadLocal的引用，value值是ThreadLocal的泛型值
> - 所以每个线程往ThreadLocal存储数据其实都是往ThreadLocalMap存储数据，读取也是将自身ThreadLocal引用作为key去map集合去寻找对应的value值，ThreadLocal本身并不存储值，只是将自身的引用作为key让线程往ThreadLocalMap存取值

<a name="yjNr3"></a>
## 12.ThreadLocal引发内存泄漏问题😅
> ThreadLocalMap中的key是ThreadLocal的弱引用，因为弱引用很容易被回收，所以ThreadLocal被回收后，但ThreadLocalMap还存在，就会导致ThreadLocalMap的key值已经不存在，value值还存在的情况，就会造成内存泄漏

<a name="RcP9A"></a>
## 13.如何解决ThreadLocal引发的内存泄漏问题😁
> 在使用完ThreadLocal后及时调用remove()方法释放内存

<a name="Y3vaL"></a>
## 14.ThreadLocalMap的结构😅
> 虽然ThreadLocalMap中带有map，但是并没有实现map接口，结构和hashMap类似，底层都维护这一个entry数组，通过哈希算法快速找到对应的数组下标（ThreadLocal的哈希值与数组长度进行取余）

<a name="ymAXu"></a>
## 15.ThreadLocalMap如何解决哈希冲突😏
> ThreadLocalMap没有使用链表结构也就不会像hashMap一样采用链地址法，而是采用开放地址法，如果当前位置发生了冲突就往数组后遍历，直到找到不发生冲突位置，然后放入

<a name="EzCtn"></a>
## 16.父子线程怎么共享数据😄
> 父子线程不能使用ThreadLocal来传递数据，但可以用另外的一个InheritableThreadLocal来实现父子线程共享数据，在线程初始化的时候，会检查父线程的InheritableThreadLocal是否存在值，如果存在就将值传给子线程

<a name="c3bHi"></a>
## 17.对java内存模型的理解😅
> JMM是一个抽象模型，并不真实存在，共享变量保存在主内存中，每个线程都有自己的本地内存，用于保存共享变量的副本，线程对一个普通共享变量的读写操作都是先从本地内存的副本中取出，相当于一个缓存

<a name="KHA1i"></a>
## 18.解释一下原子性、可见性、有序性😄
> - 原子性：指一个操作不会被分割，中断，要么全部执行，要么全部不执行
> - 可见性：一个线程对共享变量的操作对于其他线程能够感知到
> - 有序性：对于一个线程的执行代码，从前往后依次执行，单线程下可认为程序是有序地，并发时可能会发生指令重排

<a name="Ksh22"></a>
## 19.什么是指令重排😅
> 在不改变单线程程序结果的前提下，编译器和处理器为提高执行效率可以重新安排语句的执行顺序，也就是上下程序不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序

<a name="M7586"></a>
## 20.happens-before的定义😏
> 如果一个操作happens-before另一个操作，那么前一个操作的执行结果将对后一个操作可见
> 如果重排序之后的结果和按照happens-before规则执行的结果一致，那么这种重排序也是允许的

<a name="YGlOO"></a>
## 21.happens-before的规则有哪些😁
> - 程序顺序规则：对于线程中的每个操作happens-before于该线程后续任意操作
> - 监视器锁规则：对于一个锁的解锁happens-before之后对于该锁的加锁
> - volatile变量规则：对于一个volatile修饰变量的写happens-before对于该变量的读
> - 传递性规则：如果A happens-before B,B happens-before C,那么A happens-before C
> - start规则：如果在一个线程中启动另一个线程，那么该线程的start操作happens-before另一个线程的所有操作
> - join规则：如果在线程A中执行线程B的join方法，那么线程B的所有操作happens-before线程A得到join的返回结果

<a name="LWbrs"></a>
## 22.volatile怎么保证可见性😅
> volatile相较于synchornized以加锁的方式来解决共享变量的可见性问题，volatile是更轻量的选择
> 当对一个volatile修饰的变量进行修改时，会把修改的值刷新回主内存，当其他线程读取一个volatile修饰的变量时，也会从主内存中进行读取，保证每次获取的都是最新值

<a name="ieqUL"></a>
## 23.volatile怎么保证有序性😅
> 对于一个volatile变量的读写操作，编译器会生成对应的读写屏障，防止volatile变量的操作与其他指令发生重排序

<a name="Ub0I0"></a>
## 24.synchornized的用法😏
> - 修饰实例方法：相当于给当前实例对象加锁，进入方法前必须获取对象锁
> - 修饰静态方法：相当于给当前类加锁，当前类的所有实例对象只有一个能获取锁
> - 修饰代码块：给指定对象加锁

<a name="Ltsqc"></a>
## 25.synchornized的实现原理🤔
> synchornized实现代码块同步采用的monitorenter和monitorexit指令，monitorenter指向同步代码块开始的地方，monitorexit指向同步代码块结束的位置，这两个指令都是基于内部锁monitor实现的，对象的对象头里存放着monitor的指针，monitor里有两个队列，waitset和entryset,分别存放等待和阻塞的线程，当一个线程获得monitor时，会将monitor的owner设置为当前线程，计数器加一，如果线程调用wait方法，就会释放monitor，计数器减一，owner设置为空，当前线程进入waitset队列，等待被唤醒，如果当前线程执行完毕也会进入waitset,释放锁

<a name="tnlsu"></a>
## 26.synchornized怎样实现可见性😅
> - 线程加锁前，清空本地内存中所有共享变量的值，保证每次使用时都会从主内存中获取
> - 线程加锁后，保证其他线程不能访问主内存中的共享变量
> - 线程解锁前，将所有对共享变量的修改刷新到主内存

<a name="SSTM0"></a>
## 27.synchornized怎么保证有序性😅
> synchornized的同步代码块具有排他性，同一时刻只能有一个线程获取锁并执行，保证代码是单线程运行的，因此多线程执行synchornized同步代码块时是有序地

<a name="LZ1nf"></a>
## 28.synchornized怎么实现可重入的😅
> synchonized是一个可重入锁，一个线程在获得对象锁的前提下允许再次获取同一个锁，因为在synchornized的内部锁monitor中包含一个计数器，同一个线程获取锁之后计数器加一，释放锁之后计数器减一，直到计数器为0时释放锁

<a name="bPM5v"></a>
## 29.synchornized的优化🤔
> java对象头markwork中存放着关于锁的信息，对象头的信息会随着锁的状态变化而变化
> 偏向锁：在没有竞争的情况下，Mark Word存放着当前线程的id,该线程进出同步代码块不需要cas操作来进行加锁和解锁
> 轻量级锁：在没有多线程竞争的情况时，相对于重量级锁减少操作系统互斥量带来的性能消耗
> 自旋锁：减少不必要的CPU上下文切换，当轻量级锁升级为重量级锁时就用到了自旋锁
> 锁粗化：将多个连续的加锁，解锁操作连接在一起，扩展成一个范围更大的锁

<a name="V22B2"></a>
## 30.偏向锁的获取与撤销😄
> - 首先检查对象头的Mark Word是否存放了当前线程id,如果存放了话，就直接执行同步代码块，没有的就需要通过cas操作竞争锁，如果竞争成功就把Mark Word的线程id设置为当前线程，竞争失败就撤销偏向锁，升级为轻量级锁
> - 偏向锁不会主动释放锁，只有当其他线程来竞争时才会执行撤销操作，撤销之前需要知道获取锁的线程的状态，如果已经执行完同步代码块了，就撤销偏向锁，如果还未执行完，就将偏向锁升级为轻量级锁

<a name="Fv2gb"></a>
## 31.轻量级锁的获取🤔
> 线程在执行同步代码块之前，JVM会在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头的Mark Word复制到锁记录中，然后线程在尝试将对象头的Mark Wrod替换为锁记录的指针，更新成功表示获取轻量级锁，失败的就自旋获取锁，等待次数超过了阈值的话，锁就会膨胀为重量级锁

<a name="JymVL"></a>
## 32.synchornized和ReentrantLock的区别😇
> 锁的实现方式：synchornized是java的关键字，基于JVM实现，而ReentrantLock是基于JDK的api实现的
> 性能：在JDK1.6锁优化之前，synchornized性能比ReentrantLock差很多，但在JDK1.6之后性能差别就不大了
> 功能特点：ReentrantLock提供的功能比synchornized更多一些，比如ReentrantLock提供可以中断等待锁的线程的机制，也可以指定公平锁还是非公平锁，synchornized只能是非公平锁，synchornized结合wait/notify实现等待通知机制，ReentrantLock通过Condition的await/signal实现等待通知机制，ReentrantLock需要手动获取锁与释放锁，synchornized不用手动释放锁

<a name="J5hJK"></a>
## 33.AQS了解多少😥
> 同步器依赖内部的一个先进先出的双向队列来实现同步状态管理，当前线程获取同步状态失败，就会把当前线程及等待的信息构造成一个节点加入到同步队列的队尾中，考虑到可能有多个线程获取同步状态失败的情况，所以通过cas操作保证插入顺序的一致，当同步状态释放时，会唤醒队列首节点的后继节点，再次尝试获取同步状态
> 获取同步状态可以分为独占式和共享式，他们最主要的区别就是在同一时刻能否有多个线程同时获得同步状态，独占式获取了资源，其他线程会进入阻塞状态，共享式下线程获得资源，其他线程可以通过cas方式进行获取

<a name="waGsD"></a>
## 34.ReentrantLock实现原理😄
> ReentrantLock是一个可重入的独占式锁，只能有一个线程获取该锁，其他线程获取会被阻塞，它默认创建的是一个非公平锁
> 当调用lock方法时，尝试获取锁，如果没有其他线程占用，就把锁的拥有者设置为当前线程，并设置AQS状态值为1，如果之前获取过该锁，就直接把AQS的状态值加1
> 如果获取锁失败，就把线程放入同步队列

<a name="tHd4b"></a>
## 35.CAS了解多少😃
> - CAS就是CompareAndSwap,比较并交换，它是通过CPU的指令来保证操作的原子性
> - CAS指令包含3个参数，第一个参数是共享变量的地址，第二个参数是期望值，第三参数是更新之后的值
> - 在进行更新操作之前会将共享变量的值与期望值作对比，如果一致，就执行更新操作，不一致的话就返回

<a name="gA1jS"></a>
## 36.CAS的问题，如何解决😅
> - ABA问题，就是当前共享变量的值与期望值虽然相等，但是可能在判断之前有其他线程对共享变量做了修改，又修改回当前的值了
>    - 可以通过加版本号的方式解决，共享变量每做一次更新，版本号就加一，当进行cas判断时，还要判断版本号是否一致
> - 循环性能开销，就比如自旋cas操作获取锁，如果一直不成功，就会给CPU带来很大的开销
>    - 设置一个自旋次数阈值，当达到阈值时停止自旋
> - 只能保证一个变量的原子操作，如果对多个变量进行操作时，无法保证整体操作的原子性
>    - 可以将多个变量封装成一个对象，使用AtomicReference来保证原子性
>    - 或者加锁的方式保证原子性

<a name="O0ZpD"></a>
## 37.java中保证原子性的方法😗
> - 使用synchornized保证原子性
> - 使用juc包下的锁，例如ReentrantLock
> - 使用原子操作类，例如AtomicInteger

<a name="RNNcb"></a>
## 39.原子操作类了解多少😅
> 原子操作类分为：基本类型原子类，数组类型原子类，引用类型原子类，字段更新类型原子类
> 当我们想对一个变量做更新操作时，就不用通过加锁的方式来保证原子性，可以直接使用原子操作类保证操作的原子性

<a name="b7LMv"></a>
## 40.AtomicInteger的原理😄
> 简单来说就是根据CAS指令来保证操作的原子性

<a name="XbqjU"></a>
## 41.线程死锁了解吗，如何避免🐵
> 死锁是指两个或两个以上的线程因资源争夺而相互等待的情况，，在没有外力作用下，这些线程会一直阻塞
> 死锁产生的条件：
> - 互斥条件：一个资源只能有一个线程占用，只有当线程释放资源后，其他线程才能进行访问
> - 请求保持条件：一个线程已经至少拥有了一个资源，但又发出了新的资源请求，但新资源被其他线程占用，当前线程就会被阻塞，而且不会释放自已已拥有的资源，直到其他线程释放资源
> - 不可剥夺条件：一个线程在获取到资源后，不能被其他线程所抢占资源，直到自己释放资源
> - 环路等待条件：比如线程1等待线程2释放资源，线程2等待线程3释放资源，线程3又等待线程一释放资源，存在一个资源请求环形链
> 
如何避免死锁:至少破坏一个死锁发生的条件

<a name="i06yS"></a>
## 42.说说死锁问题的排查🐒
> 可以使用jdk自带的命令行工具：
> - jps查找运行的java进程
> - jstack查看线程堆栈信息
> 
也可以使用图形化界面工具JConsole,查看死锁信息

<a name="wWmMM"></a>
## 43.CountDownLatch了解吗🦍
> CountDownLatch类似于join方法，可以等待其他线程完成指定的操作，不一定要等带待其他线程执行完，CountDownLatch构造方法接受一个int类型的参数，当调用countDown方法时，值就会减一，直到减为0，调用await方法的线程就不在阻塞

<a name="XzSqa"></a>
## 44.CyclicBarrier了解吗🐶
> 就是让一组线程达到同步点时被阻塞，直到最后一个线程到达，所有在同步点被阻塞的线程才会继续运行，CyclicBarrier的构造方法接受一个int类型的参数，表示拦截线程的数量，线程调用await方法，表示被拦截

<a name="aLbc0"></a>
## 45.CyclicBarrier和CountDownLatch有什么区别🐕
> - CountDownLatch是一次性的，CyclicBarrier可以多次设置屏障，实现重复利用
> - CountDownLatch中各个子线程不可以等待其他线程，只能自己完成任务，而CyclicBarrier中的各个线程可以等待其他线程
> - CyclicBarrier面向的是线程数，CountDownLatch面向的是任务数

<a name="NaHtt"></a>
## 46.Exchanger了解吗🐩
> Exchanger用于线程间的数据交换，它提供一个同步点，当线程达到这个同步点时，就可以彼此交换数据，线程通过exchange方法交换数据，如果一个线程先执行exchange方法，他会等待另一线程也执行exchange方法，当两个线程都到达同步点时，就可以进行数据的交换

<a name="oZzL9"></a>
## 47.说说你对线程池的了解🐺
> 线程池其实就是管理线程的一个池子，可以帮助我们减少创建线程和销毁线程带来的开销，当任务来临时，我们我已直接去线程池获取一个线程来执行，不需要重新去创建一个线程，提高了响应速度，当线程执行完，可以放回线程池，等下个任务来临时又可以重新重线程池中取出来，实现了重复利用的效果

<a name="kcNk8"></a>
## 48.线程池的工作流程🦊
> - 当线程池刚创建时，里面没有一个线程，任务队列只是作为一个参数传进来
> - 当调用execute方法，线程会先判断当前运行的线程数是否小于核心线程数，如果小于的话就创建一个线程去执行任务，如果大于等于的话，就将这个任务放入任务队列中，如果队列满了的话，就会判断当前运行的线程数是否小于线程池的最大线程数，小于的话就创建非核心线程执行该任务，否则线程池根据对应的拒绝策略来处理任务
> - 当一个任务完成后，会从队列中取下一个任务来执行
> - 当一个非核心线程处于空闲状态时，超过一定的空闲存活时间就会被销毁掉

<a name="xYN7g"></a>
## 49.线程池的参数🐱
> - corePoolSize:指定核心线程数，当前运行的线程数小于核心线程数时，会创建核心线程来执行任务，当运行的线程数大于等于核心线程数时，才会将任务放入任务队列
> - maximumPoolSize：指定线程池的最大线程数，当任务队列满了，当前运行线程数小于线程池最大线程数时，就可以创建非核心线程来执行任务
> - keepAliveTime:非核心线程的空闲存活时间
> - unit：时间单位
> - workQueue：线程池的等待队列
> - threadFactory：创建线程的工厂，可以用来指定线程名
> - handler:当线程池运行的线程达到最大线程数，任务队列也满了，那么就会采取对应的饱和策略

<a name="gbzKI"></a>
## 50.线程池的拒绝策略🐈
> - 直接抛出异常，线程池的默认策略
> - 将任务交给调用线程来执行
> - 丢掉任务队列中最老的任务，将新任务加入任务队列
> - 直接丢弃当前任务

<a name="bC66T"></a>
## 51.说说线程池的任务队列🦁
> - ArrayBlockingQueue:是一个数组实现的有界阻塞队列
> - LinkedBlockingQueue:基于链表结构的阻塞队列，最大长度为整形的最大值
> - DelayQueue:延迟队列，任务定时周期执行，内部维护了一个优先队列，对时间排序
> - PriorityBlockingQueue：基于优先级的无界阻塞队列
> - SynchronousQueue：是⼀个不存储元素的阻塞队列，每个插⼊操作必须等到另⼀个线程调⽤移除操作，否则插⼊操作⼀直处于阻塞状态，吞吐量通常高于LinkedBlockingQuene，newCachedThreadPool线程池使⽤了这个队列

<a name="lC8Vf"></a>
## 52.线程池提交submit和execute有什么区别🐯
> - execute用于提交不需要返回值的任务
> - submit用于提交有返回值的任务，返回一个Future对象，通过调用Future的get方法阻塞等待获取返回值

<a name="m7nVt"></a>
## 53.线程池怎么关闭🐅
> 通过调用线程池的shutdown或shutdownNow方法关闭线程池，它的原理就是遍历线程池中的工作线程，调用每个线程的interrupt方法来中断线程、
> - shutdown方法将线程池的状态设置为shutdown，他会中断线程池中空闲线程，拒绝接收外部的任务，正在工作的线程和任务队列中的任务会执行完
> - shutdownNow方法会将线程池状态设置为stop,他也会拒绝接受外部任务，他与shutdown不同的是他会忽略任务队列中的任务，并且尝试将线程池中的所有线程中断，不管是否在运行，这样做的风险比较大

<a name="xbv05"></a>
## 54.说说常见的线程池🐆
> - newFixedThreadPool:创建固定线程数的线程池
>    - 核心线程数和最大线程数一致
>    - keepAliveTime为0
>    - 阻塞队列是LinkedBlockQueue
> - newCacheThreadPool:可缓存线程的线程池
>    - 核心线程数为0，最大线程数没有限制
>    - 阻塞队列是SynchronousQueue，不存储任务，一个任务来临时线程池直接创建
>    - 非核心线程存活时间为60秒
> - newSingleThreadPool:单线程的线程池
>    - 因为线程池中只有一个线程，所以核心线程数和最大线程数都为1，空闲生存时间为0
>    - 适用于串行执行任务，一个任务一个任务的执行
>    - 阻塞队列是LinkedBlockQueue无界阻塞队列，可能会造成OOM
> - newScheduledThreadPool:定时周期执行的线程池
>    - 阻塞队列DelayQueue封装了一个优先队列，对任务进行排序，时间小的排在前面
>    - 线程从DelayQueue中获取一个到期的ScheduledFutureTask任务，执行该任务，并将time变量修改为下次执行的时间，将ScheduledFutureTask放回任务队列

<a name="cDVWz"></a>
## 55.线程池的状态🐴
> RUNNING
> - 线程池可以接受新任务，也可以处理任务队列中的任务
> 
SHUTDOWN
> - 不会接受提交的新任务，但会处理任务队列中的任务
> 
STOP
> - 不会接受提交的新任务，也不会处理任务队列中的任务，会尝试中断正在运行的线程
> 
TIDYING
> - 表示所有任务已停止运行
> 
TERMINATED
> - 表示线程池已彻底终止

<a name="aOnxa"></a>
## 56.设计实现一个线程池😵
> 

<a name="AluJD"></a>
## 57.Fork/Join框架了解吗🤒
> Fork/Join框架就是把一个大的任务分割为多个晓得任务，最终汇总每个小任务的结果从而得到大任务的结果，主要采用了**分治算法**和**工作窃取算法**
> 将大的任务分割为多个小的任务就是采用了分治的思想，工作窃取就是每个小任务会放在一个双端队列中，单独创建线程来执行队列中的任务，当一个线程执行完了当前队列的任务，会去其他线程的任务队列的尾部窃取任务来执行，大大提高效率
> ForkJoinrTask与一般的Task的主要区别就是实现了compute方法，在这个方法中首先判断当前的任务是否足够的小，如果足够小的话就执行任务，还不够小的话就调用fork方法继续将任务进行分割，直到分割到最小任务返回一个结果，通过调用join方法阻塞获取子任务的结果

