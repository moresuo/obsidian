***
## 企业做项目流程
***
1. 需求分析：分析需求的合理性
2. 设计：概要设计，详细设计
3. 技术选型：做一个需求选用什么技术 (java, go, python……)
4. 初始化项目/引入需要的技术
5. 写 Demo, 测试用例
6. 写代码，实现业务逻辑
7. 测试 (单元测试 )
8. 代码提交
9. 部署、发布
## 需求分析
1. 登录注册
2. 用户管理 (管理员可见)，对用户的查询、修改
3. 用户校验（<mark style="background: #ABF7F7A6;">仅 VIP 用户可见</mark>）
## 技术选型
- 前端：前端三件套+React+组件库 Ant Design (别人帮我们写好的页面)+Umi (阿里巴巴开发框架)+Ant Design Pro (现成的管理系统)
- 后端：java+spring+springMVC+MyBatis+Mybatis-Plus+Springboot+MySQL
- 部署：服务器/容器 (平台)
## 计划
***
1. 初始化项目
	1. 前端初始化
		1. 初始化项目
		2. 引入组件
		3. 项目瘦身
	2. 后端初始化
		1. 环境准备 (MySQL, IDEA)
		2. 整合框架
2. 登录/注册
	1. 前端
	2. 后端
3. 用户管理
	1. 前端
	2. 后端
### 前端初始化
1. 下载 node. Js
2. Ant Design Pro, 官网：[开箱即用的中台前端/设计解决方案 - Ant Design Pro](https://pro.ant.design/zh-CN/)
初始化脚手架：
- 打开 cmd 命令窗口，推荐在做项目的文件夹下打开 cmd 窗口, 输入以下命令
```shell
# 使用 npm
npm i @ant-design/pro-cli -g
pro create myapp
```
![[Pasted image 20231130165243.png]]
- 出现问题：
![[Pasted image 20231130165847.png]]
把你的 VPN 关了😅。或者使用 yarn 的方式安装
- 使用 yarn 安装
```shell
yarn create umi myapp
```

![[Pasted image 20231130170626.png]]
![[Pasted image 20231130170720.png]]
![[Pasted image 20231130171135.png]]
- 安装 webStorm, 下载地址：[其他版本 - WebStorm (jetbrains.com)](https://www.jetbrains.com/webstorm/download/other.html)
- 破解教程：[Webstorm 2023.2.4 最新激活码,破解版安装教程（亲测有效） - 犬小哈教程 (quanxiaoha.com)](https://www.quanxiaoha.com/webstorm-pojie/webstorm-pojie-202324.html)
- 打开刚才创建的脚手架 myApp
- 进入终端，输入 yarn 自动安装相关依赖
![[Pasted image 20231130173404.png]]
- 点击 <mark style="background: #FF5582A6;">package. Json</mark>, 找到 start 标识。点击进行启动
![[Pasted image 20231130173928.png]]
- 添加 umi UI (可以帮助我们自动生成代码)
```shell
yarn add @umijs/preset-ui -D
```
### 后端初始化
- 安装 MySQL 数据库
- 在 IDEA 中新建一个 SpringBoot 项目
![[Pasted image 20231130191652.png]]
- 选择项目依赖
	- Spring Boot DevTools: 帮助我们在更改代码之后自动重启
	- Lombok: 通过注解的方式完成对一个 javaBean 的 set, get, toString 方法的省略编写
	- MySQL Driver: MySQL 的驱动
	- Spring Web: Spring  MVC 相关依赖，提供 web 访问接口，例如 Restful 代码的编写
	- MyBatis: 数据访问层的一个框架，对数据进行增删改查
![[Pasted image 20231130192420.png]]
- 在 IDEA 中连接 MySQL 数据库，其实就可以不用 navicat 了👍
![[Pasted image 20231130193010.png]]
![[Pasted image 20231130193102.png]]
- 引入 MyBatis-Plus 框架依赖, MyBatis 是对 JDBC 的封装，MyBatis -plus 是对 MyBatis 的封装，对一些常用的增删改查进行了封装，不用在编写 SQL👍
```xml
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.4.2</version>
</dependency>
```
- 将配置文件的 properties 改为 yml, yml 格式有提示且可读性更高，编写配置文件初始信息
```yaml
spring:  
  application:  
    name: user-center #项目名称  
  datasource: #数据库配置  
    driver-class-name: com.mysql.cj.jdbc.Driver  
    url: jdbc:mysql://localhost:3306/yupi?serverTimezone=UTC  
    username: root  
    password: 
server:  
  port: 8080 #项目端口号
```
- 在启动类上扫描 mapper 包的注解，`@MapperScan("com.yhk.usercenter.mapper")`

> [!warning]- 注意
> 测试类要与启动类的路径一致，如果不一致的话就要在测试类上的@SpringBootTest 注解中指定启动类，例如： `@SprintBootTest({"userCenterApplication"})`,或者在测试类上加上 `@RunWith(SpringRunner.class)`

### 数据库设计-后端
| id         | 主键                | varchar  |
| ---------- | ------------------- | -------- |
| username   | 昵称                | varchar  |
| gender     | 性别                | tinyint  |
| password   | 密码                | varchar  |
| phone      | 电话                | varchar  |
| email      | 邮箱                | varchar  |
| status    | 用户状态            | int  |
| avatarUrl  | 头像                | varchar  |
| createTime | 数据插入时间        | datetime |
| updateTime | 数据更新时间        | datatime |
| isDelete   | 是否删除 (逻辑删除) | tinyint  |
| account    | 登录账号            | varchar         |
<mark style="background: #ABF7F7A6;">后续开发可以继续添加字段，不要过度设计</mark>
性别不用加索引，因为性别离散度低，没必要加索引

- 在 IDEA 中设计一个表
![[Pasted image 20231202154256.png]]

> [!warning]- 注意
> Account 在 MySQL 5.7 为关键字，在建表时尽量不要用关键字，虽然可以用引号引起来，但是以防万一有一天忘了

<mark style="background: #ABF7F7A6;">在 MySQL 数据库中不支持两个相同的默认 current_time</mark>,推荐使用默认的 `CURRENT_TIMESTAMP`
![[Pasted image 20231202160446.png]]
```sql
create table user  
(  
    id          bigint auto_increment comment '主键'  
        primary key,  
    username    varchar(256)                       null comment '用户昵称',  
    userAccount varchar(256)                       null comment '账号',  
    avatarUrl   varchar(1024)                      null comment '用户头像',  
    gender      tinyint                            null comment '性别',  
    password    varchar(512)                       not null comment '密码',  
    phone       varchar(128)                       null comment '手机号码',  
    email       varchar(512)                       null comment '邮箱',  
    status      int      default 0                 not null comment '用户状态,0-正常',  
    createTime  datetime default CURRENT_TIMESTAMP null comment '创建时间,默认是当前时间',  
    updateTime  datetime default CURRENT_TIMESTAMP null comment '更新时间',  
    idDelete    tinyint  default 0                 not null comment '是否删除(逻辑删除),默认为0'  
)  
    comment '用户表';
```

### 登录注册-后端
1. 规整项目目录
	- Controller: 用户接受 web 请求
	- Service: 处理业务逻辑
	- Mapper: 数据库访问层，操作数据
	- Model: 存放实体类
	- Utils: 存放工具类
![[Pasted image 20231202162115.png]]
2. 实现基本数据库操作 (操作 user 表)
- 创建 user 对象，与 User 表进行字段映射，<mark style="background: #FF5582A6;">自动生成实体类</mark>，下载 MyBatisX 插件
![[Pasted image 20231202162650.png]]
- 右键点击表，选择 MyBatisX 功能项
![[Pasted image 20231202163416.png]]
![[Pasted image 20231202163517.png]]
- 在测试时，我们经常手动的调用一个对象的 set 方法完成对象的创建，比较麻烦，我们可以使用 `GenerateAllSetter` 插件一键生成
![[Pasted image 20231202164712.png]]
![[Pasted image 20231202165025.png]]
- <mark style="background: #ABF7F7A6;">MyBatis-Plus 自动会将驼峰转为下划线，如果数据表中的字段是驼峰命名的话那就会报错，所以在使用 MyBatis-Plus 时建议将表中的字段设置为下划线格式，或者在配置文件中将 MaBatis-Plus 的自动转换关闭</mark>
```yaml
mybatis-plus: #将MyBatis-Plus自动转换驼峰关闭  
  configuration:  
    map-underscore-to-camel-case: false
```
3. 写注册逻辑
- 用户在前端输入账户和密码以及校验码/手机验证码 (todo)
- 校验用户的账户、密码是否符合要求
	- 账户**不小于** 4 位
	- 密码**不小于** 8 位
	- 账户不能重复
	- 账户不包含特殊字符
	- 密码和校验密码相同
	- 其他校验
- 对密码进行加密，<mark style="background: #FF5582A6;">密码千万不能明文存储到数据库中</mark>
- 向数据库插入用户数据

> [!NOTE]- UserService-用户注册
```java
public interface UserService extends IService<User> {  
    /**  
     * 用户注册  
     * @param userAccount 用户账户  
     * @param userPassword 用户密码  
     * @param checkPassword 用户校验密码  
     * @return 用户id  
     */    long userRegister(String userAccount,String userPassword,String checkPassword);  
  
}
```

我们在进行用户注册校验时经常会用到非空判断，长度判断等校验，写出来的条件判断都比较冗余，我们可以引入 `apache commons util` 帮助我们进行字符串条件判断
```xml
<!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.12.0</version>
</dependency>
```

> [!NOTE]- UserServiceImpl-用户注册实现
```java
@Override  
public long userRegister(String userAccount, String userPassword, String checkPassword) {  
    //1. 校验  
    if(StringUtils.isAnyBlank(userAccount,userPassword,checkPassword)){//校验所含字符串是否为空，或者长度为0  
        return -1;  
    }  
    if(userAccount.length()<4){  
        return -1;  
    }  
    if(userPassword.length()<8||checkPassword.length()<8){  
        return -1;  
    }  
    //校验账户不能包含特殊字符  
    String regEx = "\\pP|\\pS|\\s+";  
    Matcher matcher = Pattern.compile(regEx).matcher(userAccount);  
    if(matcher.find()){//匹配到特殊字符  
        return -1;  
    }  
    if(!userPassword.equals(checkPassword)){  
        return -1;  
    }  
    //账户不能重复，查询数据库中有没有相同的账户,可以将查询数据库放到最后，如果前面的条件都满足的话，在进行查询数据库，因为查询数据库是最耗费时间的  
    long count = userMapper.selectCount(new QueryWrapper<User>().eq("userAccount", userAccount));  
    if(count>0){  
        return -1;  
    }  
    //2. 对密码进行加密  
    final String SALT="yhk";//加盐  
    String encryptPassword = DigestUtils.md5DigestAsHex((SALT + userPassword).getBytes());  
    // 3.插入数据  
    User user=new User();  
    user.setUserAccount(userAccount);  
    user.setPassword(encryptPassword);  
    boolean saveResult = this.save(user);  
    if(!saveResult){  
        return -1;  
    }  
    return user.getId();//id为Long类型，但是返回的是long类型，如果返回一个null的话将会报错  
}
```

> [!warning]- 注意
> - 字符串非空校验尽量使用 `StringUtils` 工具类
> - 包含特殊字符串的正则表达式 `"\\pP|\\pS|\\s+"`，使用 Matcher. Find () 判断字符串是否匹配
> - 对密码进行 md 5 加密要加盐，所谓加盐就是在进行加密的时候变得更复杂，可以使用 Spring 框架自带的加密工具 `DigestUtils.md5DigestAsHex()`
> - 在对前端信息进行校验时，尽量将操作数据库的操作放到最后，有时可以避免进行操作数据库，因为操作数据库是比较耗时的
> - 要注意返回类型是一个包装类，那么就有可能为空，为空就不能进行拆箱操作，就会报错，所以尽量对结果进行转换

4. 写登录逻辑
- 接收参数：用户账户, 密码
- 返回值：用户信息 (**脱敏**)
- 请求类型：POST 请求（请求参数很长时，不建议用 GET 请求）
- 请求体：json 格式

1. 校验用户账户和密码是否合法
	1. 账户不小于 4 位
	2. 密码不小于 8 位
	3. 非空
	4. 账户不包含特殊字符
2. 校验密码是否输入正确，和数据库中的密文密码进行比较
3. 记录用户登录态 (session)，存到服务器上 (SpringBoot 框架封装的 Tomcat 服务器)
4. 返回用户信息 (<mark style="background: #ABF7F7A6;">脱离用户敏感信息</mark>)

<mark style="background: #FFB86CA6;">如何知道哪个用户登录了？</mark>
- 连接服务器后，得到一个 session 状态，返回给前端
- 登陆成功后，得到登录成功的 session, 返回给前端一个设置 cookie 的命令
- 前端接收到后端的命令后，设置 cookie, 保存到浏览器内
- 前端再次请求相同服务器时，在请求头中携带 cookie 去请求
- 后端拿到前端传来的 cookie, 找到对应的 session
- 后端从 session 中可以取出基于该 session 存储的变量


> [!NOTE] UserService-用户登录
```java
/**  
 * 返回脱敏后的用户信息  
 * @param userAccount 用户账户  
 * @param userPassword 用户密码  
 * @return  
 */  
User doLogin (String userAccount, String userPassword, HttpServletRequest request);
```

> [!warning]- 逻辑删除
> 要在 MyBatis-Plus 中声明逻辑删除字段，所谓逻辑删除就是用户查询不到，但是数据保留在数据库中，比如在用户登录过程中根据账户进行查询信息，如果账户之前已经删除，标记为逻辑删除，那将查询失败

- 添加全局逻辑删除, 添加配置信息
```yaml
Mybatis-plus:
	Global-config:  
	  Db-config:  
	    logic-delete-field: flag #全局逻辑删除的实体字段名  
	    logic-delete-value: 1 #逻辑删除默认值  
	    logic-not-delete-value: 0 #逻辑未删除默认值
```
- 在 User 实体类的逻辑删除字段上加 `@TableLogic` 注解
```java
@TableLogic  
Private Integer idDelete;
```

> [!NOTE] UserServiceImpl-用户登录
```java
@Override  
Public User doLogin (String userAccount, String userPassword, HttpServletRequest request) {  
    //校验  
    If (StringUtils.IsAnyBlank (userAccount, userPassword)){  
        Return null;  
    }  
    If (userAccount.Length ()<4){  
        Return null;  
    }  
    If (userPassword.Length ()<8){  
        Return null;  
    }  
    //账户不能包含特殊字符  
    String regEx = "\\pP|\\pS|\\s+";  
    Matcher matcher = Pattern.Compile (regEx). Matcher (userAccount);  
    If (matcher.Find ()){  
        Return null;  
    }  
    //将登录的密码进行加密，然后与数据库中的密码进行对比  
    String entryPassword=DigestUtils. Md 5 DigestAsHex ((SALT+userPassword). GetBytes ());  
    //根据账户和密码查询用户信息  
    QueryWrapper<User> queryWrapper=new QueryWrapper<>();  
    QueryWrapper.Eq ("userAccount", userAccount);  
    QueryWrapper.Eq ("userPassword", entryPassword);  
    User user = userMapper.SelectOne (queryWrapper);  
    //用户不存在  
    If (user==null){  
        Log.Info ("user login failed, userAccount cannot match userPassword");  
        Return null;  
    }  
    //用户脱敏  
    User safeUser=new User ();  
    SafeUser.SetId (user.GetId ());  
    SafeUser.SetUsername (user.GetUsername ());  
    SafeUser.SetUserAccount (user.GetUserAccount ());  
    SafeUser.SetAvatarUrl (user.GetAvatarUrl ());  
    SafeUser.SetGender (user.GetGender ());  
    SafeUser.SetPhone (user.GetPhone ());  
    SafeUser.SetEmail (user.GetEmail ());  
    SafeUser.SetStatus (user.GetStatus ());  
    SafeUser.SetCreateTime (user.GetCreateTime ());  
    //记录用户登录态  
    Request.GetSession (). SetAttribute (USER_LOGIN_STATUS, safeUser);  
    Return safeUser;  
}
```

> [!warning]- 注意
> - 可以将用于加密的盐和用户 session 的键设置为常量
> - 必须要进行用户脱敏，不能将用户的一些敏感信息返回给前端
> - Lombok 插件中的 `@Slf 4 j` 注解用于提供日志功能

`@RestController` 适用于编写 restful 风格的 api, 返回 json 类型的数据
- 在调用一个方法时，往往需要手动的输入参数，比较麻烦，推荐安装 `Auto Filling Java Call Arguments` 插件，自动填充参数
![[Pasted image 20231205185652.png]]
- 请求体位 json 格式，我们可以创建一个对象专门来接收 json 格式的数据请求
```java
@Data  
Public class UserRegisterRequest implements Serializable {  
    Private String userAccount;  
    Private String userPassword;  
    Private String checkPassword;  
}
```

- Controller 层是对请求参数的校验，不涉及业务逻辑，Service 层是对业务逻辑的校验

> [!NOTE] UserController
```java
@RestController  
@RequestMapping ("/user")  
Public class UserController {  
    @Resource  
    Private UserService userService;  
    @PostMapping ("/register")  
    Public Long userRegister (@RequestBody UserRegisterRequest userRegisterRequest){  
        If (userRegisterRequest==null){  
            Return null;  
        }  
        String userAccount = userRegisterRequest.GetUserAccount ();  
        String userPassword = userRegisterRequest.GetUserPassword ();  
        String checkPassword = userRegisterRequest.GetCheckPassword ();  
        If (StringUtils.IsAnyBlank (userAccount, userPassword, checkPassword)) {  
            Return null;  
        }  
        Return userService.UserRegister (userAccount, userPassword, checkPassword);  
    }  
  
    @PostMapping ("/login")  
    Public User userRegister (@RequestBody UserLoginRequest userLoginRequest, HttpServletRequest request){  
        If (userLoginRequest==null){  
            Return null;  
        }  
        String userAccount = userLoginRequest.GetUserAccount ();  
        String userPassword = userLoginRequest.GetUserPassword ();  
        If (StringUtils.IsAnyBlank (userAccount, userPassword)) {  
            Return null;  
        }  
        Return userService.UserLogin (userAccount, userPassword, request);  
    }  
}
```


> [!NOTE]- 测试
> 我草，apifox 崩了，害我测试了好一阵子😭
![[Pasted image 20231205214707.png]]
![[Pasted image 20231205214737.png]]



### 用户管理接口-后端
1. 查询用户
	1. 根据用户名查询
2. 删除用户

> [!NOTE] UserController-用户查询接口
```java
@GetMapping ("/search")  
 public List<User> searchUsers (String username){  
	 //鉴权，仅管理员可以查询  
	Object userObj = request.GetSession (). GetAttribute (USER_LOGIN_STATUS);  
	User user = (User) userObj;  
	If (user==null||user.GetRole ()!=ADMIN_ROLE){  
	    return new ArrayList<>();  
	}
     Return userService.SearchUsers (username);  
 }
 
```

> [!NOTE] UserServiceImpl-用户查询
```java
@Override  
public List<User> searchUsers (String username) {  
    QueryWrapper<User> queryWrapper = new QueryWrapper<>();  
    If (StringUtils.IsNotBlank (username)) {  
        QueryWrapper.Like ("username", username);  
    }  
    Return this.List (queryWrapper);  
}
```

> [!NOTE] UserController-用户删除接口
```java
@PostMapping ("delete")  
Public boolean deleteUser (@RequestBody long id,, HttpServletRequest request){
	//鉴权，仅管理员可以查询  
	Object userObj = request.GetSession (). GetAttribute (USER_LOGIN_STATUS);  
	User user = (User) userObj;  
	If (user==null||user.GetRole ()!=ADMIN_ROLE){  
	    Return false;  
	}
    If (id<=0){  
        Return false;  
    }  
    Return userService.RemoveById (id);  
}
```


> [!warning] 注意
> 一定要进行鉴权，有些接口只能管理员进行调用，不能让一些阿猫阿狗恶意调用

- 在 user 表中添加一个<mark style="background: #FF5582A6;">身份</mark>字段，区分普通用户与管理员
- 只能管理员能删除用户和查询用户
- 注意：添加一个字段后要在对用的实体类上也添加一个属性, 尽量不要手动添加，因为手动添加还要修改 mapper 映射文件，<mark style="background: #ABF7F7A6;">建议重新用 MyBatisX 生成代码</mark>
<mark style="background: #FF5582A6;">我们可以将用户使用到的常量封装在一个常量类中</mark>
- 新建一个常量包 `constant`, 创建 `UserConatant` 接口，为什么创建接口，因为接口中的变量默认为常量
```java
Public interface UserConstant {  
    /**  
     * 用户登录键  
     */  
    String USER_LOGIN_STATUS = "userLoginStatus";  
    /**  
     * 默认权限  
     */  
    Int DEFAULT_ROLE=0;  
    /**  
     * 管理员权限  
     */  
    Int ADMIN_ROLE=1;  
}
```

<mark style="background: #ABF7F7A6;">我么可以将用户身份校验封装成一个单独的方法进行判断，否则后序如果还要进行身份校验的话，又需要重新写一遍，代码是在冗余</mark>

> [!NOTE] UserController
```java
@RestController  
@RequestMapping ("/user")  
Public class UserController {  
    @Resource  
    Private UserService userService;  
    @PostMapping ("/register")  
    Public Long userRegister (@RequestBody UserRegisterRequest userRegisterRequest){  
        If (userRegisterRequest==null){  
            Return null;  
        }  
        String userAccount = userRegisterRequest.GetUserAccount ();  
        String userPassword = userRegisterRequest.GetUserPassword ();  
        String checkPassword = userRegisterRequest.GetCheckPassword ();  
        If (StringUtils.IsAnyBlank (userAccount, userPassword, checkPassword)) {  
            Return null;  
        }  
        Return userService.UserRegister (userAccount, userPassword, checkPassword);  
    }  
  
    @PostMapping ("/login")  
    Public User userRegister (@RequestBody UserLoginRequest userLoginRequest, HttpServletRequest request){  
        If (userLoginRequest==null){  
            Return null;  
        }  
        String userAccount = userLoginRequest.GetUserAccount ();  
        String userPassword = userLoginRequest.GetUserPassword ();  
        If (StringUtils.IsAnyBlank (userAccount, userPassword)) {  
            Return null;  
        }  
        Return userService.UserLogin (userAccount, userPassword, request);  
    }  
  
   @GetMapping ("/search")  
    public List<User> searchUsers (@RequestBody String username, HttpServletRequest request){  
        //鉴权，仅管理员可以查询  
       If (! IsAdmin (request)){  
           return new ArrayList<>();  
       }  
       Return userService.SearchUsers (username);
    }  
  
    @PostMapping ("delete")  
    Public boolean deleteUser (@RequestBody long id, HttpServletRequest request){  
        If (! IsAdmin (request)){  
            Return false;  
        }  
        If (id<=0){  
            Return false;  
        }  
        Return userService.RemoveById (id);  
    }  
  
    /**  
     * 是否为管理员  
     * @param request  
     * @return  
     */  
    Private boolean isAdmin (HttpServletRequest request){  
        //鉴权，仅管理员可以查询  
        Object userObj = request.GetSession (). GetAttribute (USER_LOGIN_STATUS);  
        User user = (User) userObj;  
        If (user==null||user.GetRole ()!=ADMIN_ROLE){  
            Return false;  
        }  
        Return true;  
    }  
}
```

<mark style="background: #ABF7F7A6;">我们返回给前端的用户信息始终为脱敏的用户信息，所以我们可以在 service 层编写一个方法专门用于对原生用户信息进行脱敏</mark>

> [!NOTE] UserServiceImpl
```java
@Service  
@Slf 4 j  
public class UserServiceImpl extends ServiceImpl<UserMapper, User>  
    Implements UserService {  
    @Resource  
    Private UserMapper userMapper;  
    Private static final String SALT="yhk";//加盐, 混淆密码  
  
    @Override  
    Public long userRegister (String userAccount, String userPassword, String checkPassword) {  
        //1. 校验  
        If (StringUtils.IsAnyBlank (userAccount, userPassword, checkPassword)){//校验所含字符串是否为空，或者长度为 0  
            Return -1;  
        }  
        If (userAccount.Length ()<4){  
            Return -1;  
        }  
        If (userPassword.Length ()<8||checkPassword.Length ()<8){  
            Return -1;  
        }  
        //校验账户不能包含特殊字符  
        String regEx = "\\pP|\\pS|\\s+";  
        Matcher matcher = Pattern.Compile (regEx). Matcher (userAccount);  
        If (matcher.Find ()){//匹配到特殊字符  
            Return -1;  
        }  
        If (! UserPassword.Equals (checkPassword)){  
            Return -1;  
        }  
        //账户不能重复，查询数据库中有没有相同的账户, 可以将查询数据库放到最后，如果前面的条件都满足的话，在进行查询数据库，因为查询数据库是最耗费时间的  
        long count = userMapper.SelectCount (new QueryWrapper<User>(). Eq ("userAccount", userAccount));  
        If (count>0){  
            Return -1;  
        }  
        //2. 对密码进行加密  
        String encryptPassword = DigestUtils. Md 5 DigestAsHex ((SALT + userPassword). GetBytes ());  
        // 3. 插入数据  
        User user=new User ();  
        User.SetUserAccount (userAccount);  
        User.SetPassword (encryptPassword);  
        Boolean saveResult = this.Save (user);  
        If (! SaveResult){  
            Return -1;  
        }  
        Return user.GetId ();//id 为 Long 类型，但是返回的是 long 类型，如果返回一个 null 的话将会报错  
    }  
  
    @Override  
    Public User userLogin (String userAccount, String userPassword, HttpServletRequest request) {  
        //校验  
        If (StringUtils.IsAnyBlank (userAccount, userPassword)){  
            Return null;  
        }  
        If (userAccount.Length ()<4){  
            Return null;  
        }  
        If (userPassword.Length ()<8){  
            Return null;  
        }  
        //账户不能包含特殊字符  
        String regEx = "\\pP|\\pS|\\s+";  
        Matcher matcher = Pattern.Compile (regEx). Matcher (userAccount);  
        If (matcher.Find ()){  
            Return null;  
        }  
        //将登录的密码进行加密，然后与数据库中的密码进行对比  
        String entryPassword=DigestUtils. Md 5 DigestAsHex ((SALT+userPassword). GetBytes ());  
        //根据账户和密码查询用户信息  
        QueryWrapper<User> queryWrapper=new QueryWrapper<>();  
        QueryWrapper.Eq ("userAccount", userAccount);  
        QueryWrapper.Eq ("password", entryPassword);  
        User user = userMapper.SelectOne (queryWrapper);  
        //用户不存在  
        If (user==null){  
            Log.Info ("user login failed, userAccount cannot match userPassword");  
            Return null;  
        }  
        //用户脱敏  
        User safeUser = getSafeUser (user);  
        //记录用户登录态  
        Request.GetSession (). SetAttribute (USER_LOGIN_STATUS, safeUser);  
        Return safeUser;  
    }  
  
    @Override  
    public List<User> searchUsers (String username) {  
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();  
        If (StringUtils.IsNotBlank (username)) {  
            QueryWrapper.Like ("username", username);  
        }  
        List<User> userList= this.List (queryWrapper);  
        Return userList.Stream (). Map (user -> getSafeUser (user)). Collect (Collectors.ToList ());  
    }  
  
    /**  
     * 将原生 user 对象进行脱敏  
     * @param originUser 原生 user  
     * @return  
     */  
    @Override  
    Public User getSafeUser (User originUser) {  
        User safeUser=new User ();  
        SafeUser.SetId (originUser.GetId ());  
        SafeUser.SetUsername (originUser.GetUsername ());  
        SafeUser.SetUserAccount (originUser.GetUserAccount ());  
        SafeUser.SetAvatarUrl (originUser.GetAvatarUrl ());  
        SafeUser.SetGender (originUser.GetGender ());  
        SafeUser.SetPhone (originUser.GetPhone ());  
        SafeUser.SetEmail (originUser.GetEmail ());  
        SafeUser.SetStatus (originUser.GetStatus ());  
        SafeUser.SetCreateTime (originUser.GetCreateTime ());  
        Return safeUser;  
    }  
}
```

> [!warning]- 注意
>- 但凡是返回给前端用户信息，一定要进行脱敏
>- 用户功能中用到的常量可以封装为一个接口
>- 在多个接口中用到同样代码块，可以将代码块封装为一个方法，实现功能复用
>- 一些接口只能管理员进行调用，必须进行鉴权（可以将鉴权操作封装为一个方法）
>- 可以使用 java 8 中的 stream 流，使代码更优雅😁

### 登录注册-前端
- 如果对前端不感兴趣，可以直接将前端文件部署在 WebStrom 上，不过要注意，<mark style="background: #ABF7F7A6;">nodejs 的版本一定要是 16</mark>,nodejs 16 版本现在已经不支持了，但可以通过 nvm 管理库进行安装
- 修改登录界面底部 
```js
Import { GithubOutlined } from '@ant-design/icons';  
Import { DefaultFooter } from '@ant-design/pro-layout';  
Import { PLANET_LINK } from '@/constants';  
  
Const Footer: React. FC = () => {  
  Const defaultMessage = 'Moresuo 出品';  
  Const currentYear = new Date (). GetFullYear ();  
  Return (  
    <DefaultFooter  
      Copyright={`${currentYear} ${defaultMessage}`}  
      Links={[  
        {  
          Key: 'planet',  
          Title: '知识星球',  
          Href: PLANET_LINK,  
          BlankTarget: true,  
        },  
        {  
          Key: 'codeNav',  
          Title: '编程导航',  
          href: ' https://www.code-nav.cn ',  
          BlankTarget: true,  
        },  
        {  
          Key: 'github',  
          Title: (  
            <>  
              <GithubOutlined /> Moresuo GitHub  
            </>  
          ),  
          href: ' https://github.com/moresuo ',  
          BlankTarget: true,  
        },  
      ]}  
    />  
  );  
};  
  
Export default Footer;
```
- 将 logo 图片设置为常量
### 获取当前用户信息接口
相当于一个拦截的功能，当跳转其他页面时，请求这个接口，如果用户状态为空，说明还没有登录，直接返回登录页面

> [!NOTE] UserController-用户信息接口
```java
@GetMapping ("/current")  
Public User getCurrentUser (HttpServletRequest request){  
    Object userObj = request.GetSession (). GetAttribute (USER_LOGIN_STATUS);  
    User userCurrent= (User) userObj;  
    If (userCurrent==null){  
        Return null;  
    }  
    //根据用户 id 去查询用户数据库的具体信息  
    Long userId = userCurrent.GetId ();  
    //todo 校验用户是否合法  
    User user = userService.GetById (userId);  
    Return userService.GetSafeUser (user);  
}
```

> [!warning]- 注意
> - 用户信息随时都可能会变，存放在 session 中的用户信息不具有动态性，所以还要根据用户 id 去查询数据库返回最新的用户信息

### 用户注销 -后端
- 登录时将用户的状态存入 session 中，使用户在访问其他请求时保持登录的状态，这一切都归功与 session
- 相反，如果想让用户注销掉，失去登录的状态，我们将 session 中的登录用户移除就行了

> [!NOTE] UserService-logOut
```java
/**  
 * 用户注销功能  
 * @return  
 */  
Int userLogout (HttpServletRequest request);
```

> [!NOTE]- UserServiceImpl-logOut
```java
@Override  
Public int userLogout (HttpServletRequest request) {  
    Request.GetSession (). RemoveAttribute (USER_LOGIN_STATUS);//将用户状态从 session 中移除  
    Return 1;
}
```


> [!NOTE] UserController-logOut
```java
@PostMapping ("/logout")  
Public Integer userLogOut (HttpServletRequest request){  
    If (request==null){  
        Return null;  
    }    return userService.UserLogout (request);  
}
```

### 用户校验
>仅适用于用户可信的情况

先让用户自己填：2-5 位星球编号
后端校验：长度校验，唯一性校验
前端补充输入框，适配后端

- 新增一个字段 `planetCode`, 通过 MyBatisX 插件再次生成 User 类，<mark style="background: #ABF7F7A6;">并修改 UserMapper 配置文件映射的包名</mark>
- 星球编号不用数据脱敏，要返回给前端
- 新增一个字段，也要修改一些列业务代码，实在是太麻烦了，在实际开发中尽量不要去新增或删除一个字段😭
- 在 UserServiceImpl 中还要校验星球编号的唯一性
```java
//星球编号不能重复  
count = userMapper.SelectCount (new QueryWrapper<User>(). Eq ("planetCode", planetCode));  
If (count>0){  
    Return -1;  
}
```

### 后端优化
#### 通用返回对象
目的：给对象补充一些信息，告诉前端这个请求在业务上是成功还是失败
```json
{
	"code": 0,//业务状态码
	"data":{
		//具体返回的对象数据
	},
	"message": "返回信息"
}
```


> [!NOTE] BaseResponse
```java
Package com. Yhk. Usercenter. Common;  
  
Import lombok. Data;  
  
Import java. Io. Serializable;  
  
/**  
 * @version 1.0  
 * @Author moresuo  
 * @Date 2023/12/11 21:03  
 * @注释通用返回类  
 */  
@Data  
public class BaseResponse<T> implements Serializable {  
    Private static final long serialVersionUID = -7506108714914421400 L;  
    Private Integer code;  
    Private T data;  
    Private String message;  
  
    Public BaseResponse (Integer code, T data, String message) {  
        This. Code = code;  
        This. Data = data;  
        This. Message = message;  
    }  
  
    Public BaseResponse (Integer code, T data) {  
        This. Code = code;  
        This. Data = data;  
        This. Message="";  
    }  
  
}
```

修改 controller 层所有的返回对象为 `BaseResponse` 这样的做法是在太麻烦了，<mark style="background: #ABF7F7A6;">可以创建一个返回工具类，将成功信息和失败等信息进行封装
</mark>

> [!NOTE] ResultUtil
```java
Public class ResultUtil {  
    public static <T> BaseResponse<T> success (T data){  
        return new BaseResponse<>(0, data,"ok");  
    }  
}
```


> [!NOTE] UserController
```java
Package com. Yhk. Usercenter. Controller;  
  
Import com. Yhk. Usercenter. Common. BaseResponse;  
Import com. Yhk. Usercenter. Common. ResultUtil;  
Import com. Yhk. Usercenter. Model. Domain. User;  
Import com. Yhk. Usercenter. Model. Request. UserLoginRequest;  
Import com. Yhk. Usercenter. Model. Request. UserRegisterRequest;  
Import com. Yhk. Usercenter. Service. UserService;  
Import org. Apache. Commons. Lang 3. StringUtils;  
Import org. Springframework. Web. Bind. Annotation.*;  
  
Import javax. Annotation. Resource;  
Import javax. Servlet. Http. HttpServletRequest;  
Import java. Util. ArrayList;  
Import java. Util. List;  
  
Import static com. Yhk. Usercenter. Constant. UserConstant. ADMIN_ROLE;  
Import static com. Yhk. Usercenter. Constant. UserConstant. USER_LOGIN_STATUS;  
  
/**  
 * @version 1.0  
 * @Author moresuo  
 * @Date 2023/12/5 18:48  
 * @注释用户接口  
 */  
@RestController  
@RequestMapping ("/user")  
Public class UserController {  
    @Resource  
    Private UserService userService;  
    @PostMapping ("/register")  
    public BaseResponse<Long> userRegister (@RequestBody UserRegisterRequest userRegisterRequest){  
        If (userRegisterRequest==null){  
            Return null;  
        }        String userAccount = userRegisterRequest.GetUserAccount ();  
        String userPassword = userRegisterRequest.GetUserPassword ();  
        String checkPassword = userRegisterRequest.GetCheckPassword ();  
        String planetCode= userRegisterRequest.GetPlanetCode ();  
        If (StringUtils.IsAnyBlank (userAccount, userPassword, checkPassword, planetCode)) {  
            Return null;  
        }        long result = userService.UserRegister (userAccount, userPassword, checkPassword, planetCode);  
        Return ResultUtil.Success (result);  
    }  
  
    @PostMapping ("/login")  
    public BaseResponse<User> userRegister (@RequestBody UserLoginRequest userLoginRequest, HttpServletRequest request){  
        If (userLoginRequest==null){  
            Return null;  
        }        String userAccount = userLoginRequest.GetUserAccount ();  
        String userPassword = userLoginRequest.GetUserPassword ();  
        If (StringUtils.IsAnyBlank (userAccount, userPassword)) {  
            Return null;  
        }        User user = userService.UserLogin (userAccount, userPassword, request);  
        Return ResultUtil.Success (user);  
    }  
    @PostMapping ("/logout")  
    public BaseResponse<Integer> userLogOut (HttpServletRequest request){  
        If (request==null){  
            Return null;  
        }        int result = userService.UserLogout (request);  
        Return ResultUtil.Success (result);  
    }  
  
    @GetMapping ("/current")  
    public BaseResponse<User> getCurrentUser (HttpServletRequest request){  
        Object userObj = request.GetSession (). GetAttribute (USER_LOGIN_STATUS);  
        User userCurrent= (User) userObj;  
        If (userCurrent==null){  
            Return null;  
        }        //根据用户 id 去查询用户数据库的具体信息  
        Long userId = userCurrent.GetId ();  
        //todo 校验用户是否合法  
        User user = userService.GetById (userId);  
        User result = userService.GetSafeUser (user);  
        Return ResultUtil.Success (result);  
    }  
  
   @GetMapping ("/search")  
    public BaseResponse<List<User>> searchUsers (@RequestBody String username, HttpServletRequest request){  
        //鉴权，仅管理员可以查询  
       If (! IsAdmin (request)){  
           Return null;  
       }       List<User> result = userService.SearchUsers (username);  
       Return ResultUtil.Success (result);  
   }  
  
    @PostMapping ("delete")  
    public BaseResponse<Boolean> deleteUser (@RequestBody long id, HttpServletRequest request){  
        If (! IsAdmin (request)){  
            Return null;  
        }        if (id<=0){  
            Return null;  
        }        boolean result = userService.RemoveById (id);  
        Return ResultUtil.Success (result);  
    }  
  
    /**  
     * 是否为管理员  
     * @param request  
     * @return  
     */  
    Private boolean isAdmin (HttpServletRequest request){  
        //鉴权，仅管理员可以查询  
        Object userObj = request.GetSession (). GetAttribute (USER_LOGIN_STATUS);  
        User user = (User) userObj;  
        If (user==null||user.GetUserRole ()!=ADMIN_ROLE){  
            Return false;  
        }        return true;  
    }  
}
```

#### 封装全局异常处理
- 之前 service 层校验失败要么返回-1 要么返回 null, 这样对前端提示非常不友好，可读性差
- <mark style="background: #ABF7F7A6;">可以定义一套通用的状态码</mark>
	- 成功状态
	- 请求参数错误
	- 请求参数为空
	- 无权限
	- 未登录
	- 系统内部异常

> [!NOTE] ErrorCode
> 枚举不支持 `@Data` 注解，也不支持 set 方法，相当于常量不能修改
```java
Package com. Yhk. Usercenter. Common;  
  
/**  
 * @version 1.0  
 * @Author moresuo  
 * @Date 2023/12/11 22:28  
 * @注释全局状态码  
 */  
Public enum ErrorCode {  
    SUCCESS (0,"ok",""),  
    PARAMS_ERROE (40000,"请求参数错误",""),  
    PARAMS_NULL_ERROE (40001,"请求数据为空",""),  
    NO_AUTH (40101,"无权限",""),  
    NOT_LOGIN (40100,"未登录","");  
    Private final int code;//状态码  
    Private final String message;//状态码信息  
    Private final String description;//状态码描述  
  
    ErrorCode (int code, String message, String description) {  
        This. Code = code;  
        This. Message = message;  
        This. Description = description;  
    }  
    Public int getCode () {  
	    Return code;  
	}  
  
	Public String getMessage () {  
	    Return message;  
	}  
  
	Public String getDescription () {  
	    Return description;  
	}
}
```
- 将通用返回对象 `BaseResponse` 的属性依赖于 `ErrorCode` 的枚举
```java
Package com. Yhk. Usercenter. Common;  
  
Import lombok. Data;  
  
Import java. Io. Serializable;  
  
/**  
 * @version 1.0  
 * @Author moresuo  
 * @Date 2023/12/11 21:03  
 * @注释通用返回类  
 */  
@Data  
public class BaseResponse<T> implements Serializable {  
    Private static final long serialVersionUID = -7506108714914421400 L;  
    Private Integer code;  
    Private T data;  
    Private String message;  
    Private String description;  
  
    Public BaseResponse (Integer code, T data, String message, String description) {  
        This. Code = code;  
        This. Data = data;  
        This. Message = message;  
        This. Description=description;  
    }  
    Public BaseResponse (Integer code, T data, String message) {  
        This. Code = code;  
        This. Data = data;  
        This. Message = message;  
    }  
  
    Public BaseResponse (Integer code, T data) {  
        This. Code = code;  
        This. Data = data;  
        This. Message="";  
    }  
    Public BaseResponse (ErrorCode errorCode){  
        This (errorCode.GetCode (), null, errorCode.GetMessage (), errorCode.GetDescription ());  
    }  
  
}
```

<mark style="background: #FFB86CA6;">可能你会发现通过 ErroeCode 也可以返回成功信息，那为什么还要单独定义一个 success 方法</mark>
>如果单纯的返回一个成功信息，而不用返回任何从后端获取的数据，就使用 ErrorCode 即可
>如果返回成功信息的同时还要携带从后端获取的数据信息（data），那就可以调用 success 方法

你可能觉得当前的 `ResultUtil` 已经很完美了，返回成功和错误的信息，但这个只局限于 controller 层，<mark style="background: #FF5582A6;">如果在其他类中呢，可能就不仅仅只是返回成功和错误的信息</mark>，所以有了全局异常处理类

1. 定义业务异常类
- 相对于 java 的异常类，支持更多字段
- 自定义构造函数，更灵活快捷设置字段

> [!NOTE] BusinessException
```java
Package com. Yhk. Usercenter. Exception;  
  
Import com. Yhk. Usercenter. Common. ErrorCode;  
  
/**  
 * @version 1.0  
 * @Author moresuo  
 * @Date 2023/12/11 23:00  
 * @注释自定义异常类  
 */  
Public class BusinessException extends RuntimeException {  
    Private final int code;  
    Private final String description;  
    Public BusinessException (String message, int code, String description){  
        Super (message);//异常信息交给 RuntimeException 去显示  
        This. Code=code;  
        This. Description=description;  
    }  
    Public BusinessException (ErrorCode errorCode){  
        Super (errorCode.GetMessage ());  
        This. Code=errorCode.GetCode ();  
        This. Description=errorCode.GetDescription ();  
    }  
	Public BusinessException (ErrorCode errorCode, String description){  
	    Super (errorCode.GetMessage ());  
	    This. Code=errorCode.GetCode ();  
	    This. Description=description;  
	}
  
    Public int getCode () {  
        Return code;  
    }  
  
    Public String getDescription () {  
        Return description;  
    }  
}
```
- 将之前返回的错误校验信息更换为抛出异常
2. 编写全局异常处理器
- 捕获代码中所有异常，集中处理，让前端得到更详细的业务报错
- 如果不将异常信息屏蔽掉的可能会给前端暴露一些后端接口信息，存在安全隐患问题
![[Pasted image 20231211233239.png]]
- 利用 Spring AOP 切面，在方法调用前后进行集中处理
- `@RestControllerAdvice` 注解定义一个切面类
- `@ExceptionHandler` 用在方法上，属性为异常类的 class 对象，表示捕获指定异常
```java
Package com. Yhk. Usercenter. Exception;  
  
Import com. Yhk. Usercenter. Common. BaseResponse;  
Import com. Yhk. Usercenter. Common. ErrorCode;  
Import com. Yhk. Usercenter. Common. ResultUtil;  
Import lombok. Extern. Slf 4 j. Slf 4 j;  
Import org. Springframework. Web. Bind. Annotation. ExceptionHandler;  
Import org. Springframework. Web. Bind. Annotation. RestControllerAdvice;  
  
/**  
 * @version 1.0  
 * @Author moresuo  
 * @Date 2023/12/11 23:33  
 * @注释全局异常处理器  
 */  
@RestControllerAdvice  
@Slf 4 j  
Public class GlobalExceptionHandler {  
    @ExceptionHandler (BusinessException. Class)  
    Public BaseResponse businessExceptionHandler (BusinessException e){  
        log.Error ("business: "+e.getMessage (), e);  
        return ResultUtil.Error (e.getCode (), e.getMessage (), e.getDescription ());  
    }  
  
    @ExceptionHandler (RuntimeException. Class)  
    Public BaseResponse businessExceptionHandler (RuntimeException e){  
        Log.Error ("runtime: ", e);  
        return ResultUtil.Error (ErrorCode. SYSTEM_ERROE, e.getMessage (), "");  
    }  
}
```
#### 全局请求日志和登录校验

## 部署
### 多环境
参考文章：[多环境设计-CSDN博客](https://blog.csdn.net/weixin_41701290/article/details/120173283)
<mark style="background: #ABF7F7A6;">同一套项目代码在不同阶段需要根据实际情况来部署到不同的机器上</mark>
优点：
- 每个环境互不影响
- 为了区分不同的阶段：开发/测试/生产环境
- 对项目进行优化
	- 本地日志级别
	- 精简依赖，节省项目体积
	- 项目环境/参数可以调整
针对不同环境做不同的事情

**多环境分类：**
1. 本地环境：localhost
2. 开发环境（远程开发），大家来连同一台机器
3. 测试环境，独立的服务器，独立的数据库（单元测试/功能测试/系统集成测试/性能测试）
4. 预发布环境（体验服）
5. 正式环境（线上对外公开访问环境），尽量不要改动
6. 沙箱/实验环境
#### 前端多环境
- 请求地址
	- 开发环境：locahost:8080
	- 线上环境: moresuo. Top
- 启动方式
	- 开发环境：npm run start
	- 线上环境：npm run build (项目构建打包)，使用 `serve` 进行调试（安装 serve: `npm install -g serve`）, 相当于一个本地 web 服务器
- 项目配置
	- 可以在配置文件后添加对应的环境名称后缀来区分开发环境和生产环境
	- 开发环境：config. Dev. Ts
	- 生产环境：config. Prod. Ts
#### 后端多环境
通过修改 application 配置文件的后缀来表示不同的环境
![[Pasted image 20231218174528.png]]
将创建的表的 DDL 保存下来放入一个文件中
![[Pasted image 20231218184811.png]]


<mark style="background: #ABF7F7A6;">可以在启动项目时传入启动变量</mark>
![[Pasted image 20231218214215.png]]
![[Pasted image 20231218215612.png]]
![[Pasted image 20231218220628.png]]

> [!NOTE] 问题-没有主清单属性
> ![[Pasted image 20231218220729.png]]
> 在 spring-boot-maven-plugin 的配置中设置 <skip>true</skip> 时，实际上你告诉 Maven 在执行构建生命周期时跳过这个插件的运行。此插件负责将你的项目打包成一个可执行的 JAR 文件，其中包含了一个正确的清单文件（MANIFEST. MF）以及所有的项目依赖项。
在清单文件中，主类（Main Class）的信息是一个关键的元素，它告诉 JVM 运行哪一个类的 main 方法作为程序的入口点。如果 spring-boot-maven-plugin 被跳过了，那么这个清单文件可能不会被正确地生成，主类的信息也就不会被加入到清单文件中。这就是为什么当你尝试运行 JAR 文件时，你会看到 "没有主清单属性" 的错误。
所以，为了正确生成可执行的 JAR 文件，需要移除 <skip>true</skip> 配置，或者将其设置为 false。这样，在执行 mvn package 或者 mvn install 时，spring-boot-maven-plugin 就会被执行，它会生成一个正确的可执行的 JAR 文件，包含了主类的信息以及所有的项目依赖项

### 项目部署
#### 原始部署
>什么都自己装

**前端**
需要 web 服务器：nginx
参考文档：[nginx安装及其配置详细教程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/83890573)
1. 官网：[nginx：下载](https://nginx.org/en/download.html)
2. ![[Pasted image 20231218224951.png]]
3. 将下载的压缩包传到 linux 下
4. 创建一个目录用与存放 nginx
```shell
[ root@moresuo ~]# mkdir service
[ root@moresuo ~]# ll
Total 1132
drwxr-xr-x 2 root root    4096 Nov 28 20:42 halo
-rw-r--r-- 1 root root   34763 Nov 22 17:29 install. Sh
-rw-r--r-- 1 root root 1112471 Dec 18 22:51 nginx-1.24.0. Tar. Gz
drwxr-xr-x 2 root root    4096 Dec 18 22:51 service
[ root@moresuo ~]# mv nginx-1.24.0. Tar. Gz service
[ root@moresuo ~]# ll
Total 44
drwxr-xr-x 2 root root  4096 Nov 28 20:42 halo
-rw-r--r-- 1 root root 34763 Nov 22 17:29 install. Sh
drwxr-xr-x 2 root root  4096 Dec 18 22:52 service
[ root@moresuo ~]# cd service
[ root@moresuo service]# ll
Total 1088
-rw-r--r-- 1 root root 1112471 Dec 18 22:51 nginx-1.24.0. Tar. Gz
```
5. 解压 nginx
```shell
[ root@moresuo service]# tar -zxvf nginx-1.24.0. Tar. Gz
```
6. 进入 nginx-1.24.0 文件
7. 执行 configure 文件
```shell
[ root@moresuo nginx-1.24.0]# . Configure
```
8. 编译 nginx
```shell
Make
```
9. 安装
```shell
Make install
```
10. 修改环境变量
```shell
Vim /etc/profile
```
![[Pasted image 20231218231425.png]]
11. 重新激活配置文件，否则还是无效
```shell
Source /etc/profile
```
12. 将前端项目打包传到 linux
![[Pasted image 20231218232427.png]]
![[Pasted image 20231218232453.png]]
13. 解压到指定目录下
```shell
[ root@moresuo service]# unzip dist. Zip -d user-center-front
```
14. 进入到 nginx 配置文件目录下，修改配置文件
```shell
[ root@moresuo service]# cd nginx-1.24.0
[ root@moresuo nginx-1.24.0]# ls
CHANGES  CHANGES. Ru  LICENSE  Makefile  README  auto  conf  configure  contrib  html  man  objs  src
[ root@moresuo nginx-1.24.0]# cd conf
[ root@moresuo conf]# vim nginx. Conf
```
![[Pasted image 20231218233207.png]]
![[Pasted image 20231218234723.png]]

**后端**
>安装 JDK, maven

```shell
[ root@moresuo conf]# yum install -y java-1.8.0-openjdk*
```
Maven 官网下载：[Maven – Download Apache Maven](https://maven.apache.org/download.cgi)
![[Pasted image 20231218235501.png]]
<mark style="background: #ABF7F7A6;">复制 maven 下载链接</mark>
```shell
[ root@moresuo service]# curl -o apache-maven-3.9.6-bin. Tar. Gz https://dlcdn.apache.org/maven/maven-3/3.9.6/binaries/apache-maven-3.9.6-bin.tar.gz
```
<mark style="background: #ABF7F7A6;">将代码仓库中的后端代码克隆到 linux 中</mark>
```shell
[ root@moresuo service]# git https://gitee.com/moresuo/user-center.git
```
![[Pasted image 20231219001602.png]]
<mark style="background: #ABF7F7A6;">给项目的 jar 包赋予可执行权限</mark>
```shell
[ root@moresuo target]# chmod a+x user-center-0.0.1-SNAPSHOT. Jar
```
![[Pasted image 20231219083807.png]]
<mark style="background: #ABF7F7A6;">启动之后让项目在后台运行</mark>
```shell
[nohup java -jar](<[root@moresuo target]# nohup java -jar ./user-center-0.0.1-SNAPSHOT.jar &>)
```
![[Pasted image 20231219091721.png]]
`jps` 命令查看所有工作的 java 进程
#### 宝塔安装
**宝塔：**：一个 linux 运维可视化控制面板
>方便管理服务器，安装软件
![[Pasted image 20231219093400.png]]
![[Pasted image 20231219101643.png]]
![[Pasted image 20231219101722.png]]
![[Pasted image 20231219101555.png]]
![[Pasted image 20231219102533.png]]
![[Pasted image 20231219102552.png]]
![[Pasted image 20231219104358.png]]

#### Docker 部署
Docker 是容器，可以将项目依赖的环境（java, nginx）和项目代码打包成镜像，镜像更容易分发和移植，再启动项目时，不需要敲一大堆命令，直接下载镜像，启动镜像即可运行项目，可以理解为为一个安装包，一个沙盒环境，在沙盒里部署的环境只作用于沙盒内的项目，而不会干扰沙盒外的事物，而且可以存在多个 docker 容器，意思是可以存在多个项目的部署而配置环境依赖互不干扰
