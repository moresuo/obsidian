***
## 需求设计
- **短信登录**：使用 redis 共享 session 来实现
- **商户查询缓存**：解决缓存穿透，缓存雪崩，缓存击穿问题
- **优惠卷秒杀**：使用 Redis 计数器功能，结合 Lua 脚本语言完成高性能 redis 操作，学会 Redis 分布式锁的原理，包括 Redis 的 3 种消息队列
- **附近的商户**：利用 Redis 的 GEOHash 来完成对地理坐标的操作
- **UV 统计**：使用 redis 完成统计功能
- **用户签到**：使用 redis 的 BitMap 统计功能
- **好友关注**：基于 redis 的 set 集合实现关注，取消关注，共同关注等功能
- **达人探店**：基于 redis 的 List 完成点赞列表操作，同时基于 sortedSet 来完成点赞排行榜功能
## 环境搭建
### 导入后端项目
![[Pasted image 20240116141320.png]]
<mark style="background: #FF5582A6;">将 application.yml 文件中配置信息进行修改：MySQL 数据库地址，用户名，密码；Redis 数据库地址，用户名，密码</mark>
运行项目，在浏览器访问：`http://localhost:8081/shop-type/list`
![[Pasted image 20240116144409.png]]
出现以上结果说明后端项目环境搭建成功
### 连接数据，运行 SQL 文件
![[Pasted image 20240116141753.png]]
![[Pasted image 20240116141812.png]]
- `tb_user`: 用户表
- `tb_user_info`: 用户详情表
- `tb_shop`: 商品信息表
- `tb_shop_type`: 商户类型表
- `tb_blog`: 用户日记表
- `tb_follow`: 用户关注表
- `tb_voucher`: 优惠卷表
- `tb_voucher_order`: 优惠卷订单表
- `tb_blog_comments`: 用户评论表
- `tb_seckill_voucher`: 秒杀优惠卷卷表
### 导入前端项目
![[Pasted image 20240116142601.png]]
![[Pasted image 20240116144607.png]]
- 输入 `start nginx`,<mark style="background: #FF5582A6;">输入之后别关闭命令窗口</mark>
- 进入浏览器，输入：`localhost:8080`
- 出现页面之后，按 f 12
- ![[Pasted image 20240116145014.png]]
### 项目架构
![[黑马点评 项目架构.excalidraw]]


> [!NOTE] 架构介绍
> ⼿机或者 app 端发起请求，请求我们的 nginx 服务器，nginx 基于七层模型⾛的事HTTP 协议，<mark style="background: #ABF7F7A6;">可以实现基于 Lua 直接绕开 tomcat 访问 redis</mark>，也可以作为静态资源服务器，轻松扛下上万并发， <mark style="background: #ABF7F7A6;">负载均衡到下游 tomcat 服务器</mark>，打散流量，我们都知道⼀台 4 核 8G 的 tomcat，在优化和处理简单业务的加持下，⼤不了就处理 1000 左右的并发， 经过 nginx 的负载均衡分流后，利⽤集群⽀撑起整个项⽬，同时 nginx在部署了前端项⽬后，更是可以做到动静分离，进⼀步降低 tomcat 服务的压⼒，这些功能都得靠 nginx 起作⽤，所以 nginx 是整个项⽬中重要的⼀环。在 tomcat ⽀撑起并发流量后，我们如果让 tomcat 直接去访问 Mysql，根据经验Mysql 企业级服务器只要上点并发，⼀般是 16 或 32 核⼼ cpu，32 或 64G 内存，像企业级 mysql 加上固态硬盘能够⽀撑的并发，⼤概就是 4000 起 ~7000 左右，上万并发， 瞬间就会让 Mysql 服务器的 cpu，硬盘全部打满，容易崩溃，<mark style="background: #ABF7F7A6;">所以我们在⾼并发场景下，会选择使⽤ mysql 集群，同时为了进⼀步降低 Mysql 的压⼒，同时增加访问的性能，我们也会加⼊ Redis，同时使⽤ Redis 集群使得 Redis 对外提供更好的服务。</mark>
## 登录功能
### 基于 Session 实现登录

> [!NOTE] 发送验证码
> - 用户提交手机号之后，检验手机号是否合法，如果不合法要求用户重新输入
> - 手机号合法，后台产生一个验证码，将验证码进行保存，然后通过短信的方式将验证码发送给用户


> [!NOTE] 短信验证码登录、注册
> - 用户将验证码和手机号进行输入，后台从 session 中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到 session 中，方便后续获得当前登录信息


> [!NOTE] 验证登录状态
> - 用户在请求时候，会从 cookie 中携带者 JsessionId 到后台，后台通过 JsessionId 从 session 中拿到用户信息，如果没有 session 信息，则进行拦截，如果有 session 信息，则将用户信息保存到 threadLocal 中，并且放行


![[1653066208144.png]]
#### 发送短信验证码
![[1653067054461.png]]

**发送验证码具体代码实现**：

> [!NOTE] Controller 层
```java
@PostMapping("code")  
public Result sendCode(@RequestParam("phone") String phone, HttpSession session) {  
    return userService.sendCode(phone,session);  
}
```

> [!NOTE] Service 层
```java
public Result sendCode(String phone, HttpSession session) {  
    //检验手机号是否合法  
    if(RegexUtils.isPhoneInvalid(phone)){  
        return Result.fail("手机号格式不正确");  
    }    //手机号合法，生成验证码保存到session  
    String code= RandomUtil.randomNumbers(6);//生成6位随机字符数字  
    session.setAttribute("code", code);  
    //发送验证码  
    log.info("验证码：{}", code);  
    return Result.ok();  
}
```

**登录功能具体实现**：

> [!NOTE] Controller 层
```java
@PostMapping("/login")  
public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session){  
    return userService.login(loginForm, session);  
}
```

> [!NOTE] Service 层
```java
public Result login(LoginFormDTO loginFormDTO, HttpSession session) {  
    String phone= loginFormDTO.getPhone();  
    String webCode=loginFormDTO.getCode();  
    //判断手机号是否合法  
    if(RegexUtils.isPhoneInvalid(phone)){  
        return Result.fail("手机号不合法");  
    }    //判断验证码是否正确  
    String code = (String) session.getAttribute("code");  
    if(code==null||!webCode.equals(code)){  
        return Result.fail("验证码不正确");  
    }    //判断手机号是否已经注册过  
    User user = this.getOne(new LambdaQueryWrapper<User>().eq(User::getPhone, phone));  
    if(Objects.isNull(user)){  
        //用户不存在，注册  
        user = createUserWithPhone(phone);  
    }    //将用户保存到session中  
    session.setAttribute("user", user);  
    return Result.ok();  
}  
  
/**  
 * 根据手机号创建用户  
 * @param phone  
 * @return  
 */  
private User createUserWithPhone(String phone){  
    User user=new User();  
    user.setPhone(phone);  
    user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomString(10));  
    this.save(user);  
    return user;  
}
```
#### 配置登录拦截器

> [!NOTE] Tomcat 运行原理

> ![[1653068196656.png]]
> 当用户发起请求时，会<mark style="background: #ABF7F7A6;">访问我们像 tomcat 注册的端口</mark>，任何程序想要运行，都需要有<mark style="background: #ABF7F7A6;">一个线程对当前端口号进行监听</mark>，tomcat 也不例外，当监听线程知道用户想要和 tomcat 连接连接时，<mark style="background: #ABF7F7A6;">那会由监听线程创建 socket 连接</mark>，socket 都是成对出现的，<mark style="background: #ABF7F7A6;">用户通过 socket 像互相传递数据</mark>，当 tomcat 端的 socket 接受到数据后，此时监听线程会从 <mark style="background: #ABF7F7A6;">tomcat 的线程池中取出一个线程执行用户请求</mark>，在我们的服务部署到 tomcat 后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的 controller，service，dao 中，并且访问对应的 DB，在用户执行完请求后，再统一返回，再找到 tomcat 端的 socket，再将数据写回到用户端的 socket，完成请求和响应
> 通过以上讲解，我们可以得知<mark style="background: #ABF7F7A6;"> 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的</mark>， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用<mark style="background: #ABF7F7A6;">threadlocal来做到线程隔离</mark>，每个线程操作自己的一份数据
> 

![[1653068874258.png]]

> [!NOTE] 用户脱敏
> - 通常前端从后端获取用户信息，<mark style="background: #ABF7F7A6;">不需要获取全部用户信息，而且一些关于用户的隐私信息不应该暴露出去</mark>，这时就需要对用户信息进行脱敏，返回少量必要的信息即可，用户脱敏信息用另外的 DTO 对象来保存
```java
//将用户脱敏的信息保存到session中  
session.setAttribute("user", BeanUtil.copyProperties(user, UserDTO.class));
```

> [!NOTE] 登录拦截器
```java
public class LoginInterceptor implements HandlerInterceptor {  
  
    /**  
     * 前置拦截器  
     * @param request  
     * @param response  
     * @param handler  
     * @return  
     * @throws Exception  
     */  
    @Override  
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  
        HttpSession session = request.getSession();  
        //判断用户是否存在  
        UserDTO user = (UserDTO) session.getAttribute("user");  
        if(Objects.isNull(user)){  
            return false;  
        }        //用户存在，将用户信息保存到ThreadLocal中  
        UserHolder.saveUser(user);  
        return true;  
    }  
}
```

> [!NOTE] 在 SpringMVC 配置类中添加自定义的拦截器
```java
@Configuration  
public class WebMVCConfig implements WebMvcConfigurer {  
    @Override  
    public void addInterceptors(InterceptorRegistry registry) {  
        //添加登录拦截器  
        registry.addInterceptor(new LoginInterceptor())  
                //设置不用拦截的路径  
                .excludePathPatterns(  
                        "/user/code",  
                        "/user/login",  
                        "/blog/hot",  
                        "/shop/**",  
                        "/shop-type/**",  
                        "/upload/**",  
                        "/voucher/**"  
                );  
    }  
}
```
#### 登录校验
当你完成了上述操作之后去登录，你会发现登录之后还是跳转回登录界面，因为还没有做登录校验功能，就是将用户信息返回给前端

> [!NOTE] Controller 层
```java
@GetMapping("/me")  
public Result me(){  
    UserDTO user = UserHolder.getUser();  
    return Result.ok(user);  
}
```
>之前一只不知道前端是通过这个接口获取用户信息，我还以为登陆成功后直接返回用户信息😭，之后前端获取用户信息都可以访问这个接口

#### Session 集群共享问题
- **什么是 session 集群共享问题**：
	- 在分布式集群环境中，会话共享是一个常见的挑战，默认情况下，<mark style="background: #ABF7F7A6;">web 程序的会话是保存在单个服务器下</mark>，因为集群环境下存在多个服务器，用户不可能一只访问一个服务器，当用户访问其他服务器时，会话信息将无法访问
- **Session 集群共享问题造成哪些影响**：
	- 服务器之间无法实现会话状态的共享，比如：在当前这个服务器上用户已经完成了登录，将用户信息存储到 session 中，能够判断用户是否已经登录，但是在另一个服务器中没有对应的 session 信息，用户访问时将显示未登录状态
- **如何解决 session 集群共享问题**：
	- 方案一：<mark style="background: #BBFABBA6;">session 拷贝</mark>（不推荐）
		- Tomcat 提供 session 拷贝的功能，通过配置 Tomcat 可以实现 session 的拷贝，但是这会增加服务器内存的额外开销，同时会带来数据一致性问题
	- 方案二：<mark style="background: #FF5582A6;">Redis 缓存</mark>（推荐）
		- Redis 缓存具有 session 一样的特点，基于内存，存储结构是 key-value 结构，数据共享
- **Redis 相较于传统 session 存储的优点**：
	- <mark style="background: #ABF7F7A6;">高性能和可伸缩性</mark>：Redis 是一个内存数据库，具有快速的读写能力。相比于传统的 Session 存储方式，将会话数据存储在 Redis 中可以大大提高读写速度和处理能力。此外，Redis 还支持集群和分片技术，可以实现水平扩展，处理大规模的并发请求。
	- <mark style="background: #ABF7F7A6;">可靠性和持久性</mark>：Redis 提供了持久化机制，可以将内存中的数据定期或异步地写入磁盘，以保证数据的持久性。这样即使发生服务器崩溃或重启，会话数据也可以被恢复。
	- <mark style="background: #ABF7F7A6;">丰富的数据结构</mark>：Redis 不仅仅是一个键值存储数据库，它还支持多种数据结构，如字符串、列表、哈希、集合和有序集合等。这些数据结构的灵活性使得可以更方便地存储和操作复杂的会话数据。
	- <mark style="background: #ABF7F7A6;">分布式缓存功能</mark>：Redis 作为一个高效的缓存解决方案，可以用于缓存会话数据，减轻后端服务器的负载。与传统的 Session 存储方式相比，使用 Redis 缓存会话数据可以大幅提高系统的性能和可扩展性。
	- <mark style="background: #ABF7F7A6;">可用性和可部署性</mark>：Redis 是一个强大而成熟的开源工具，有丰富的社区支持和活跃的开发者社区。它可以轻松地与各种编程语言和框架集成，并且可以在多个操作系统上运行。
### 基于 Redis 实现短信验证码登录
![[1653319474181.png]]
基于前面的分析，Redis 显然是要优于 session 的，但是 Redis 中有很多数据结构，我们应该选用哪种数据结构呢？
- 很显然验证码使用 String 类型，并给验证码设置 TTL 存活时间
- 用户信息既可以使用 String 类型，也可以使用 hash 类型，这里推荐使用 Hash 类型

> [!NOTE] Hash 结构与 String 结构的比较
> - String 结构是以 JSON 格式保存用户信息，更加直观，操作也更加方便，JSON 会有很多非必要的内存开销，比如引号，大括号
> - Hash 结构是以字典的形式进行保存，内存开销更小，最重要的是方便对单个字段的 CRUD, 更加灵活


> [!NOTE] Redis 替代 session 需要考虑的问题
> - 选择合适的数据结构，了解 String 和 Hash 的区别
> - 选择合适的 key，为 key 设置一个业务前缀，方便区分和分组，为 key 拼接一个 UUID, 防止 key 相同对数据进行覆盖
> - 选择合适的存储粒度，对于验证码这类数据，一般设置 TTL 为3min 即可，防止大量缓存数据的堆积，而对于用户信息这类数据可以稍微设置长一点，比如30min，防止频繁对Redis进行IO操作
#### 短信验证登录
***
>可以将存储在 Redis 中的 key 的业务前缀设置为常量，这样可以简化开发，看起来更优雅，<mark style="background: #ABF7F7A6;">可以将常量设置在接口类中，因为接口中的变量都默认为常量
</mark>
```java
@Resource  
private StringRedisTemplate stringRedisTemplate;  
/**  
 * 发送验证码  
 * @param phone 手机号码  
 * @param session 会话  
 * @return  
 */  
@Override  
public Result sendCode(String phone, HttpSession session) {  
    //检验手机号是否合法  
    if(RegexUtils.isPhoneInvalid(phone)){  
        return Result.fail("手机号格式不正确");  
    }    //手机号合法，生成验证码保存到redis中  
    String code= RandomUtil.randomNumbers(6);//生成6位随机字符数字     
	stringRedisTemplate.opsForValue().
		set(LOGIN_CODE_KEY+phone,code,LOGIN_CODE_TTL, TimeUnit.MINUTES);  
    //发送验证码  
    log.info("验证码：{}", code);  
    return Result.ok();  
}  
  
/**  
 * 登录功能  
 * @param loginFormDTO 登录表单  
 * @param session 会话  
 * @return  
 */  
@Override  
public Result login(LoginFormDTO loginFormDTO, HttpSession session) {  
    String phone= loginFormDTO.getPhone();  
    String webCode=loginFormDTO.getCode();  
    //判断手机号是否合法  
    if(RegexUtils.isPhoneInvalid(phone)){  
        return Result.fail("手机号不合法");  
    }    //判断验证码是否正确  
    String code = (String) session.getAttribute("code");  
    if(code==null||!webCode.equals(code)){  
        return Result.fail("验证码不正确");  
    }    //判断手机号是否已经注册过  
    User user = this.getOne(new LambdaQueryWrapper<User>().eq(User::getPhone, phone));  
    if(Objects.isNull(user)){  
        //用户不存在，注册  
        user = createUserWithPhone(phone);  
    }    //将用户脱敏的信息保存到redis中  
    UserDTO userDTO=BeanUtil.copyProperties(user, UserDTO.class);  
    //将对象中的属性全部转换为String类型  
    Map<String, Object> map = BeanUtil.beanToMap(userDTO, new HashMap<>(), CopyOptions.create()
    .setIgnoreNullValue(true)  
        .setFieldValueEditor((filedName, filedValue) -> filedValue.toString())); 
    String token = UUID.randomUUID().toString();  
    String tokenKey=LOGIN_USER_KEY+token;  
    stringRedisTemplate.opsForHash().putAll(tokenKey, map);  
    //设置TTL存活时间  
    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);  
    return Result.ok(token);  
}  
  
/**  
 * 根据手机号创建用户  
 * @param phone  
 * @return  
 */  
private User createUserWithPhone(String phone){  
    User user=new User();  
    user.setPhone(phone);  
    user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomString(10));  
    this.save(user);  
    return user;  
}
```

> [!warning] 注意
> - 要将 token 返回给前端，要不然后面获取 token 为空😭

#### 配置刷新 token 的拦截器
![[1653320764547.png]]

> [!NOTE] 单独配置一个拦截器刷新 redis 中的用户信息
> 在基于 session 实现短信验证码登录时，我们只配置了一个拦截器，这里需要再配置一个拦截器拦截所有访问路径，<mark style="background: #ABF7F7A6;">用于刷新 Redis 中用户信息</mark>，因为用户信息是存放在 Redis 当中并设置了 TTL 超时时间，如果我们访问网站时 TTL 时间突然到期了，就会导致强制下线，影响用户体验，<mark style="background: #ABF7F7A6;">而且用户信息可能更改，要及时的获取最新的用户信息</mark>。那为什么不把刷新的操作放到一个拦截器中呢，因为之前的那个拦截器只是用来拦截一些需要进行登录校验的请求，对于哪些不需要登录校验的请求是不会走拦截器的，刷新操作显然是要针对所有请求比较合理，所以单独创建一个拦截器拦截一切请求，刷新Redis中的Key


> [!NOTE] 刷新 token 拦截器
```java
public class RefreshTokenInterceptor implements HandlerInterceptor {  
    //new出来的对象无法注入到IoC容器中  
    private StringRedisTemplate stringRedisTemplate;  
    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate){  
        this.stringRedisTemplate=stringRedisTemplate;  
    }  
  
    /**  
     * 前置拦截器  
     * @param request  
     * @param response  
     * @param handler  
     * @return  
     * @throws Exception  
     */  
    @Override  
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  
        //获取token，并判断token是否存在  
        String token = request.getHeader("authorization");  
        if(StrUtil.isBlank(token)){  
            //用户未登录  
            return true;  
        }        
        String userKey=LOGIN_USER_KEY+token;  
        //获取最新的用户信息  
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(userKey);//entries获取所有键值对  
        if(userMap.isEmpty()){  
            return true;  
        }        //用户信息存在，将用户信息保存到ThreadLocal中  
        UserDTO userDTO= BeanUtil.fillBeanWithMap(userMap,new UserDTO(),false);  
        UserHolder.saveUser(userDTO);  
        //刷新有效期  
        stringRedisTemplate.expire(userKey, LOGIN_USER_TTL, TimeUnit.MINUTES);  
        return true;  
    }  
}
```

<mark style="background: #FFB86CA6;">>如果 token 为空或者 userMap 为空是否可以直接返回 false 进行拦截？</mark>
>答案是否定的，因为存在一些访问路径不需要用户信息，比如/user/login, 如果进行拦截会造成功能上的阻碍

> [!NOTE] 登录拦截器
```java
public class LoginInterceptor implements HandlerInterceptor {  
  
    /**  
     * 前置拦截器  
     * @param request  
     * @param response  
     * @param handler  
     * @return  
     * @throws Exception  
     */  
    @Override  
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  
        if(UserHolder.getUser()==null){  
            response.setStatus(HttpStatus.HTTP_UNAUTHORIZED);  
            return false;  
        }        
        return true;  
    }  
}
```

> [!NOTE] SpringMVC 配置类
```java
@Configuration  
public class WebMVCConfig implements WebMvcConfigurer {  
    @Resource  
    private StringRedisTemplate stringRedisTemplate;  
    @Override  
    public void addInterceptors(InterceptorRegistry registry) {  
        //添加登录拦截器  
        registry.addInterceptor(new LoginInterceptor())  
                //设置不用拦截的路径  
                .excludePathPatterns(  
                        "/user/code",  
                        "/user/login",  
                        "/blog/hot",  
                        "/shop/**",  
                        "/shop-type/**",  
                        "/upload/**",  
                        "/voucher/**"  
                ).order(1);  
        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate))  
                .addPathPatterns("/**").order(0);  
    }  
}
```
**order 可以设置拦截器的执行顺序，数值越小越先执行**

## 商户查询缓存
- **什么是缓存？**
>缓存就是数据交换的缓冲区，是存储数据的临时地方，一般读写性能较高

- **为什么使用缓存？**
>缓存数据存储在内存当中，内存的读写性能远高于磁盘，缓存可以大大降低用户并发访问带给服务器的压力
![[image-20220523214414123.png]]
### 根据 id 查询商户缓存
![[1653322097736.png]]

<mark style="background: #FFB86CA6;">将商户信息保存在 Redis 当中应该选用哪种数据结构来保存？</mark>
- Hash 类型
- <mark style="background: #ABF7F7A6;">String 类型</mark>
推荐使用 String 类型，使用 Hash 类型转换太麻烦，使用 String 类型序列化为 JSON 字符串，方便存储

> [!NOTE] Controller 层
```java
@GetMapping("/{id}")  
public Result queryShopById(@PathVariable("id") Long id) {  
    return shopService.queryById(id);  
}
```

> [!NOTE] Service 层
```java
public Result queryById(Long id) {  
    String shopKey=CACHE_SHOP_KEY+id.toString();  
    //根据key查询商户信息  
    String shopJson = stringRedisTemplate.opsForValue().get(shopKey);  
    Shop shop=null;  
    //判断缓存是否命中  
    if(StrUtil.isNotBlank(shopJson)){  
        //缓存命中  
        shop = JSONUtil.toBean(shopJson, Shop.class);  
        return Result.ok(shop);  
    }    //缓存未命中，从数据库中查询  
    shop = this.getById(id);  
    //判断是否为空  
    if(Objects.isNull(shop)){  
        return Result.fail("店铺不存在");  
    }    //将店铺信息存入Redis中  
    shopJson = JSONUtil.toJsonStr(shop);  
    stringRedisTemplate.opsForValue().set(shopKey, shopJson);  
    return Result.ok(shop);  
}
```

> [!NOTE] Hutool 库常用方法
> - `JSONUtil.toBean(jsonString,Object.class)`: 将 JSON 字符串反序列化为指定对象
> - `JSONUtil.toJsonStr(object)`: 将指定对象序列化为 JSON 字符串
> - `BeanUtil.fillBeanWithMap(map,object,false)`: 将 map 集合转为实体对象
> - `BeanUtil.beanToMap(userDTO, new HashMap<>(), CopyOptions.create().setIgnoreNullValue(true).setFieldValueEditor ((filedName, filedValue) -> filedValue.ToString ())) `：将实体类对象转换为 map 集合，并将属性全部转为 String 类型
> - `StrUtil.isBlank(object)`: 判断一个对象是否为 null 或者是空字符串
> - `UUID.randomUUID().toString(true)`: 生成 UUID
> - `RandomUtil.randomNumbers(6)`: 生成指定长度的数字
### 查询店铺类型
对于店铺类型数据，一般变动会比较小，所以这里我们直接将店铺类型的数据持久化存储到 Redis中

> [!NOTE] Controller 层
```java
@RestController  
@RequestMapping("/shop-type")  
public class ShopTypeController {  
    @Resource  
    private IShopTypeService typeService;  
    @GetMapping("list")  
    public Result queryTypeList() {  
        return typeService.queryTypeList();  
    }  
}
```

> [!NOTE] Service 层
```java
@Service  
public class ShopTypeServiceImpl extends ServiceImpl<ShopTypeMapper, ShopType> implements IShopTypeService {  
  
    @Resource  
    private StringRedisTemplate stringRedisTemplate;  
    /**  
     * 查询商户类型  
     * @return  
     */  
    @Override  
    public Result queryTypeList() {  
        String shopTypeKey = CACHE_SHOP_TYPE_KEY；
        String shopTypeJson = stringRedisTemplate.opsForValue().get(shopTypeKey);  
        List<ShopType> shopTypes=null;  
        if(StrUtil.isNotBlank(shopTypeJson)){  
            shopTypes = JSONUtil.toList(shopTypeJson, ShopType.class);  
            return Result.ok(shopTypes);  
        }        //缓存中不存在商户类型，查询数据库  
        shopTypes = this.list(new LambdaQueryWrapper<ShopType>().orderByAsc(ShopType::getSort));  
        if (Objects.isNull(shopTypes)) {  
            return Result.fail("店铺类型不存在");  
        }        //店铺数据存在，写入Redis  
        stringRedisTemplate.opsForValue().set(shopTypeKey, JSONUtil.toJsonStr(shopTypes), CACHE_SHOP_TTL, TimeUnit.MINUTES);  
        return Result.ok(shopTypes);  
    }  
}
```

> [!warning] 注意
> 有很多人给店铺类型的 key 后面加了一串 UUID, 这肯定是不能加的，每次访问都能生成不同的 UUID，缓存永远查询不到，商户类型一般很少改变，直接固定一个 key 就行，如果改变了就将缓存删掉重新加载即可

![[Pasted image 20240122173049.png]]
### 数据一致性问题
>缓存的使用<mark style="background: #ABF7F7A6;">降低了后端负载，提高了读写的效率，降低了响应的时间</mark>，这么看来缓存是不是就一本万利呢？答案是否定的！并不是说缓存有这么多优点项目中就可以无脑使用缓存了，我们还需要考虑缓存带来的问题，比如：缓存的添加<mark style="background: #FF5582A6;">提高了系统的维护成本，同时也带来了数据一致性问题</mark>……总的来讲，系统使用引入缓存需要经过前期的测试、预算，判断引入缓存后带来的价值是否会超过引入缓存带来的代价

那么我们该如何解决<mark style="background: #ABF7F7A6;">数据一致性问题</mark>呢？首先我们需要明确数据一致性问题的主要原因是什么，从主要原因入手才是解决问题的关键！数据一致性的根本原因是 <mark style="background: #FF5582A6;">缓存和数据库中的数据不同步</mark>，那么我们该如何让缓存和数据库中的数据尽可能的即时同步？这就需要选择一个比较好的**缓存更新策略**了

> [!NOTE] 常见的缓存更新策略
> - <mark style="background: #BBFABBA6;">内存淘汰（全自动）</mark>：利用 Redis 的<mark style="background: #FFB8EBA6;">内存淘汰机制</mark>实现缓存更新，Redis 的内存淘汰机制是当 Redis 发现内存不足时，自动采用一定的策略淘汰部分数据
> - <mark style="background: #BBFABBA6;">超时剔除（半自动）</mark>：手动给缓存数据添加 TTL 生存时间，到期之后 Redis 自动删除
> - <mark style="background: #BBFABBA6;">主动更新（手动）</mark>：手动编码实现缓存更新，在修改数据库的同时更新缓存👍
> 	- <mark style="background: #FF5582A6;">双写方案</mark>：人工编码方式，缓存调用者在更新完数据库后再去更新缓存，使用困难，灵活度高
> 		- **读取**：当需要读取数据时，首先检查缓存中是否存在该数据，如果缓存中存在，直接返回缓存中的数据。如果缓存中不存在，则从底层数据库中读取数据，并将数据保存至缓存中，方便下次读取时直接从缓存中读取，提高性能
> 		- **写入**：当进行数据写入操作时，首先更新底层数据库中的数据，然后根据具体情况，可以选择直接更新缓存中的数据，或者是简单的将缓存中与修改的数据相关条目标记为无效状态，在下次读取时在更新缓存
> 		- 使用<mark style="background: #FFB86CA6;">更新缓存模式</mark>还是<mark style="background: #FFB86CA6;">删除缓存模式</mark>？
> 			- [ ] **更新缓存模式**：每次更新数据库都更新缓存，无效写操作较多（假设我们执行上百万次数据库更新操作，那么就要执行上百万次写入缓存操作，然而查询请求并没有这么多）
> 			- [x] **删除缓存模式**：每次更新数据库时顺便删除缓存中对应的数据，等下一次查询时再从数据库中写入到缓存中，无效写较少（推荐使用）
> 				- 使用删除缓存模式，那么是<mark style="background: #FFB86CA6;">先操作缓存还是操作数据库</mark>？
> 				- [ ] **先删除缓存，再更新数据库**：当线程 1 删除缓存到更新数据库之间的时间段，会有其他线程访问数据，由于缓存已经被删除，导致大量的查询请求打到数据库上，给数据库带来巨大压力，因为缓存删除很快，但数据库更新耗时较长，在更新数据库这段时间内会有其他请求的不断访问。存在缓存击穿问题，而且概率较大
> 				- [x] **先更新数据库，再删除缓存**：当线程 1 查询缓存且没有命中时，去查询数据库，查询完准备写入缓存时，线程 2 在这期间对数据库做了更新操作，此时线程 1 将旧数据返回，此时就出现了脏读，这个事件出现的概率很小，因为要首先满足缓存未命中，且在写入缓存的期间有一个数据库更新操作，缓存更新时间空隙很小，所以出现脏读的概率也比较小
> 				- 选择先更新数据库，再删除缓存，如何<mark style="background: #FFB86CA6;">保证缓存与数据库操作之间的原子性</mark>？
> 				- [x] 对于单体系统，将缓存与数据库操作放在同一个事务当中
> 				- [ ] 对于分布式系统，利用 TCC 等分布式方案
> 	- <mark style="background: #FF5582A6;">读写穿透方案</mark>：将读取和写入操作首先在缓存中执行，然后再传播到数据库存储
> 		- **读取穿透**：当进行读取请求时，首先检查缓存，如果缓存中存在，则直接返回，如果缓存中没有，则将请求转发给数据库，获取到数据后存储在缓存中，然后返回给调用者
> 		- **写入穿透**：当进行写入操作时，首先将数据写入缓存中，然后再将写操作传递给数据库进行数据库写入，保持缓存和数据库数据的一致性
> 	- <mark style="background: #FF5582A6;">写回方案</mark>：调用者只操作缓存，其他线程异步处理数据库操作，完成读写一致性
> 			- **读取**：先检查缓存中是否存在对应数据，如果不存在，则将请求转发给数据库进行查询，将查询到的数据保存至缓存
> 			- **写入**：先更新缓存数据，然后将待写入的数据放入一个缓存队列，在适当时机，通过批量操作或异步处理，将缓存队列中的数据写入到底层数据库中

![[1653322506393.png]]

- 主动更新策略中三种方案的比较：
	- **双写方案**和**读写穿透方案**在写入数据时都会直接更新缓存，以保持缓存和底层数据存储的一致性。而**写回方案**延迟了缓存的更新操作，将数据先放入缓存队列，然后再进行批量或异步写入。
	- **读写穿透方案**和**写回方案**相比，写回方案具有更高的写入性能，因为它<mark style="background: #ABF7F7A6;">通过批量和异步操作减少了频繁的写入操作</mark>。但是 写回方案 带来了数据一致性的考虑，需要确保缓存和底层数据存储在某个时间点上保持一致，而 读写穿透方案 将数据库和缓存整合为一个服务，由服务来维护缓存与数据库的一致性，调用者无需关心数据一致性问题，降低了系统的可维护性，但是实现困难
- 主动更新策略中三种方案的应用场景：
	- **双写方案** 较适用于读多写少的场景，数据的一致性由应用程序主动管理
	- **读写穿透方案** 适用于数据实时性要求较高、对一致性要求严格的场景
	- **写回方案** 适用于追求写入性能的场景，对数据的实时性要求相对较低、可靠性也相对低
- 更新策略的应用场景：
	- 对于低一致性需求，可以使用内存淘汰机制。例如店铺类型数据的查询缓存
	- 对于高一致性需求，可以采用主动更新策略，<mark style="background: #ABF7F7A6;">并以超时剔除作为兜底方案</mark>。例如店铺详情数据查询的缓存
![[1653322857620.png]]
### 实现商铺缓存与数据库双写一致
>在启动类添加 `@EnableTransactionManagement` 注解开启事务

**思路**
- 使用缓存主动更新策略中的<mark style="background: #ABF7F7A6;">双写方案</mark>（采用删除模式，先更新数据库再删除缓存，同时添加事务保证原子性）
- 根据 id 查询店铺缓存，如果命中则直接返回，如果未命中，则查询数据库，将数据库数据保存至缓存中，并设置 TTL 超时时间（超时剔除兜底）
- 根据 id 修改店铺信息，首先修改数据库中的数据，然后删除缓存中关于店铺的信息

> [!NOTE] 根据 id 查询店铺
```java
public Result queryById(Long id) {  
    String shopKey=CACHE_SHOP_KEY+id.toString();  
    //根据key查询商户信息  
    String shopJson = stringRedisTemplate.opsForValue().get(shopKey);  
    Shop shop=null;  
    //判断缓存是否命中  
    if(StrUtil.isNotBlank(shopJson)){  
        //缓存命中  
        shop = JSONUtil.toBean(shopJson, Shop.class);  
        return Result.ok(shop);  
    }    //缓存未命中，从数据库中查询  
    shop = this.getById(id);  
    //判断是否为空  
    if(Objects.isNull(shop)){  
        return Result.fail("店铺不存在");  
    }    //将店铺信息存入Redis中  
    shopJson = JSONUtil.toJsonStr(shop);  
    stringRedisTemplate.opsForValue().set(shopKey, shopJson,CACHE_SHOP_TTL, TimeUnit.MINUTES);  
    return Result.ok(shop);  
}
```

### 缓存穿透解决方案
>缓存穿透是指客户端的请求数据在缓存和数据库中都不存在，这样缓存永远不会生效，请求会直接打到数据库上，如果在同一时间大量的无效请求打在数据库上，可能会造成数据库无法承受压力导致崩溃

![[缓存击穿.excalidraw]]

> [!NOTE] 常见的缓存穿透解决方案
> - <mark style="background: #ABF7F7A6;">缓存空对象</mark>
> 	- 优点：实现简单，方便维护
> 	- 缺点：额外内存消耗，可能造成短期不一致
> - <mark style="background: #ABF7F7A6;">布隆过滤</mark>
> 	- 优点：内存占用少，没有多余的 key
> 	- 缺点：实现复杂，可能存在误判
> - 上面两种都是被动解决缓存穿透的方案，此外我们可以采用主动的方案预防缓存穿透，比如：<mark style="background: #FF5582A6;">增强 id 的复杂度避免被猜测 id 规律，做好数据的基础校验格式，加强用户权限验证，做好热点参数限流</mark>
![[1653326156516.png]]
#### 编码解决店铺信息缓存穿透问题
**思路**
- 我们采用<mark style="background: #ABF7F7A6;">缓存空对象</mark>解决缓存穿透问题
- 根据 id 查询店铺缓存信息，如果存在则直接返回，不存在就去查询数据库，如果数据库中存在，就将店铺信息写入到缓存中，<mark style="background: #ABF7F7A6;">如果数据库中不存在，则将空字符串存入缓存中，等到下次相同的无效请求时，直接返回缓存中的空值</mark>
- 如果此次请求的数据不在数据库当中，但是过一段时间后向数据库中新增了对应请求的数据，那么再次发送请求获取数据还是为空值，造成数据的不一致性，这时候就给存入的空值设置 TTL 超时时间
![[1653327124561.png]]

> [!NOTE] 缓存穿透解决方案
```java
public Result queryById(Long id) {  
    String shopKey=CACHE_SHOP_KEY+id.toString();  
    //根据key查询商户信息  
    String shopJson = stringRedisTemplate.opsForValue().get(shopKey);  
    Shop shop=null;  
    //判断缓存是否命中  
    if(StrUtil.isNotBlank(shopJson)){  
        //缓存命中  
        shop = JSONUtil.toBean(shopJson, Shop.class);  
        return Result.ok(shop);  
    }    
    //判断缓存数据是否是空字符串  
    if("".equals(shopJson)){  
        return Result.fail("店铺不存在");  
    }    
    //缓存未命中，从数据库中查询  
    shop = this.getById(id);  
    //判断是否为空  
    if(Objects.isNull(shop)){  
    //缓存空对象
        stringRedisTemplate.opsForValue().set(shopKey, "", CACHE_NULL_TTL, TimeUnit.MINUTES);  
        return Result.fail("店铺不存在");  
    }    
    //将店铺信息存入Redis中  
    shopJson = JSONUtil.toJsonStr(shop);  
    stringRedisTemplate.opsForValue().set(shopKey, shopJson,CACHE_SHOP_TTL, TimeUnit.MINUTES);  
    return Result.ok(shop);  
}
```
![[Pasted image 20240122220123.png]]
![[Pasted image 20240122220312.png]]
![[Pasted image 20240122220356.png]]
再次访问相同的店铺 id, 如果控制台没有出现任何数据说明成功 (没有查询数据库，直接返回缓存中的空对象)

> [!warning] 注意
> 判断缓存中的数据是否是空字符串时一定要用 equals 方法，否则永远不会相等😂
### 缓存雪崩解决方案
>缓存雪崩是指在同一时间段大量的 key 同时失效或者 Redis 宕机，导致大量的请求达到底层数据库上，给数据库造成巨大压力


> [!NOTE] 常见的缓存雪崩解决方案
> - 给不同的 key 的 TTL 添加随机值
> - 利用 Redis 集群提高服务的可用性
> - 给缓存业务添加降级限流策略
> - 给业务添加多级缓存
> ![[1653327884526.png]]

### 缓存击穿解决方案
>缓存击穿也叫热点 key 问题，就是一个被高并发访问且缓存重建过程较复杂的 key 突然失效，导致大量请求打到底层数据库，造成巨大压力

逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法，那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大
![[1653328022622.png]]

> [!NOTE] 解决缓存击穿常见方案
> - <mark style="background: #FF5582A6;">互斥锁</mark>（时间换空间）
> 	- 优点：内存占用小，一致性高，实现简单
> 	- 缺点：性能较低，容易出现死锁
> - <mark style="background: #FF5582A6;">逻辑过期</mark>（空间换时间）
> 	- 优点：性能高
> 	- 缺点：内存占用较大，容易出现脏读
> - 两者相比较，互斥锁更加易于实现，但是容易发生死锁，且锁导致并行变成串行，导致系统性能下降，逻辑过期实现起来相较复杂，且需要耗费额外的内存，但是通过开启子线程重建缓存，使原来的同步阻塞变成异步，提高系统的响应速度，但是容易出现脏读
> - ![[1653328288627.png]]
> - ![[1653328663897.png]]
#### 基于互斥锁解决缓存击穿问题
**思路**：
- 以前是如果缓存查询不到，就直接查询数据库，如果在同一时间段内大量请求查询缓存，就会导致大量的请求查询不到缓存而去查询数据库，造成缓存击穿问题
- 现在是利用互斥锁，如果一个线程缓存未查询到，就获取一个互斥锁去重建缓存，缓存重建成功之后释放锁，其他线程想要访问数据库时会被互斥锁阻塞，直到互斥锁释放
- 注意：每个线程获取锁成功之后要再查询一遍缓存，因为有可能是其他线程已经完成了重建缓存的工作才释放的锁，这时当前线程就不要再去查询数据库了，直接查询缓存
- 这里使用 Redis 中的 `setnx` 指令实现互斥锁，只有当值不存在时才可以进行 `set` 操作
- 如果发生死锁怎么办，<mark style="background: #ABF7F7A6;">锁可以设置一个有效期</mark>，有效期的时长根具体业务有关
- 一个线程未获取到锁也不能一直频繁地获取锁，必须要休眠一段时间再去获取锁，否则对 CPU 造成无效损耗
- 要及时释放锁，把释放锁的操作一定要放在 finally 中，防止发生异常导致锁释放不及时（TTL 时间过期自动释放）
![[1653357860001.png]]

> [!NOTE] 基于互斥锁解决缓存击穿
```java
public Result queryById(Long id) {  
    String shopKey=CACHE_SHOP_KEY+id;  
    String lockKey=LOCK_SHOP_KEY+id;  
    Result result = getShopFromCache(shopKey);  
    if(result!=null){//result不为空，说明缓存查询到了，直接返回  
        return result;  
    }    
    try {  
        //缓存未命中，获取互斥锁  
        boolean isLock = tryLock(lockKey);//解决缓存击穿问题  
        if(!isLock){//获取锁失败，等待锁释放  
            Thread.sleep(50);  
            return queryById(id);  
        }  
        //获取锁成功，重新查询缓存  
        result = getShopFromCache(shopKey);  
        if(result!=null){  
            return result;  
        }  
        //缓存还是为空，查询数据库  
        Shop shop=null;  
        shop = this.getById(id);  
        //判断是否为空  
        if(Objects.isNull(shop)){//解决缓存穿透问题  
            stringRedisTemplate.opsForValue().set(shopKey, "", CACHE_NULL_TTL, TimeUnit.MINUTES);  
            return Result.fail("店铺不存在");  
        }  
        //将店铺信息存入Redis中  
        String shopJson = JSONUtil.toJsonStr(shop);  
        stringRedisTemplate.opsForValue().set(shopKey, shopJson,CACHE_SHOP_TTL, TimeUnit.MINUTES);  
        return Result.ok(shop);  
    } catch (InterruptedException e) {  
        throw new RuntimeException(e);  
    } finally {  
        //释放锁  
        unlock(lockKey);  
    }}  
  
/**  
 * 从缓存中获取店铺信息  
 * @param key  
 * @return  
 */  
private Result getShopFromCache(String key){  
    //根据key查询商户信息  
    String shopJson = stringRedisTemplate.opsForValue().get(key);  
    Shop shop=null;  
    //判断缓存是否命中  
    if(StrUtil.isNotBlank(shopJson)){  
        //缓存命中  
        shop = JSONUtil.toBean(shopJson, Shop.class);  
        return Result.ok(shop);  
    }    //判断缓存数据是否是空字符串  
    if("".equals(shopJson)){  
        return Result.fail("店铺不存在");  
    }    return null;  
}
/**  
 * 获取互斥锁  
 * @param key  
 * @return  
 */  
private boolean tryLock(String key){  
    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", LOCK_SHOP_TTL, TimeUnit.SECONDS);//当key不存在时才可以设置值，返回true  
    return BooleanUtil.isTrue(flag);//拆箱要做非空判断，如果不为true的话就返回false  
}  
  
/**  
 * 释放锁  
 * @param key  
 */  
private void unlock(String key){  
    stringRedisTemplate.delete(key);  
}
```

**测试**：
- 通过 Jmeter 测试，5 秒内发送 2000 个请求（**qps** 高达 400，每秒发送 400 个请求），最终**吞吐量**是 340
![[Pasted image 20240123224211.png]]

> [!NOTE] 高并发性能指标
> - <mark style="background: #ABF7F7A6;">QPS</mark>: 每秒请求数
> - <mark style="background: #ABF7F7A6;">TPS</mark>: 每秒事务数，一个事务是指一个客户端页面向服务器发送请求然后服务器做出响应的<mark style="background: #FF5582A6;">过程</mark>。客户端在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。一个页面只能形成一个事务，但是一个页面中可以发送多个请求，也就是说一个事务中可能包含多个请求
> - <mark style="background: #ABF7F7A6;">RT</mark>: 响应时间，执行一个请求从开始到最后收到响应数据所花费的总体时间，即从客户端发起请求到收到服务器响应结果的时间。
> - <mark style="background: #ABF7F7A6;"> Concurrency</mark>：并发数，是指系统同时能处理的请求数量，这个也反应了系统的负载能力
> - <mark style="background: #ABF7F7A6;">吞吐量</mark>：系统吞吐量有几个重要指标参数：QPS（TPS）、并发数、响应时间，**QPS（TPS）= 并发数/平均响应时间**
#### 基于逻辑过期解决缓存击穿问题
>所谓逻辑过期，类似于逻辑删除，并不是真正意义上的过期，而是新增一个字段，用来标记 key 的过期时间，这样能够避免 key 过期而被自动删除，因为缓存击穿问题就是 key 过期造成大量请求打到了数据库上，从根本上解决了热点 key 问题，一般搞活动，比如抢优惠卷，秒杀场景等，请求量比较大时，就可以使用逻辑过期，等活动一过就可以删除逻辑过期字段

**思路**：
- 从 Redis 中查询店铺信息，判断是否过期，如果没有过期，就返回缓存信息
- 如果缓存信息过期了，就只需要一个线程去执行重建缓存工作（获取互斥锁），其他线程直接返回 Redis 中已经过期的数据（造成短期数据不一致）
- 获取到互斥锁的线程开启一个独立线程去异步更新缓存，当前线程也只需要返回 Redis 中的数据
- 最后不论是否执行成功一定要释放锁
![[1653360308731.png]]

> [!NOTE] 装载逻辑过期的工具类
```java
@Data  
public class RedisData {  
    private LocalDateTime expireTime;  
    private Object data;  
}
```

> [!NOTE] 基于逻辑过期解决缓存击穿问题
```java
private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);//创建线程池  
/**  
 * 逻辑过期解决缓存击穿问题  
 * @param id  
 * @return  
 */  
public Result queryById(Long id) {  
    String shopKey=CACHE_SHOP_KEY+id;  
    //根据key查询缓存  
    String shopJson = stringRedisTemplate.opsForValue().get(shopKey);  
    if(StrUtil.isBlank(shopJson)){//为空或者空字符串  
        return Result.fail("店铺不存在");  
    }    //查询到店铺信息，判断是否过期  
    //将shopJson反序列化为RedisData对象  
    RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);  
    JSONObject data = (JSONObject) redisData.getData();//需要将对象转换为哦JSONObject  
    Shop shop = JSONUtil.toBean(data, Shop.class);  
    //获取过期时间，判断过期时间是否在当前时间后面  
    LocalDateTime expireTime = redisData.getExpireTime();  
    if (expireTime.isAfter(LocalDateTime.now())) {  
        //没有过期，返回缓存数据  
        return Result.ok(shop);  
    }    //缓存数据过期，获取互斥锁重建缓存  
    String lockKey=LOCK_SHOP_KEY+id;  
    boolean isLock = tryLock(lockKey);  
    if(isLock){  
        //获取锁成功,开启子线程去重建缓存  
        CACHE_REBUILD_EXECUTOR.submit(()->{  
            try {  
                this.saveToCache(id, CACHE_SHOP_LOGICAL_TTL);  
            }finally {  
                this.unlock(lockKey);  
            }  
        });  
    }    
    //获取锁失败，重新查询缓存，可能缓存已经重建成功了  
    shopJson = stringRedisTemplate.opsForValue().get(shopKey);  
    if(StrUtil.isBlank(shopJson)){//为空或者空字符串  
        return Result.fail("店铺不存在");  
    }    
    //查询到店铺信息，判断是否过期  
    //将shopJson反序列化为RedisData对象  
    redisData = JSONUtil.toBean(shopJson, RedisData.class);  
    data = (JSONObject) redisData.getData();//需要将对象转换为哦JSONObject  
    shop = JSONUtil.toBean(data, Shop.class);  
    //获取过期时间，判断过期时间是否在当前时间后面  
    expireTime = redisData.getExpireTime();  
    if (expireTime.isAfter(LocalDateTime.now())) {  
        //没有过期，返回缓存数据  
        return Result.ok(shop);  
    }    //如果过期了，直接返回过期数据  
    return Result.ok(shop);  
}  
  
/**  
 * 保存信息到缓存  
 * @param id  
 * @param expireMinutes  
 */  
public void saveToCache(Long id,Long expireMinutes){  
    //根据id查询数据库  
    Shop shop = this.getById(id);  
    //封装逻辑过期时间  
    RedisData redisData = new RedisData();  
    redisData.setData(shop);  
    redisData.setExpireTime(LocalDateTime.now().plusMinutes(expireMinutes));  
    //将逻辑过期数据存入redis  
    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));  
}
/**  
 * 获取互斥锁  
 * @param key  
 * @return  
 */  
private boolean tryLock(String key){  
    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", LOCK_SHOP_TTL, TimeUnit.SECONDS);//当key不存在时才可以设置值，返回true  
    return BooleanUtil.isTrue(flag);//拆箱要做非空判断，如果不为true的话就返回false  
}  
  
/**  
 * 释放锁  
 * @param key  
 */  
private void unlock(String key){  
    stringRedisTemplate.delete(key);  
}
```

> [!warning] 注意
> 逻辑过期一定数据预热，所谓数据预热就是将我们的热点数据提前加入缓存中，因为逻辑过期前提保证数据具有永久性
```java
@Resource  
private IShopService shopService;  
@Test  
public void testSaveCache(){  
    shopService.saveToCache(1L, CACHE_SHOP_LOGICAL_TTL);  
}
```

> [!NOTE] 关于逻辑过期和缓存穿透问题
> 有的人可能会有疑惑，使用逻辑过期查询数据库信息保存到 Redis 中不用判断数据是否存在吗？不怕造成缓存穿透问题吗？
> 答案是肯定不会，因为要实现逻辑过期的前提是要进行数据预热，保证数据一定在数据库中，而且是热点数据，缓存穿透问题主要是查询的 key 在缓存和数据库中都不存在，那查询的 key 一定就不会是热点 key 了，不是热点 key 就可以直接返回店铺不存在信息，所以逻辑过期与缓存穿透问题不能相互存在，如果相互存在就形成一个悖论了😂

**测试**：
数据预热的时候逻辑过期时间设置短一点，等他的逻辑时间一过，我们修改数据库中数据，接着发送大量请求到指定接口
数据库修改之前 redis 中的数据
![[Pasted image 20240124183041.png]]

修改数据库中数据
![[Pasted image 20240124183206.png]]
向逻辑过期的缓存发送大量请求，看看出现多少脏读
- 缓存重建键之后 score 为 45
![[Pasted image 20240124184224.png]]
- 很遗憾的是没有脏读现象，所有请求的结果都是 45😥
![[Pasted image 20240124184520.png]]
![[Pasted image 20240124185920.png]]
### 缓存工具类封装

> [!NOTE] 基于 StringRedisTemplate 封装一个缓存工具类
> - **方法一**：将任意 java 对象序列化为 json 字符串并根据 key 存储在 String 类型的 Redis 中，还可以设置 TTL 时间
> - **方法二**：将任意 java 对象序列化为 json 字符串并根据 key 存储在 String 类型的 Redis 中，还可以设置逻辑过期时间，用于处理缓存击穿问题
> - **方法三**：根据指定的 key 查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题
> - **方法四**：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题

方法一和方法三负责常见的普通缓存，用于解决缓存穿透问题，方法二和方法四负责热点缓存，用于解决缓存击穿

> [!NOTE] ShopServiceImpl
```java
@Service  
public class ShopServiceImpl extends ServiceImpl<ShopMapper, Shop> implements IShopService {  
  
    @Resource  
    private StringRedisTemplate stringRedisTemplate;  
    @Resource  
    private  CacheClient cacheClient;  
  
    /**  
     * 根据商户id查询商户缓存,解决缓存穿透问题  
     *  
     * @param id  
     * @return  
     */  
    /*@Override    public Result queryById(Long id) {        Shop shop = cacheClient.handleCachePenetration(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_TTL, TimeUnit.MINUTES);        if(shop==null){            return Result.fail("店铺不存在");  
        }        return Result.ok(shop);    }*/  
    /**     * 逻辑过期解决缓存击穿问题  
     * @param id  
     * @return  
     */  
    public Result queryById(Long id) {  
        Shop shop = cacheClient.handleCacheBreakdown(CACHE_SHOP_KEY, id, Shop.class, this::getById, CACHE_SHOP_LOGICAL_TTL, TimeUnit.SECONDS);  
        if(shop==null){  
            return Result.fail("店铺不存在");  
        }        return Result.ok(shop);  
    }  
  
    /**  
     * 更新店铺信息，采用双写方案  
     * @param shop  
     * @return  
     */  
    @Override  
    @Transactional    
    public Result updateShop(Shop shop) {  
        //更新数据库中的数据  
        boolean f = this.updateById(shop);  
        if(!f){  
            //更新失败，抛出异常触发回滚  
            throw new RuntimeException("数据库更新失败");  
        }        //删除缓存  
        f = stringRedisTemplate.delete(CACHE_SHOP_KEY + shop.getId());  
        if(!f){  
            throw new RuntimeException("缓存删除失败");  
        }        
        return Result.ok();  
    }  
  
  
}
```

> [!NOTE] 缓存工具类
```java
@Component  
@Slf4j  
public class CacheClient {  
    private StringRedisTemplate stringRedisTemplate;  
    @Autowired  
    public CacheClient(StringRedisTemplate stringRedisTemplate){  
        this.stringRedisTemplate=stringRedisTemplate;  
    }  
  
    /**  
     * 将数据加入Redis中，并设置有效期  
     * @param key  
     * @param value  
     * @param timeout  
     * @param unit  
     */  
    public void set(String key, Object value,Long timeout,TimeUnit unit){  
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), timeout, unit);  
    }  
  
    /**  
     * 将数据加入Redis中，并设置逻辑过期时间  
     * @param key  
     * @param value  
     * @param timeout  
     * @param unit  
     */  
    public void setWithLogicalExpire(String key, Object value, Long timeout, TimeUnit unit) {  
        RedisData redisData = new RedisData();  
        redisData.setData(value);  
        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(timeout)));  
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));  
    }  
  
    /**  
     * 获取缓存信息，并解决缓存穿透问题  
     * @param keyPrefix  
     * @param id  
     * @param type  
     * @param dbFallback  
     * @param timeout  
     * @param unit  
     * @return  
     * @param <T>  
     * @param <ID>  
     */  
    public <T,ID> T handleCachePenetration(String keyPrefix, ID id, Class<T> type, Function<ID,T> dbFallback,Long timeout,TimeUnit unit){  
        String key=keyPrefix+id;  
        //从Redis中查询店铺信息  
        String jsonStr = stringRedisTemplate.opsForValue().get(key);  
        T t=null;  
        if(StrUtil.isNotBlank(jsonStr)){  
            t = JSONUtil.toBean(jsonStr, type);  
            return t;  
        }        if("".equals(jsonStr)){  
            return null;  
        }        t = dbFallback.apply(id);  
        if(t==null){  
            this.set(key, "", CACHE_NULL_TTL, TimeUnit.SECONDS);  
            return null;  
        }        //重建缓存  
        this.set(key,t,timeout,unit);  
        return t;  
    }  
  
    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);//创建线程池  
  
    public <T,ID> T handleCacheBreakdown(String keyPrefix,ID id,Class<T> type,Function<ID,T> dbFallback,Long timeout,TimeUnit unit){  
        String key=keyPrefix+id;  
        //从缓存中查询信息  
        String jsonStr = stringRedisTemplate.opsForValue().get(key);  
        if(StrUtil.isBlank(jsonStr)){  
            return null;  
        }        
        RedisData redisData = JSONUtil.toBean(jsonStr, RedisData.class);  
        JSONObject data = (JSONObject) redisData.getData();  
        T t = JSONUtil.toBean(data, type);  
        LocalDateTime expireTime = redisData.getExpireTime();  
        if (expireTime.isAfter(LocalDateTime.now())) {  
            return t;  
        }        //缓存已过期  
        String lockKey=LOCK_SHOP_KEY+id;  
        boolean isLock = tryLock(lockKey);  
        if(isLock){  
            try {  
                CACHE_REBUILD_EXECUTOR.submit(()->{  
                    //查询数据库  
                    T t1 = dbFallback.apply(id);  
                    this.setWithLogicalExpire(key, t1, timeout, unit);  
                });  
            }finally {  
                unlock(lockKey);  
            }  
        }  
        jsonStr = stringRedisTemplate.opsForValue().get(key);  
        if(StrUtil.isBlank(jsonStr)){  
            return null;  
        }        redisData = JSONUtil.toBean(jsonStr, RedisData.class);  
        data = (JSONObject) redisData.getData();  
        t = JSONUtil.toBean(data, type);  
        expireTime = redisData.getExpireTime();  
        if (expireTime.isAfter(LocalDateTime.now())) {  
            return t;  
        }        return t;  
    }  
    /**  
     * 获取互斥锁  
     * @param key  
     * @return  
     */  
    private boolean tryLock(String key){  
        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", LOCK_SHOP_TTL, TimeUnit.SECONDS);//当key不存在时才可以设置值，返回true  
        return BooleanUtil.isTrue(flag);//拆箱要做非空判断，如果不为true的话就返回false  
    }  
  
    /**  
     * 释放锁  
     * @param key  
     */  
    private void unlock(String key){  
        stringRedisTemplate.delete(key);  
    }  
}
```
### 小结
为了解决<mark style="background: #ABF7F7A6;">数据一致性问题</mark>，我们可以选择适当的缓存更新策略：
以**缓存主动更新**（双写方案+删除缓存模式+先操作数据库后操作缓存+事务）为主，**超时剔除为辅**
1. 查询时，先查询缓存，缓存命中直接返回，缓存未命中查询数据库并重建缓存，返回查询结果
2. 更新时，先修改数据删除缓存，<mark style="background: #ABF7F7A6;">使用事务保证缓存和数据操作两者的原子性</mark>
除了会遇到数据一致性问题意外，我们还会遇到<mark style="background: #FF5582A6;">缓存穿透、缓存雪崩、缓存击穿</mark>等问题
1. 对于缓存穿透，我们采用了<mark style="background: #FFB8EBA6;">缓存空对象</mark>解决
2. 对于缓存击穿，我们分别演示了<mark style="background: #FFB8EBA6;">互斥锁</mark>（ `setnx `实现方式）和<mark style="background: #FF5582A6;">逻辑过期</mark>两种方式解决
最后我们通过抽取出一个工具类，并且利用泛型编写几个通用方法，形成最终的形式
## 优惠卷秒杀
### 自增 ID 存在的问题
当用户抢购时，就会生成订单并保存到 `tb_voucher_order` 这张表中，而订单表如果使用数据库自增 ID
就存在一些问题：
- **Id 的规律性太过明显**，容易出现信息的泄露，被不怀好意的人伪造请求
- **受单表数据量的限制**，MySQL 中表能够存储的数据有限，会出现分库分表的情况，id 不能够一直自增

> [!NOTE] 当ID规律过于明显时，存在以下一些缺点
> - <mark style="background: #ABF7F7A6;">安全性问题</mark>：如果 ID 规律太明显，可能会使系统容易受到恶意攻击，例如暴力破解等。攻击者可以通过分析 ID 规律来推断出其他用户的 ID，从而进行未授权的访问或操纵。
> - <mark style="background: #ABF7F7A6;">隐私泄露风险</mark>：如果 ID 规律太明显，可能导致用户的个人信息或敏感数据被曝光。攻击者可以根据规律推测出其他用户的 ID，并通过这些 ID 获取到相应的数据，进而侵犯用户的隐私。
> - <mark style="background: #ABF7F7A6;">数据的可预测性</mark>：当 ID 规律太明显时，使用这些规律的攻击者可以很轻易地猜测出其他实体（如订单、交易等）的 ID。这可能破坏系统的数据安全性和防伪能力。
> - <mark style="background: #ABF7F7A6;">扩展性受限</mark>：如果 ID 规律太明显，可能会对系统的扩展性造成一定影响。当系统需要处理大量并发操作时，如果 ID 规律过于明显，可能导致多个操作同时对同一资源进行竞争，从而增加冲突和性能瓶颈。
> - <mark style="background: #ABF7F7A6;">维护困难</mark>：当 ID 规律太明显时，系统可能需要额外的资源和机制来保持规律的更新和变化，以确保安全性和数据完整性。这会增加系统的复杂度，并给维护带来挑战。

我们可以使用<mark style="background: #FF5582A6;">分布式 ID</mark> 解决数据库自增 ID 出现的问题，分布式 ID 满足以下特点：
1. **全局唯一性**：分布式 ID 保证在整个分布式系统中唯一性，不会出现重复的标识符。这对于区分和追踪系统中的不同实体非常重要。
2. **高可用性**：分布式 ID 生成器通常被设计为高可用的组件，可以通过水平扩展、冗余备份或集群部署来确保服务的可用性。即使某个节点或组件发生故障，仍然能够正常生成唯一的 ID 标识符。
3. **安全性**：分布式 ID 生成器通常是独立于应用程序和业务逻辑的。它们被设计为一个单独的组件或服务，可以被各种应用程序和服务所共享和使用，使得各个应用程序之间的 ID 生成过程互不干扰。
4. **高性能**：分布式 ID 生成器通常要求在很短的时间内生成唯一的标识符。为了实现低延迟，设计者通常采用高效的算法和数据结构，以及优化的网络通信和存储策略。
5. **递增性**：分布式 ID 通常可以被设计成可按时间顺序排序，以便更容易对生成的 ID 进行索引、检索或排序操作。这对于一些场景，如日志记录和事件溯源等，非常重要。
### 分布式 ID 的实现
分布式 ID 的实现方式：
- **UUID**
- **Redis 自增**
- **数据库自增**
- **雪花算法**
我们使用自定义的实现方式：<mark style="background: #FF5582A6;">时间戳+序列号+数据库自增</mark>
为了增加 ID 的安全性，我们可以不直接使用 Redis 自增的数值，而是拼接一些其它信息：
![[1653363172079.png]]
- 符号位：1 bit, 永远为 0
- 时间戳：31 bit, 以秒为单位，可以使用 69 年（2^31/3600/24/365=69）
- 序列号：32 bit, 秒内计数器，支持每秒产生 2^31 个不同 ID

> [!NOTE] 分布式 ID 工具类
```java
@Component  
public class RedisIdWorker {  
    @Resource  
    private StringRedisTemplate stringRedisTemplate;  
    //开始时间戳  
    private static final long BEGIN_TIMESTAMP=1640995200L;  
    //序列化位数  
    private static final int COUNT_BITS=32;  
  
    /**  
     * 获取分布式ID  
     * @param keyPrefix  
     * @return  
     */  
    public long nextId(String keyPrefix){  
        //生成时间戳  
        LocalDateTime now = LocalDateTime.now();  
        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);  
        long timestamp = nowSecond - BEGIN_TIMESTAMP;  
        //生成序列号  
        String date = now.format(DateTimeFormatter.ofPattern("yyyyMMdd"));  
        Long count = stringRedisTemplate.opsForValue().increment(ID_PREFIX + keyPrefix + ":" + date);//每次调用数值加一  
        return timestamp<<COUNT_BITS|count;  
    }  
}
```

> [!NOTE] 测试
```java
@Resource  
private RedisIdWorker redisIdWorker;  
private ExecutorService es = Executors.newFixedThreadPool(500);  
@Test  
void testIdWorker() throws InterruptedException {  
    CountDownLatch latch = new CountDownLatch(300);  
  
    Runnable task = () -> {  
        for (int i = 0; i < 100; i++) {  
            long id = redisIdWorker.nextId("order");  
            System.out.println("id = " + id);  
        }  
        latch.countDown();//计数器减一  
    };  
    long begin = System.currentTimeMillis();  
    for (int i = 0; i < 300; i++) {  
        es.submit(task);  
    }    latch.await();//直到计数器减为0才通行  
    long end = System.currentTimeMillis();  
    System.out.println("time = " + (end - begin));  
}
```
![[Pasted image 20240129170948.png]]
### 优惠卷秒杀接口实现
#### 添加优惠卷
每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：
![[1653365145124.png]]
`tb_voucher`：优惠券的基本信息，优惠金额、使用规则等
`tb_seckill_voucher`：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息

>平价卷由于优惠力度并不是很大，所以是可以任意领取，而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段

**思路**：
- 获取优惠卷信息
- 将优惠卷信息保存至 `tb_voucher` 中
- 提取优惠卷信息，保存至 `tb_seckill_voucher` 中
- 将秒杀卷库存存入 Redis 中

> [!NOTE] VoucherController
```java
@PostMapping("seckill")  
public Result addSeckillVoucher(@RequestBody Voucher voucher) {  
    voucherService.addSeckillVoucher(voucher);  
    return Result.ok(voucher.getId());  
}
```

> [!NOTE] VoucherServiceImpl
```java
@Service  
public class VoucherServiceImpl extends ServiceImpl<VoucherMapper, Voucher> implements IVoucherService {  
  
    @Resource  
    private ISeckillVoucherService seckillVoucherService;  
    @Resource  
    private StringRedisTemplate stringRedisTemplate;  
  
    @Override  
    public Result queryVoucherOfShop(Long shopId) {  
        // 查询优惠券信息  
        List<Voucher> vouchers = getBaseMapper().queryVoucherOfShop(shopId);  
        // 返回结果  
        return Result.ok(vouchers);  
    }  
  
    @Override  
    @Transactional    public void addSeckillVoucher(Voucher voucher) {  
        // 保存优惠券  
        save(voucher);  
        // 保存秒杀信息  
        SeckillVoucher seckillVoucher = new SeckillVoucher();  
        seckillVoucher.setVoucherId(voucher.getId());  
        seckillVoucher.setStock(voucher.getStock());  
        seckillVoucher.setBeginTime(voucher.getBeginTime());  
        seckillVoucher.setEndTime(voucher.getEndTime());  
        seckillVoucherService.save(seckillVoucher);  
        stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());  
    }  
}
```

#### 抢购秒杀卷
>在原先数据库中添加秒杀卷，或者调用接口添加秒杀卷
![[Pasted image 20240129173351.png]]

**思路**：
- 秒杀是否开始或结束，尚未开始或已经结束则无法下单
- 库存是否充足，不足则无法下单
![[1653366238564.png]]

> [!NOTE] VoucherOrderServiceImpl
```java
@Service  
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {  
  
    @Resource  
    private ISeckillVoucherService seckillVoucherService;  
    @Resource  
    private RedisIdWorker redisIdWorker;  
    /**  
     * 抢购秒杀卷生成订单  
     * @param voucherId  
     * @return  
     */  
    @Override  
    @Transactional    public Result seckillVoucher(Long voucherId) {  
        //根据id查询秒杀卷  
        SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);  
        //判断秒杀卷是否合法  
        if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) {  
            return Result.fail("秒杀尚未开始");  
        }        if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) {  
            return Result.fail("秒杀已结束");  
        }        if(seckillVoucher.getStock()<1){  
            return Result.fail("秒杀卷已抢空");  
        }        //秒杀卷合法，减少库存  
        boolean flag = seckillVoucherService.update(new LambdaUpdateWrapper<SeckillVoucher>()  
                .eq(SeckillVoucher::getVoucherId, seckillVoucher.getVoucherId()) 
                .setSql("stock=stock-1"));  
        if(!flag){  
            throw new RuntimeException("秒杀卷扣减失败");  
        }        //秒杀成功，创建对应订单，并保存到数据库中  
        VoucherOrder voucherOrder = new VoucherOrder();  
        long orderId = redisIdWorker.nextId("order");  
        voucherOrder.setId(orderId);  
        voucherOrder.setUserId(UserHolder.getUser().getId());  
        voucherOrder.setVoucherId(voucherId);  
        //保存订单  
        flag = this.save(voucherOrder);  
        if(!flag){  
            return Result.fail("创建订单失败");  
        }        return Result.ok(orderId);  
    }  
}
```

> [!NOTE] VoucherOrderController
```java
@RestController  
@RequestMapping("/voucher-order")  
public class VoucherOrderController {  
    @Resource  
    private IVoucherOrderService voucherOrderService;  
    @PostMapping("seckill/{id}")  
    public Result seckillVoucher(@PathVariable("id") Long voucherId) {  
        return voucherOrderService.seckillVoucher(voucherId);  
    }  
}
```
![[Pasted image 20240129180804.png]]

### 单体下一人多单超卖问题
上一节我们通过分布式 ID+事务成功完成了优惠券秒杀功能，并且在测试后发现逻辑跑通了，看上去已经成功的解决了秒杀优惠券功能。但是前面我们只是正常的测试，那如果换到高并发的场景下能否成功解决？现在就让我们使用 Jmeter 来进行压力测试看看吧！
![[Pasted image 20240129204009.png]]
![[Pasted image 20240129204020.png]]

很明显在一人同时发送同一请求的情况下，出现了大量的异常，<mark style="background: #FF5582A6;">异常率高达 73.45%</mark>，<mark style="background: #FF5582A6;">数据库中秒杀卷的库存甚至可能为-1</mark>，这就是所谓的超卖问题，为什么会出现这样的情况呢？
当线程 1 执行完查找秒杀卷之后，发现可以抢购，对数据库中的数据进行修改之前，线程 2 和线程 3 同时调用抢购的接口，此时线程 1 还未对数据库进行修改，线程 2 和线程 3 查询数据库，发现可以进行抢购，这时又回到线程 1 将库存减一，假设原来库存中只有一个了，线程 1 调用数据库之后变为了 0 个，此时线程 2 和线程 3 再去调用数据库减少库存，就会将原来的库存 0 减少为负数，这就是超卖的过程
![[1653368335155.png]]

> [!NOTE] 解决超卖问题的方法
> - <mark style="background: #ABF7F7A6;">悲观锁</mark>：认为线程安全问题一定会发生，因此操作数据库之前都需要先获取锁，确保线程串行执行。常见的悲观锁有： `synchronized` 、 `lock`
> - <mark style="background: #ABF7F7A6;">乐观锁</mark>：认为线程安全问题不一定发生，因此不加锁，只会在更新数据库的时候去判断有没有其它线程对数据进行修改，如果没有修改则认为是安全的，直接更新数据库中的数据即可，如果修改了则说明不安全，直接抛异常或者等待重试。常见的实现方式有：<mark style="background: #FF5582A6;">版本号法、CAS操作、乐观锁算法</mark>

**悲观锁与乐观锁的比较**：
- 悲观锁比乐观锁的性能低：悲观锁需要先加锁再操作，而乐观锁不需要加锁，所以乐观锁通常具有更好的性能。
- 悲观锁比乐观锁的冲突处理能力低：悲观锁在冲突发生时直接阻塞其他线程，乐观锁则是在提交阶段检查冲突并进行重试。
- 悲观锁比乐观锁的并发度低：悲观锁存在锁粒度较大的问题，可能会限制并发性能；而乐观锁可以实现较高的并发度。
- 应用场景：两者都是互斥锁，悲观锁适合写入操作较多、冲突频繁的场景；乐观锁适合读取操作较多、冲突较少的场景。
### 乐观锁解决超卖问题
- **实现方式一**：版本号法
![[1653369268550.png]]
首先我们要为 `tb_seckill_voucher` 表新增一个版本号字段 `version` ，线程1查询完库存，在进行库存扣减操作的同时将版本号+1，线程2在查询库存时，同时查询出当前的版本号，发现库存充足，也准备执行库存扣减操作，但是需要判断当前的版本号是否是之前查询时的版本号，结果发现版本号发生了改变，这就说明数据库中的数据已经发生了修改，需要进行重试（或者直接抛异常中断）
- **实现方式二**：CAS 法
CAS 法类似与版本号法，但是不需要另外在添加一个 version 字段，而是直接使用<mark style="background: #FF5582A6;">库存替代版本号</mark>，线程1查询完库存后进行库存扣减操作，线程2在查询库存时，发现库存充足，也准备执行库存扣减操作，<mark style="background: #FF5582A6;">但是需要判断当前的库存是否是之前查询时的库存</mark>，结果发现库存数量发生了改变，这就说明数据库中的数据已经发生了修改，需要进行重试（或者直接抛异常中断）

>我们选择 CAS 法，因为能够避免额外的内存开销，我们只需要将修改时的条件增加一个数据库库存等于前面获取对象中的库存

> [!NOTE] CAS 法解决超卖问题
```java
@Service  
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {  
  
    @Resource  
    private ISeckillVoucherService seckillVoucherService;  
    @Resource  
    private RedisIdWorker redisIdWorker;  
    /**  
     * 抢购秒杀卷生成订单  
     * @param voucherId  
     * @return  
     */  
    @Override  
    @Transactional    public Result seckillVoucher(Long voucherId) {  
        //根据id查询秒杀卷  
        SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);  
        //判断秒杀卷是否合法  
        if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) {  
            return Result.fail("秒杀尚未开始");  
        }        if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) {  
            return Result.fail("秒杀已结束");  
        }        if(seckillVoucher.getStock()<1){  
            return Result.fail("秒杀卷已抢空");  
        }        //秒杀卷合法，减少库存  
        boolean flag = seckillVoucherService.update(new LambdaUpdateWrapper<SeckillVoucher>()  
                .eq(SeckillVoucher::getStock, seckillVoucher.getStock())  
	            .eq(SeckillVoucher::getVoucherId,seckillVoucher.getVoucherId())  
                .setSql("stock=stock-1"));  
        if(!flag){  
            throw new RuntimeException("秒杀卷扣减失败");  
        }        //秒杀成功，创建对应订单，并保存到数据库中  
        VoucherOrder voucherOrder = new VoucherOrder();  
        long orderId = redisIdWorker.nextId("order");  
        voucherOrder.setId(orderId);  
        voucherOrder.setUserId(UserHolder.getUser().getId());  
        voucherOrder.setVoucherId(voucherId);  
        //保存订单  
        flag = this.save(voucherOrder);  
        if(!flag){  
            return Result.fail("创建订单失败");  
        }        return Result.ok(orderId);  
    }  
}
```
**再次进行测试**
QPS 为 200，异常率为 56%，虽然有所减少，但是仍不能满足实际需求
![[Pasted image 20240129213207.png]]
![[Pasted image 20240129213242.png]]
而且总共 200 个请求，居然只秒杀掉 11 张优惠卷😅
**这又是什么原因导致？**
- 这就是乐观锁的弊端，只要发现数据库修改过了就直接终止操作，从而导致在高并发的情况下很多请求就直接终止掉了，但是只要库存大于 0，我们就可以继续进行修改操作，不用直接终止掉
```java
boolean flag = seckillVoucherService.update(new LambdaUpdateWrapper<SeckillVoucher>()  
        .gt(SeckillVoucher::getStock,0)  
                .eq(SeckillVoucher::getVoucherId,seckillVoucher.getVoucherId())  
        .setSql("stock=stock-1"));
```
### 单体下一人一单超卖问题
>需求：修改秒杀业务，要求同一张优惠卷，一个用户只能下一单
>优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单

**思路**：
- 抢购优惠卷的时间是否合法，是否在规定时间内抢购
- 优惠卷的库存是否充足
- 根据优惠卷 id 和用户 id 查询订单是否已经存在，如果存在，则不能再次抢购，如果不存在，则可以进行抢购，扣减库存
![[1653371854389.png]]

> [!NOTE] 一人一单
```java
@Override  
@Transactional  
public Result seckillVoucher(Long voucherId) {  
    //根据id查询秒杀卷  
    SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);  
    //判断秒杀卷是否合法  
    if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) {  
        return Result.fail("秒杀尚未开始");  
    }    if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) {  
        return Result.fail("秒杀已结束");  
    }    if(seckillVoucher.getStock()<1){  
        return Result.fail("秒杀卷已抢空");  
    }    //根据优惠卷id和用户id查询订单  
    int count = this.count(new LambdaQueryWrapper<VoucherOrder>().  
        eq(VoucherOrder::getVoucherId, voucherId).  
        eq(VoucherOrder::getUserId, UserHolder.getUser().getId()));  
	if(count>=1){  
	    return Result.fail("不能重复下单");  
	}  
    //秒杀卷合法，减少库存  
    boolean flag = seckillVoucherService.update(new LambdaUpdateWrapper<SeckillVoucher>().eq(SeckillVoucher::getVoucherId,voucherId)  
                    .gt(SeckillVoucher::getStock,0)  
                    .setSql("stock=stock-1"));  
    if(!flag){  
        throw new RuntimeException("秒杀卷扣减失败");  
    }    //秒杀成功，创建对应订单，并保存到数据库中  
    VoucherOrder voucherOrder = new VoucherOrder();  
    long orderId = redisIdWorker.nextId("order");  
    voucherOrder.setId(orderId);  
    voucherOrder.setUserId(UserHolder.getUser().getId());  
    voucherOrder.setVoucherId(voucherId);  
    //保存订单  
    flag = this.save(voucherOrder);  
    if(!flag){  
        throw new RuntimeException("创建秒杀订单失败");  
    }    return Result.ok(orderId);  
}
```

**测试**
现在是否解决了一人一单问题呢，用 jmeter 测试一下
![[Pasted image 20240130182834.png]]
![[Pasted image 20240130182844.png]]
结果并没有按我们想象中的那么走，还是出现了超卖问题，这是为什么呢？
>**原因**：和前面的一人多单超卖问题一样，线程 1 调用方法，查询到订单数为 0，满足让库存减一的条件，但是在线程 1 减库存之前，线程 2 又执行方法，此时线程 1 的订单还未生成，线程 2 查询订单数量自然也为 0，满足减少库存的条件，因此造成了超卖问题

**解决方法**
- 悲观锁
- 乐观锁
### 悲观锁解决一人一单超卖问题
>乐观锁需要判断数据是否修改，而当前是判断当前是否存在，所以无法像解决库存超卖一样使用CAS机制，但是可以使用版本号法，但是版本号法需要新增一个字段，所以这里为了方便，就直接演示使用悲观锁解决超卖问题

1. 我们可以将生成订单的过程封装成一个方法, 然后使用 `synchronized` 锁起来
```java
@Override  
@Transactional  
public Result seckillVoucher(Long voucherId) {  
    //根据id查询秒杀卷  
    SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);  
    //判断秒杀卷是否合法  
    if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) {  
        return Result.fail("秒杀尚未开始");  
    }    if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) {  
        return Result.fail("秒杀已结束");  
    }    if (seckillVoucher.getStock() < 1) {  
        return Result.fail("秒杀卷已抢空");  
    }    return createVoucherOrder(voucherId);  
}  
  
/**  
 * 生成订单  
 * @param voucherId  
 * @return  
 */  
@Transactional  
public synchronized Result createVoucherOrder(Long voucherId){  
    //根据优惠卷id和用户id查询订单  
    int count = this.count(new LambdaQueryWrapper<VoucherOrder>().  
            eq(VoucherOrder::getVoucherId, voucherId).  
            eq(VoucherOrder::getUserId, UserHolder.getUser().getId()));  
    if(count>=1){  
        return Result.fail("不能重复下单");  
    }    //秒杀卷合法，减少库存  
    boolean flag = seckillVoucherService.update(new LambdaUpdateWrapper<SeckillVoucher>().eq(SeckillVoucher::getVoucherId,voucherId)  
            .gt(SeckillVoucher::getStock,0)  
            .setSql("stock=stock-1"));  
    if(!flag){  
        throw new RuntimeException("秒杀卷扣减失败");  
    }    //秒杀成功，创建对应订单，并保存到数据库中  
    VoucherOrder voucherOrder = new VoucherOrder();  
    long orderId = redisIdWorker.nextId("order");  
    voucherOrder.setId(orderId);  
    voucherOrder.setUserId(UserHolder.getUser().getId());  
    voucherOrder.setVoucherId(voucherId);  
    flag = this.save(voucherOrder);  
    if(!flag){  
        throw new RuntimeException("创建秒杀订单失败");  
    }    return Result.ok(orderId);  
}
```
2. 我们必须考虑锁的粗粒度，`synchronized` 直接用在方法上，粒度太粗了，`synchronized` 最好使用在代码块里
```java
@Transactional  
public  Result createVoucherOrder(Long voucherId){  
    synchronized (voucherId){  
        //根据优惠卷id和用户id查询订单  
        int count = this.count(new LambdaQueryWrapper<VoucherOrder>().  
                eq(VoucherOrder::getVoucherId, voucherId).  
                eq(VoucherOrder::getUserId, UserHolder.getUser().getId()));  
        if(count>=1){  
            return Result.fail("不能重复下单");  
        }  
        //秒杀卷合法，减少库存  
        boolean flag = seckillVoucherService.update(new LambdaUpdateWrapper<SeckillVoucher>().eq(SeckillVoucher::getVoucherId,voucherId)  
                .gt(SeckillVoucher::getStock,0)  
                .setSql("stock=stock-1"));  
        if(!flag){  
            throw new RuntimeException("秒杀卷扣减失败");  
        }  
        //秒杀成功，创建对应订单，并保存到数据库中  
        VoucherOrder voucherOrder = new VoucherOrder();  
        long orderId = redisIdWorker.nextId("order");  
        voucherOrder.setId(orderId);  
        voucherOrder.setUserId(UserHolder.getUser().getId());  
        voucherOrder.setVoucherId(voucherId);  
        flag = this.save(voucherOrder);  
        if(!flag){  
            throw new RuntimeException("创建秒杀订单失败");  
        }  
        return Result.ok(orderId);  
    }}
```
3. 不能直接将 userId 作为锁标识，因为每个线程访问进来所携带的 userId 都不是同一个对象，你可能会认用 toString 方法转换为字符串不就好了，但是你又中陷阱了，toString 方法也是通过 new 的方式返回一个字符串对象，换言之，返回的并不是常量池中的字符串常量😜，这时可以使用 `intern` 这个方法，这个方法会返回常量池中的对象，如果常量池中没有则会自动创建一个对象
```java
@Transactional  
public  Result createVoucherOrder(Long userId,Long voucherId){  
    synchronized (userId.toString().intern()){  
        //根据优惠卷id和用户id查询订单  
        int count = this.count(new LambdaQueryWrapper<VoucherOrder>().  
                eq(VoucherOrder::getVoucherId, voucherId).  
                eq(VoucherOrder::getUserId, UserHolder.getUser().getId()));  
        if(count>=1){  
            return Result.fail("不能重复下单");  
        }  
        //秒杀卷合法，减少库存  
        boolean flag = seckillVoucherService.update(new LambdaUpdateWrapper<SeckillVoucher>().eq(SeckillVoucher::getVoucherId,voucherId)  
                .gt(SeckillVoucher::getStock,0)  
                .setSql("stock=stock-1"));  
        if(!flag){  
            throw new RuntimeException("秒杀卷扣减失败");  
        }  
        //秒杀成功，创建对应订单，并保存到数据库中  
        VoucherOrder voucherOrder = new VoucherOrder();  
        long orderId = redisIdWorker.nextId("order");  
        voucherOrder.setId(orderId);  
        voucherOrder.setUserId(UserHolder.getUser().getId());  
        voucherOrder.setVoucherId(voucherId);  
        flag = this.save(voucherOrder);  
        if(!flag){  
            throw new RuntimeException("创建秒杀订单失败");  
        }  
        return Result.ok(orderId);  
    }}
```
4. 但是以上代码还是存在问题，问题的原因在于当前方法被 spring 的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题
```java
@Override  
public Result seckillVoucher(Long voucherId) {  
    //根据id查询秒杀卷  
    SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);  
    //判断秒杀卷是否合法  
    if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) {  
        return Result.fail("秒杀尚未开始");  
    }    if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) {  
        return Result.fail("秒杀已结束");  
    }    if (seckillVoucher.getStock() < 1) {  
        return Result.fail("秒杀卷已抢空");  
    }    Long userId = UserHolder.getUser().getId();  
    synchronized (userId.toString().intern()){  
        return createVoucherOrder(voucherId);  
    }
}  
  
/**  
 * 生成订单  
 * @param voucherId  
 * @return  
 */  
@Transactional  
public  Result createVoucherOrder(Long userId,Long voucherId){  
    //根据优惠卷id和用户id查询订单  
    int count = this.count(new LambdaQueryWrapper<VoucherOrder>().  
            eq(VoucherOrder::getVoucherId, voucherId).  
            eq(VoucherOrder::getUserId, UserHolder.getUser().getId()));  
    if(count>=1){  
        return Result.fail("不能重复下单");  
    }    //秒杀卷合法，减少库存  
    boolean flag = seckillVoucherService.update(new LambdaUpdateWrapper<SeckillVoucher>().eq(SeckillVoucher::getVoucherId,voucherId)  
            .gt(SeckillVoucher::getStock,0)  
            .setSql("stock=stock-1"));  
    if(!flag){  
        throw new RuntimeException("秒杀卷扣减失败");  
    }    //秒杀成功，创建对应订单，并保存到数据库中  
    VoucherOrder voucherOrder = new VoucherOrder();  
    long orderId = redisIdWorker.nextId("order");  
    voucherOrder.setId(orderId);  
    voucherOrder.setUserId(UserHolder.getUser().getId());  
    voucherOrder.setVoucherId(voucherId);  
    flag = this.save(voucherOrder);  
    if(!flag){  
        throw new RuntimeException("创建秒杀订单失败");  
    }    return Result.ok(orderId);  
}
```
5. 你以为这就完了? Spring 中事务失效的场景这个八股文背了吗，<mark style="background: #FF5582A6;">同一个类之间的方法调用会导致事务失效</mark>，你是用的是 this 对象调用事务，但实际应该用代理对象调用事务
- 引入 AOP 依赖
```xml
<dependency>
	<groupId>org.aspectj</groupId>
	<artifactId>aspectjweaver</artifactId>
</dependency>
```
- 在启动类上暴露动态代理对象（默认是 false）
`@EnableAspectJAutoProxy(exposeProxy = true)`
```java
@Override  
public Result seckillVoucher(Long voucherId) {  
    //根据id查询秒杀卷  
    SeckillVoucher seckillVoucher = seckillVoucherService.getById(voucherId);  
    //判断秒杀卷是否合法  
    if (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) {  
        return Result.fail("秒杀尚未开始");  
    }    if (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) {  
        return Result.fail("秒杀已结束");  
    }    if (seckillVoucher.getStock() < 1) {  
        return Result.fail("秒杀卷已抢空");  
    }    Long userId = UserHolder.getUser().getId();  
    synchronized (userId.toString().intern()){  
        //创建代理对象  
        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();  
        return proxy.createVoucherOrder(voucherId);  
    }}  
  
/**  
 * 生成订单  
 * @param voucherId  
 * @return  
 */  
@Transactional  
public  Result createVoucherOrder(Long userId,Long voucherId){  
    //根据优惠卷id和用户id查询订单  
    int count = this.count(new LambdaQueryWrapper<VoucherOrder>().  
            eq(VoucherOrder::getVoucherId, voucherId).  
            eq(VoucherOrder::getUserId, UserHolder.getUser().getId()));  
    if(count>=1){  
        return Result.fail("不能重复下单");  
    }    //秒杀卷合法，减少库存  
    boolean flag = seckillVoucherService.update(new LambdaUpdateWrapper<SeckillVoucher>().eq(SeckillVoucher::getVoucherId,voucherId)  
            .gt(SeckillVoucher::getStock,0)  
            .setSql("stock=stock-1"));  
    if(!flag){  
        throw new RuntimeException("秒杀卷扣减失败");  
    }    //秒杀成功，创建对应订单，并保存到数据库中  
    VoucherOrder voucherOrder = new VoucherOrder();  
    long orderId = redisIdWorker.nextId("order");  
    voucherOrder.setId(orderId);  
    voucherOrder.setUserId(UserHolder.getUser().getId());  
    voucherOrder.setVoucherId(voucherId);  
    flag = this.save(voucherOrder);  
    if(!flag){  
        throw new RuntimeException("创建秒杀订单失败");  
    }    return Result.ok(orderId);  
}
```
记得也要重写 createVoucherOrder 方法，代理的是接口，接口中应该包含要调用的方法

**测试**
![[Pasted image 20240130213212.png]]
![[Pasted image 20240130213224.png]]

> [!warning] 巨坑
> 千万不要在 seckillVoucher 方法上添加事务，否则根据 Spring 事务的传播机制，createVoucherOrder 方法和 seckillVoucher 相当于同一个事务，也就是当 createVoucherOrder 方法执行完还不能提交，直到 seckillVoucher 方法执行完才能提交，也就是说在数据还未更改之前，锁已经释放了😭
### 集群下一人一单超卖问题
1. 搭建集群并实现负载均衡
首先，在 IDEA 中启动两个 SpringBoot 程序，一个端口号是8081，另一个端口是8082：
![[Pasted image 20240130214211.png]]
![[Pasted image 20240130214234.png]]
![[Pasted image 20240130214324.png]]
![[Pasted image 20240130214501.png]]
![[Pasted image 20240130214509.png]]
2. 然后修改 nginx 的 conf 目录下的 nginx. Conf 文件，配置反向代理和负载均衡：
![[Pasted image 20240130214754.png]]

3. 准备两个接口，用于模拟集群下的多用户重复下单
![[Pasted image 20240130215654.png]]
4. 发送请求之前，在锁的内部打一个断点
![[Pasted image 20240130215824.png]]
5. 发送请求，因为 nginx 是负载均衡策略，所以请求 1 会被 8081 端口接受，请求 2 会被 8082 端口接受
可以看到，两者都进入了锁的内部，这个 `synchronized` 锁形同虚设，这是由于 `synchronized` 是本地锁，<mark style="background: #FF5582A6;">只能提供线程级别的同步</mark>，<mark style="background: #FF5582A6;">每个 JVM 中都有一把 synchronized 锁，不能跨 JVM 进行上锁</mark>，当一个线程进入被 synchronized 关键字修饰的方法或代码块时，它会尝试获取对象的内置锁（也称为监视器锁）。如果该锁没有被其他线程占用，则当前线程获得锁，可以继续执行代码；否则，当前线程将进入阻塞状态，直到获取到为止。而现在我们是创建了两个节点，也就意味着有两个 JVM，所以 synchronized 会失效！
>这时就会出现超卖的问题了

![[1653374044740.png]]

### 分布式锁
>分布式锁：满足分布式系统下或集群模式下多进程可见并互斥的锁

前面 `sychronized` 锁失效的原因是由于每一个 JVM 都有一个独立的锁监视器，用于监视当前 JVM 中的
`sychronized` 锁，所以无法保障多个集群下只有一个线程访问一个代码块。所以我们直接将使用一个分布锁，在整个系统的全局中设置一个锁监视器，从而保障不同节点的 JVM 都能够识别，从而实现集群下只允许一个线程访问一个代码块
![[1653374296906.png]]

> [!NOTE] 分布式锁的特点
> - <mark style="background: #ABF7F7A6;">可见性</mark>：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思
> - <mark style="background: #ABF7F7A6;">互斥</mark>：互斥是分布式锁的最基本的条件，使得程序串行执行
> - <mark style="background: #ABF7F7A6;">高可用</mark>：分布式锁应该具备高可用性，即使在网络分区或节点故障的情况下，仍然能够正常工作。（容错性）当持有锁的节点发生故障或宕机时，系统需要能够自动释放该锁，以确保其他节点能够继续获取锁。
> - <mark style="background: #ABF7F7A6;">高性能</mark>：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能
> - <mark style="background: #ABF7F7A6;">安全性</mark>：安全也是程序中必不可少的一环

**分布式锁常见的实现方式**：
![[1653382219377.png]]
- [ ] Mysql：mysql 本身就带有锁机制，但是由于 mysql 性能本身一般，所以采用分布式锁的情况下，其实使用 mysql 作为分布式锁比较少见
- [x] Redis：redis 作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用 redis 或者 zookeeper 作为分布式锁，利用 `setnx` 这个方法，如果插入 key 成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁 ✅ 2024-02-01
- [ ] Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案，由于本套视频并不讲解zookeeper的原理和分布式锁的实现，所以不过多阐述
**使用 Redis 获取锁**：
- 方式一
```shell
# 添加锁
setnx [key] [value]
# 为锁设置过期时间，超时释放，避免死锁
expire [key] [time]
```
- 方式二👍
```shell
# 添加锁
set [key] [value] ex [time] nx
```
**使用 Redis 释放锁**：
```shell
# 释放锁（除了使用del手动释放，还可超时释放）
del [key]
```
### 分布式锁解决超卖问题
**思路**：
- 获取锁
	- 互斥：确保在分布式结构下只有一个线程能够获取锁
	- 非阻塞：尝试一次，成功返回 true，失败返回 false
- 释放锁
	- 手动释放
	- 超时释放
- 多个线程获取锁时，第一个线程会调用 Redis 的 `setNx` 方法，对应的 key 如果没有值，则获取锁成功，返回 1，如果对应的 key 存在值，说明分布式锁已经被其他线程所抢占了，返回 0，等待一段时间继续获取锁
![[1653382830810.png]]

> [!NOTE] 创建分布式锁
```java
public interface ILock {  
    /**  
     * 获取锁，并设置超时时间  
     * @param timeoutSec  
     * @return  
     */  
    boolean tryLock(long timeoutSec);  
  
    /**  
     * 释放锁  
     */  
    void unLock();  
}
```
```java
public class SimpleRedisLock implements ILock{  
    private StringRedisTemplate stringRedisTemplate;  
    private String name;  
    public SimpleRedisLock(StringRedisTemplate stringRedisTemplate,String name){  
        this.stringRedisTemplate=stringRedisTemplate;  
        this.name=name;  
    }  
  
    /**  
     * 获取分布式锁  
     * @param timeoutSec  
     * @return  
     */  
    @Override  
    public boolean tryLock(long timeoutSec) {  
        String id=Thread.currentThread().getId()+"";  
        Boolean isLock = stringRedisTemplate.opsForValue().setIfAbsent("lock:" + name, id, timeoutSec, TimeUnit.SECONDS);  
        return BooleanUtil.isTrue(isLock);//要考虑isLock为空的情况  
    }  
  
  
    @Override  
    public void unLock() {  
        stringRedisTemplate.delete("lock:" + name);  
    }  
}
```

> [!NOTE] 将分布式锁应用在 VoucherOrderServiceImpl 中
```java
public Result seckillVoucher(Long voucherId) {  
// 1、查询秒杀券  
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);  
// 2、判断秒杀券是否合法  
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {  
// 秒杀券的开始时间在当前时间之后  
            return Result.fail("秒杀尚未开始");  
        }        
        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {  
// 秒杀券的结束时间在当前时间之前  
            return Result.fail("秒杀已结束");  
        }        
        if (voucher.getStock() < 1) {  
            return Result.fail("秒杀券已抢空");  
        }// 3、创建订单  
        Long userId = UserHolder.getUser().getId();  
        SimpleRedisLock simpleRedisLock = new SimpleRedisLock(stringRedisTemplate, "order:"+userId);  
        //获取分布式锁  
        boolean isLock = simpleRedisLock.tryLock(1200);  
        if(!isLock){  
            return Result.fail("不能重复下单");  
        }        
        try{  
            // 创建代理对象，使用代理对象调用第三方事务方法， 防止事务失效  
            IVoucherOrderService proxy = (IVoucherOrderService)  
                    AopContext.currentProxy();  
            return proxy.createVoucherOrder(userId, voucherId);  
        }finally {  
            simpleRedisLock.unLock();//释放锁  
        }  
}
```

> [!warning] 注意
> - 使用 apifox 进行测试时，及得在 header 中添加用户的 token，否则没有用户信息会被拦截
> - try... Finally... 确保发生异常时锁能够释放，注意这给地方不要使用 catch ，A 事务方法内部调用 B 事务方法，A 事务方法不能够直接 catch，否则会导致事务失效
> - ![[Pasted image 20240201205055.png]]

### 分布式锁优化
#### 分布式锁误删问题
>假设线程一获取了分布式锁，执行业务，但由于执行业务时间过长，导致在还未释放锁之前分布式锁就超时释放了，这时同一个用户启动线程二就可以获得同一把锁，线程二执行业务的过程中线程一业务执行完毕，线程一释放锁，但是释放的是线程二的锁，导致线程二的互斥锁提前释放，此时同一个用户线程三又可以趁虚而入拿到锁，线程二和线程三同时执行业务代码，那就很有可能导致<mark style="background: #FF5582A6;">超卖问题</mark>了（但是这个在小项目
（并发数不高）中出现的概率比较低，在大型项目（并发数高）情况下是有一定概率的）
![[1653385920025.png]]

**解决方案**：
- 添加一个锁的线程标识，如果这个线程标识和当前线程 id 一致则可以进行释放，否则就不释放
- 一个线程获取分布式锁时，将 redis 中的值设置为当前线程的 id, 在释放锁时，就从 Redis 中获取对应的线程 id 与当前线程 id 做对比
![[1653387398820.png]]
- 如果你担心在集群的情况下向不同的 JVM 发送请求得到的线程 id 可能相同（这种情况比中彩票还难），不妨设置一个 JVM 标识，就是设置一个常量，这个常量的值是根据 UUID 获取的随机数，在不同的 JVM 下 UUID 是不一样的

> [!NOTE] 分布式锁优化
```java
public class SimpleRedisLock implements ILock{  
    private StringRedisTemplate stringRedisTemplate;  
    private String name;  
    private static final String ID_PREFIX = UUID.randomUUID().toString(true) + "-";  
    public SimpleRedisLock(StringRedisTemplate stringRedisTemplate,String name){  
        this.stringRedisTemplate=stringRedisTemplate;  
        this.name=name;  
    }  
  
    /**  
     * 获取分布式锁  
     * @param timeoutSec  
     * @return  
     */  
    @Override  
    public boolean tryLock(long timeoutSec) {  
        String id=ID_PREFIX+Thread.currentThread().getId()+"";  
        Boolean isLock = stringRedisTemplate.opsForValue().setIfAbsent("lock:" + name, id, timeoutSec, TimeUnit.SECONDS);  
        return BooleanUtil.isTrue(isLock);//要考虑isLock为空的情况  
    }  
  
  
    @Override  
    public void unLock() {  
        //获取当前线程标识  
        String currentThreadFlag=ID_PREFIX+Thread.currentThread().getId();  
        String id = stringRedisTemplate.opsForValue().get("lock:" + name);  
        if(currentThreadFlag!=null&&currentThreadFlag.equals(id)){//一致，说明当前锁就是当前线程的  
            stringRedisTemplate.delete("lock:" + name);  
        }   
	}  
}
```
#### 分布式锁的原子性问题
>线程一获取锁之后执行相关业务，最后在释放锁的过程中，判断完当前锁是属于当前线程的，但是在删除操作之前发生了阻塞，这时锁被超时释放了，线程二乘虚而入获取锁并执行相关业务，接着线程一阻塞完成，直接进行释放锁操作（因为前面线程一已经判断过锁是属于当前线程的），这相当于又把线程二的锁进行释放了，这时线程三又可以趁虚而入获取锁，与线程二同时执行相同业务，从而发生了<mark style="background: #FF5582A6;">超卖问题</mark>
![[1653387398820 1.png]]

**解决方法**：
- 综上问题不难发现，发生超卖的主要原因是<mark style="background: #FF5582A6;">判断锁标识和释放锁操作缺乏原子性</mark>
- Redis 使用（支持）相同的 <mark style="background: #FF5582A6;">Lua</mark> 解释器，来运行所有的命令。Redis还保证脚本以原子方式执行：<mark style="background: #ABF7F7A6;">在执行脚本时，不会执行其他脚本或Redis命令</mark>。这个语义类似于 MULTI（开启事务）/ EXEC （触发事务，一并执行事务中的所有命令）。从所有其他客户端的角度来看，脚本的效果要么仍然不可见，要么已经完成
- 这里重点介绍 Redis 提供的调用函数，我们可以使用 lua 去操作 redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了，作为 Java 程序员这一块并不作一个简单要求，并不需要大家过于精通，只需要知道他有什么作用即可。
这里重点介绍 Redis 提供的调用函数，语法如下：
```lua
redis.call('命令名称', 'key', '其它参数', ...)
```
例如，我们要执行 set name jack，则脚本是这样：
```lua
# 执行 set name jack
redis.call('set', 'name', 'jack')
```
例如，我们要先执行 set name Rose，再执行 get name，则脚本如下：
```lua
# 先执行 set name jack
redis.call('set', 'name', 'Rose')
# 再执行 get name
local name = redis.call('get', 'name')
# 返回
return name
```
写好脚本以后，需要用 Redis 命令来调用脚本，调用脚本的常见命令如下：
![[1653392181413.png]]
例如，我们要执行 redis.call('set', 'name', 'jack') 这个脚本，语法如下：
![[1653392218531.png]]
如果脚本中的 key、value 不想写死，可以作为参数传递。key 类型参数会放入 KEYS 数组，其它参数会放入 ARGV 数组，在脚本中可以从 KEYS 和 ARGV 数组获取这些参数：
![[1653392438917.png]]

释放锁的流程：
1. 获取锁中的线程标识
2. 判断是否与当前线程标识一致
3. 如果一致则释放锁
4. 不一致什么都不做
>在 IDEA 中编写 lua 脚本要先下一个 `EmmyLua` 插件

> [!NOTE] 判断和释放操作的 lua 脚本
```lua
---  
--- Generated by EmmyLua(https://github.com/EmmyLua)  
--- Created by moresuo.  
--- DateTime: 2024/2/1 21:56  
---  
-- 比较缓存中的线程标识与当前线程标识是否一致  
if (redis.call('get',KEYS[1]) == ARGV[1]) then  
    -- 一致，删除  
    return redis.call('del',KEYS[1])  
end  
-- 不一致  
return 0;
```

> [!NOTE] 基于 lua 脚本的分布式锁
```java
public class SimpleRedisLock implements ILock{  
    private StringRedisTemplate stringRedisTemplate;  
    private String name;  
    private static final String ID_PREFIX = UUID.randomUUID().toString(true) + "-";  
    public SimpleRedisLock(StringRedisTemplate stringRedisTemplate,String name){  
        this.stringRedisTemplate=stringRedisTemplate;  
        this.name=name;  
    }  
  
    /**  
     * 获取分布式锁  
     * @param timeoutSec  
     * @return  
     */  
    @Override  
    public boolean tryLock(long timeoutSec) {  
        String id=ID_PREFIX+Thread.currentThread().getId()+"";  
        Boolean isLock = stringRedisTemplate.opsForValue().setIfAbsent("lock:" + name, id, timeoutSec, TimeUnit.SECONDS);  
        return BooleanUtil.isTrue(isLock);//要考虑isLock为空的情况  
    }  
  
    /**  
     * 在类加载时就加载脚本  
     */  
    private static final DefaultRedisScript<Long> UNLOCK_SCRIPT;  
    static {  
        UNLOCK_SCRIPT = new DefaultRedisScript<>();  
        UNLOCK_SCRIPT.setLocation(new ClassPathResource("lua/unLock.lua"));  
        UNLOCK_SCRIPT.setResultType(Long.class);  
    }  
    @Override  
    public void unLock() {  
        //获取当前线程标识  
        String currentThreadFlag=ID_PREFIX+Thread.currentThread().getId();  
        stringRedisTemplate.execute(UNLOCK_SCRIPT, Collections.singletonList("lock:" + name), currentThreadFlag);//将判断和释放作为一个原子操作  
    }  
}
```
现在我们的分布式锁满足了以下功能：
1. **多线程可见**：用 Redis 完成分布式锁，保证在所有 JVM 都可见
2. **互斥**：使用 `set nx ex` 指令保证只能有一个线程操作成功，而且设置超时时间，防止发生死锁
3. **高可用**：层层优化，即使是特别极端的情况下照样可以防止超卖
4. **高性能**：Redis 的 IO 速度很快，Lua 脚本的性能也很快
5. **安全性**：这个不用多说了，通过给锁夹线程标识+Lua 封装 Redis 指令充分保障了线程安全，不那么容易出现并发安全问题，同时采用超时释放避免死锁
>但是并不是完美的，还有一个问题，就是锁超时问题，线程一拿到锁之后执行业务过程中锁突然超时释放了，线程二又可以获取锁了，应该在线程一的锁到期时，如果线程一还未完成相关业务，提供一个续期功能

### Redisson 
经过前面的优化我们的分布式锁已经达到**生产可用级别**，但是还不够完善，比如：
- <mark style="background: #ABF7F7A6;">分布式锁不可重入</mark>：不可重入是指同一线程不能重复获取同一把锁。比如，方法 A 中调用方法 B，方法 A 需要获取分布式锁，方法 B 同样需要获取分布式锁，线程 1 进入方法 A 获取了一次锁，进入方法 B 又获取一次锁，由于锁不可重入，所以就会导致死锁
- <mark style="background: #ABF7F7A6;">分布式锁不可重试</mark>：获取锁只尝试一次就返回 false，没有重试机制，这会导致数据丢失，比如线程 1 获取锁，然后要将数据写入数据库，但是当前的锁被线程 2 占用了，线程 1 直接就结束了而不去重试，这就导致数据发生了丢失
- <mark style="background: #ABF7F7A6;">分布式锁超时释放</mark>：超市释放机机制虽然一定程度避免了死锁发生的概率，但是如果业务执行耗时过长，期间锁就释放了，这样存在安全隐患。锁的有效期过短，容易出现业务没执行完就被释放，锁的有效期过长，容易出现死锁，所以这是一个大难题！
	- 我们可以设置一个<mark style="background: #FF5582A6;">较短的有效期</mark>，但是加上一个<mark style="background: #FF5582A6;">心跳机制</mark>和<mark style="background: #FF5582A6;">自动续期</mark>：在锁被获取后，可以使用心跳机制并自动续期锁的持有时间。通过<mark style="background: #FF5582A6;">定期发送心跳请求</mark>，显示地告知其他线程或系统锁还在使用中，同时更新锁的过期时间。如果某个线程持有锁的时间超过了预设的有效时间，其他线程可以尝试重新获取锁
- <mark style="background: #ABF7F7A6;">主从一致性问题</mark>：如果 Redis 提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。
![[1653546070602.png]]
>这时候就轮到我们的 `Redisson` 出场了，`Redssion` 是一个十分成熟的 Redis 框架，功能也很多，比如：<mark style="background: #FF5582A6;">分布式锁和同步器、分布式对象、分布式集合、分布式服务</mark>，各种 Redis 实现分布式的解决方案。简而言之 `Redisson` 就是一个使用 Redis 解决分布式问题的方案的集合，当然它不仅仅是解决分布式相关问题，还包含其它的一些问题

#### Redisson 实现分布式锁
1. 引入 Redisson 依赖
```xml
<dependency>
	<groupId>org.redisson</groupId>
	<artifactId>redisson</artifactId>
	<version>3.17.3</version>
</dependency>
```
2. 配置 Redisson 客户端
```java
@Configuration  
public class RedissonConfig {  
  
    @Value("${spring.redis.host}")  
    private String host;  
    @Value("${spring.redis.port}")  
    private String port;  
    @Value("${spring.redis.password}")  
    private String password;  
  
    /**  
     * 创建Redisson配置对象，交给Ioc管理  
     * @return  
     */  
    @Bean  
    public RedissonClient redissonClient(){  
        //获取Redisson配置对象  
        Config config = new Config();  
        //添加Redis地址，这里是添加单节点地址，如果想添加集群地址可以通过config.userClusterServers()  
        config.useSingleServer().setAddress("redis://" + this.host + ":" + this.port).setPassword(this.password);  
        //获取redissonClient对象，交给IoC管理  
        return Redisson.create(config);  
    }  
}
```
>此外还有一种配置 Redisson 客户端的方式，可以引入 redisson 的 starter 依赖，然后在 yml 文件中配置Redisson，但是不推荐这种方式，因为他会替换掉 Spring官方 提供的这套对 Redisson 的配置

3. 将前面使用我们自己的分布式锁的地方换为 Redisson 的分布式锁
```java
@Resource  
    private RedissonClient redissonClient;  
    /**  
     * 抢购秒杀券  
     *  
     * @param voucherId  
     * @return  
     */  
  
    @Override  
    public Result seckillVoucher(Long voucherId)  {  
// 1、查询秒杀券  
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);  
// 2、判断秒杀券是否合法  
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {  
// 秒杀券的开始时间在当前时间之后  
            return Result.fail("秒杀尚未开始");  
        }        
        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {  
// 秒杀券的结束时间在当前时间之前  
            return Result.fail("秒杀已结束");  
        }        
        if (voucher.getStock() < 1) {  
            return Result.fail("秒杀券已抢空");  
        }// 3、创建订单  
        Long userId = UserHolder.getUser().getId();  
        RLock lock = redissonClient.getLock("lock:order:" + userId);//获取锁，可重入锁，指定锁的名称  
        //获取分布式锁  
        boolean isLock = false;//参数分别代表获取锁的最大等待时间（在1秒内不断尝试获取锁），锁超时时间，单位  
        try {  
            isLock = lock.tryLock(1, 10, TimeUnit.SECONDS);  
        } catch (InterruptedException e) {  
            throw new RuntimeException("获取锁失败");  
        }        
        if(!isLock){  
            return Result.fail("不能重复下单");  
        }        
        try{  
            // 创建代理对象，使用代理对象调用第三方事务方法， 防止事务失效  
            IVoucherOrderService proxy = (IVoucherOrderService)  
                    AopContext.currentProxy();  
            return proxy.createVoucherOrder(userId, voucherId);  
        }finally {  
            lock.unlock();//释放锁  
        }  
    }
```
>如果发生 RedissonClient 的初始化异常，可以参考 [Unable to init enough connections amount! Only 21 of 24 were initialized... 的解决办法-CSDN博客](https://blog.csdn.net/qq_36128033/article/details/127116407)，或者将 `Redisson` 版本改为 3.17.3，如果你使用的 redis 在云服务上的话就有可能是网络问题

> [!NOTE] 方法介绍
>- `tryLock()`: 使用无参的方式获取分布式锁，`waitTime` 的默认值是-1，代表不等待，获取锁失败直接返回 false, `leaseTime`: 默认值是 30，`unit` 默认值是 seconds, 也就是超时时间默认是 30 秒
>- `tryLock(long time,TimeUnit unit)`: 在指定时间内不断尝试获取锁，获取锁成功返回 true, h 获取锁失败返回 false
>- `tryLock(long waitTime,long leaseTime,TimeUnit unit)`: 指定等待时间为 `waitTime`,锁超时时间为 `leaseTime`

### 秒杀优化

> [!NOTE] 回顾之前完成的内容
> - <mark style="background: #FF5582A6;">自增 ID 问题</mark>：我们的订单 id 一定要是<mark style="background: #ABF7F7A6;">复杂的，递增的，安全的，高可用的</mark>，如果仅仅使用数据库的自增 id 作为订单 id, <mark style="background: #ABF7F7A6;">可能面临分库分表，id 可推测等问题</mark>，从而引出了<mark style="background: #ABF7F7A6;">分布式 id</mark>
> - <mark style="background: #FF5582A6;">一人多单超卖问题</mark>：在多线程情况下可能会出现优惠卷<mark style="background: #ABF7F7A6;">库存为-1</mark> 的现象，使用<mark style="background: #ABF7F7A6;">乐观锁</mark>解决了该问题
> - <mark style="background: #FF5582A6;"> 一人一单超卖问题</mark>：在实际场景下更多的是一人一单的超卖问题，同一用户线程不能同时操作数据库，我们使用了悲观锁 `synchronized` 解决了单体下的一人一单超卖问题，但是如果在集群的情况下，`synchronized` 就会失效导致超卖问题，从而引入了<mark style="background: #ABF7F7A6;">分布式锁</mark>，开始我们自己编写了一个分布式锁，开始是<mark style="background: #ABF7F7A6;">超时释放导致超卖问题</mark>，我们通过引入<mark style="background: #ABF7F7A6;">线程标识</mark>，给锁的释放增加了一个判断条件，但是<mark style="background: #ABF7F7A6;">判断锁和释放锁的操作缺乏原子性</mark>，可能在删除锁之前发生<mark style="background: #ABF7F7A6;">阻塞</mark>导致锁提前释放，因此我们引入 <mark style="background: #ABF7F7A6;">lua 脚本</mark>，保证判断和删除操作的<mark style="background: #ABF7F7A6;">原子性</mark>，最后引入了功能更加全面的 `Redisson` 👍

所以现在锁的优化基本上已经到了极致，我们现在就要对性能和稳定性进行进一步的优化
**之前程序的测试**
![[Pasted image 20240203123728.png]]
><mark style="background: #FF5582A6;">QPS 为 1000，异常率为 21.5%，吞吐量为 413</mark>
#### 异步秒杀优化
- **同步**：是指程序按照顺序依次执行，每一步操作完成后再进行下一步。在同步模式下，当一个任务开始执行时，程序会一直等待该任务完成后才会继续执行下一个任务。
- **异步**：是指程序在执行任务时，不需要等待当前任务完成，而是在任务执行的同时继续执行其他任务。在异步模式下，任务的执行顺序是不确定的，程序通过回调、事件通知等方式来获取任务执行的结果。
显然异步的性能是要高于同步的，但是会牺牲掉一定的数据一致性，所以也不是无脑用异步，要根据具体业务进行分析，这里的下单是可以使用异步的，因为下单操作比较耗时，后端操作步骤多，可以进行拆分

**回顾下单流程**：
当用户发起请求，此时会请求 nginx，nginx 会访问到 tomcat，而 tomcat 中的程序，会进行串行操作，分成如下几个步骤：
1. 查询优惠卷
2. 判断秒杀库存是否足够
3. 查询订单
4. 校验是否是一人一单
5. 扣减库存
6. 创建订单
在这六步操作中，又有很多操作是要去操作数据库的，而且还是一个线程串行执行，这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行，那么如何加速呢？
![[1653560986599.png]]
**优化思路**：我们将耗时比较短的逻辑判断放入 lua 脚本中进行判断，比如库存是否足够，是否一人一单，只要这样的逻辑完成就意味着我们一定是可以下单成功的，我们只需要进行快速地逻辑判断，<mark style="background: #FF5582A6;">根本不用等订单创建和保存到数据库中，直接给用户返回成功，再在后台开启一个线程，后台线程慢慢去执行订单创建和订单保存的业务</mark>，这样程序就变得快起来了，而且用户也能快速的得到响应，<mark style="background: #ABF7F7A6;">唯一的缺点就是用户得到响应之后去执行关于订单的相关操作，但是订单数据可能还未保存到数据库中，造成短暂的数据不一致</mark>

- 第一个难点是我们怎么在 redis 中去快速校验一人一单，还有库存判断
	- 库存很明显在 redis 中用 `string` 类型进行存储，将优惠卷 id 作为 key
	- 我们判断是否一人一单是根据<mark style="background: #FF5582A6;">用户 id 和优惠卷 id </mark>进行判断，所以我们可以将 userid 和 voucherid 作为 key 保存在 `Set` 类型的 Redis 中
- 第二个难点是由于我们校验和 tomct 下单是两个线程，那么我们如何知道到底哪个单他最后是否成功，或者是下单完成，为了完成这件事我们在 redis 操作完之后，我们会将一些信息返回给前端，同时也会把这些信息丢到异步 queue 中去，后续操作中，可以通过这个 id 来查询我们 tomcat 中的下单逻辑是否完成了。
![[1653561657295.png]]

**思路**：
- 当用户下单之后，判断库存是否充足只需要根据 key 到 redis 中查找对应的 value 是否大于 0，大于 0 则表示充足，可以继续执行，反之直接结束；继续在 redis 中判断用户是否可以下单，<mark style="background: #FF5582A6;">如果 set 集合中没有这条记录则会返回 0，表示可以下单</mark>，而且顺便将用户 id 和优惠卷 id 存入 set 集合中，整个过程要保证原子性，可以使用 lua 脚本来实现
- 当以上判断逻辑走完之后，我们可以判断当前 redis 中返回的结果是否是 0 ，如果是 0，则表示可以下单，则将之前说的信息存入到到 queue 中去，然后返回，然后再来个线程异步的下单，前端可以通过返回的订单 id 来判断是否下单成功。
- 

![[1653562234886.png]]

**需求**
- 新增秒杀优惠卷的同时，将优惠卷库存信息保存到 Redis 中
- 基于 lua 脚本，判断优惠卷库存，一人一单，决定是否抢购成功
- 如果抢购成功，将优惠卷 id 和用户 id 封装后存入阻塞队列
- 开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能

> [!NOTE] lua 脚本
```lua
-- 优惠卷id  
local voucherId = ARGV[1]  
-- 用户id  
local userId = ARGV[2]  
  
-- 库存的key,前缀可以通过方法参数传过来，也可以直接在lua脚本中写死  
local stockKey = 'seckill:stock:' .. voucherId  
-- 订单key  
local orderKey = 'seckill:order:' .. voucherId  
-- 判断库存是否充足  
local stock = redis.call('get',stockKey)  
if (tonumber(stock) <= 0) then  
    -- 库存不足，返回1  
    return 1  
end  
-- 库存充足，判断是否已经下过单  
if (redis.call('sismember',orderKey,userId) == 1) then  
    -- 用户已下单，返回2  
    return 2  
end  
-- 库存充足，没有下过单，将订单信息保存至set集合,库存减一  
redis.call('incrby',stockKey,-1)  
redis.call('sadd',orderKey,userId)  
-- 成功返回0  
return 0
```

> [!NOTE] 异步线程实现秒杀
```java
@Service  
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {  
  
    @Resource  
    private ISeckillVoucherService seckillVoucherService;  
  
    @Resource  
    private StringRedisTemplate stringRedisTemplate;  
  
    @Resource  
    private RedisIdWorker redisIdWorker=new RedisIdWorker(stringRedisTemplate);  
    @Resource  
    private RedissonClient redissonClient;  
  
    private BlockingQueue<VoucherOrder> orderTasks = new ArrayBlockingQueue<>(1024*1024);//存储订单信息的阻塞队列  
    private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();//线程池，当判断可以下单时，开启异步线程去保存到数据库  
  
    //在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的  
    @PostConstruct  
    private void init() {  
        SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());  
    }  
    private static final DefaultRedisScript<Long> SECKILL_SCRIPT;  
    static {  
        SECKILL_SCRIPT = new DefaultRedisScript<>();  
        SECKILL_SCRIPT.setLocation(new ClassPathResource("lua/seckill.lua"));  
        SECKILL_SCRIPT.setResultType(Long.class);  
    }  
    private IVoucherOrderService proxy;//保存代理对象  
    /**  
     * 抢购秒杀券  
     *  
     * @param voucherId  
     * @return  
     */  
    @Override  
    public Result seckillVoucher(Long voucherId)  {  
        Long result=null;  
        Long userId = UserHolder.getUser().getId();  
        //执行lua脚本，判断是否具有秒杀资格  
        try{  
            result=stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), userId.toString());  
        }catch (Exception e){  
            throw new RuntimeException(e);  
        }        //如果result不为0，则表示没有秒杀资格  
        if (result != null && !result.equals(0L)) {  
            int r=result.intValue();  
            return Result.fail(r == 2 ? "不能重复下单" : "库存不足");  
        }        //result为0表示可以下单，创建订单信息，将订单信息保存至阻塞队列中，开启异步线程后台保存至数据库  
        long orderId = redisIdWorker.nextId("order:");  
        VoucherOrder voucherOrder = new VoucherOrder();  
        voucherOrder.setId(orderId);  
        voucherOrder.setVoucherId(voucherId);  
        voucherOrder.setUserId(userId);  
        //将订单保存至阻塞队列  
        orderTasks.add(voucherOrder);  
        //异步线程无法获取当前线程的局部变量，也就是说异步线程无法获取代理对象，所以将代理对象提升作用域  
        this.proxy = (IVoucherOrderService) AopContext.currentProxy();  
        //返回订单  
        return Result.ok(orderId);  
    }  
  
    //创建一个内部类执行任务  
    private class VoucherOrderHandler implements Runnable{  
  
        @Override  
        public void run() {  
            while (true){//不断地从阻塞队列中获取订单信息  
                try {  
                    VoucherOrder voucherOrder = orderTasks.take();  
                    handlerVoucherOrder(voucherOrder);  
                }catch (Exception e){  
                    throw new RuntimeException("订单处理异常");  
                }  
            }  
        }  
    }  
    private void handlerVoucherOrder(VoucherOrder voucherOrder){  
        Long userId = voucherOrder.getUserId();  
        RLock lock = redissonClient.getLock(LOCK_ORDER_KEY + userId);  
        boolean isLock = lock.tryLock();  
        if(!isLock){  
            log.error("只能一人一单");  
            return;  
        }        //获取锁成功，保存至数据库  
        try {  
            this.proxy.createVoucherOrder(voucherOrder);  
        }finally {  
            lock.unlock();//释放锁  
        }  
    }  
    /**  
     * 创建订单  
     *  
     * @return  
     */  
    @Transactional  
    public void createVoucherOrder(VoucherOrder voucherOrder) {  
        Long voucherId = voucherOrder.getVoucherId();  
        Long userId = voucherOrder.getUserId();  
// 1、判断当前用户是否是第一单  
        int count = this.count(new LambdaQueryWrapper<VoucherOrder>()  
                .eq(VoucherOrder::getUserId, userId)  
                .eq(VoucherOrder::getVoucherId,voucherId));  
        if (count >= 1) {  
// 当前用户不是第一单  
            log.error("用户已经购买过了");  
            return;  
        }// 2、用户是第一单，可以下单，秒杀券库存数量减一  
        boolean flag = seckillVoucherService.update(new  
                LambdaUpdateWrapper<SeckillVoucher>()  
                .eq(SeckillVoucher::getVoucherId, voucherId)  
                .gt(SeckillVoucher::getStock, 0)  
                .setSql("stock = stock -1"));  
        if (!flag) {  
            throw new RuntimeException("秒杀券扣减失败");//让事务发生回滚  
        }  
        flag = this.save(voucherOrder);  
        if (!flag) {  
            throw new RuntimeException("创建秒杀券订单失败");  
        }    
        
	}  
}
```
**实现细节**：
- Lua 脚本中，接收的参数都是 `String` 类型的，`String` 类型的数据无法进行比较，我们需要利用 `tonumber` 函数将 String 转成 Number
- `stringRedisTemplate.execute ` 这个方法，第二个参数是应该 List 集合，标识传入 Lua 脚本中的的 key，如果我们没有传 key，那么直接使用 `Collections.emptyList ()` ，<mark style="background: #FFB8EBA6;">而不是直接使用 null</mark> ，<mark style="background: #ABF7F7A6;">是因为在 `stringRedisTemplate. Execute` 方法内部可能对参数进行了处理，如果传递 null 可能引发 NPE 异常</mark>
- <mark style="background: #ABF7F7A6;">异步线程无法从 ThreadLocal 中获取 userId，我们需要从 voucherOrder 中获取 userId</mark>
- <mark style="background: #FF5582A6;">AopContext. CurrentProxy () 底层也是利用 ThreadLocal 获取的</mark>，所以异步线程中也无法使用。解决方案有两种，第一种是将代理对象和订单一起放入阻塞队列中，<mark style="background: #FF5582A6;">第二种是将代理对象的作用域提升</mark>，变成一个成员变量（我采用了第二种方式）
- 使用一个内部类完成多线程执行的任务，使用 `PostConstruct` 注解在所有类加载完毕后启动线程池中的线程去执行 run 方法
- 在 `createVoucherOrder` 中如果操作数据库失败记得抛出异常进行回滚，不能只做一个日志信息
- 明明在 lua 脚本中已经判断了一人一单的校验为什么在最后创建订单之前还要校验一次，这是为了更加保险，防止 redis 中的数据突然失效造成超卖问题，当然也可以不用加
- 在测试之前要进行数据预热，将数据库中的库存数量同步到 redis 中
**测试**
![[Pasted image 20240203152241.png]]
QPS 为 1000，异常率 0%，吞吐量 281😅妈的还变低了
### 消息队列优化
**分析**
前面我们使用 Java 自带的阻塞队列 `BlockingQueue` 实现消息队列，这种方式存在以下几个严重的弊端：
- 信息可靠性没有保障，`BlockingQueue` 的消息是存储在内存中的，无法进行持久化，一旦程序宕机或者发生异常，会直接导致消息丢失
- 消息容量有限，`BlockingQueue` 的容量有限，无法进行有效扩容，一旦达到最大容量限制，就会抛出<mark style="background: #FF5582A6;">OOM异常</mark>
所以这里我们可以选择采用其它成熟的的（和之前分布式锁一样）MQ，比如：<mark style="background: #ABF7F7A6;">RabbitMQ、RocketMQ、Kafka</mark>等，但是本项目是为了学习Redis而设计的，所以这里我们将要学习如何使用Redis实现一个相对可靠的消息队列（自己实现的肯定没法和别人成熟的产品相比）
什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：
- <mark style="background: #ABF7F7A6;">消息队列</mark>：存储和管理消息，也被称为消息代理（Message Broker）
- <mark style="background: #ABF7F7A6;">生产者</mark>：发送消息到消息队列
- <mark style="background: #ABF7F7A6;">消费者</mark>：从消息队列获取消息并处理消息
![[1653574849336.png]]

>使用队列的好处在于 **解耦**所谓解耦，举一个生活中的例子就是：快递员 (生产者)把快递放到快递柜里边 (Message Queue)去，我们 (消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。
  这种场景在我们秒杀中就变成了：我们下单之后，利用 redis 去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。

$$
基于List结构模拟消息队列
$$
- 消息队列（Message Queue），字面意思就是存放消息的队列。而 Redis 的 list 数据结构是一个双向链表，很容易模拟出队列效果。
- 队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP 来实现。不过要注意的是，<mark style="background: #ABF7F7A6;">当队列中没有消息时 RPOP 或 LPOP 操作会返回 null，并不像 JVM 的阻塞队列那样会阻塞并等待消息</mark>。因此这里应该使用 BRPOP 或者 BLPOP 来实现阻塞效果。
![[1653575176451.png]]
**基于 List 的消息队列有哪些优缺点？**
优点：
- 利用Redis存储，不受限于JVM内存上限
- 基于 Redis 的持久化机制，数据安全性有保证
- 可以满足消息有序性
缺点：
- 无法避免消息丢失
- 只支持单消费者

$$
基于PubSub的消息队列
$$
- PubSub（发布订阅）是 Redis 2.0 版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个 channel，生产者向对应 channel 发送消息后，所有订阅者都能收到相关消息。
	- SUBSCRIBE channel [channel] ：订阅一个或多个频道 
	- PUBLISH channel msg ：向一个频道发送消息
	- PSUBSCRIBE pattern[pattern] ：订阅与 pattern 格式匹配的所有频道
![[1653575506373.png]]
**基于 PubSub 的消息队列有哪些优缺点？**
优点：
- 采用发布订阅模型，支持多生产、多消费
缺点：
- 不支持数据持久化
- 无法避免消息丢失
- 消息堆积有上限，超出时数据丢失

$$
基于Stream的消息队列
$$
Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。
发送消息的命令：
![[1653577301737.png]]
例如：
![[1653577349691.png]]
读取消息的方式之一：XREAD
![[1653577445413.png]]
例如，使用 XREAD 读取第一个消息：
![[1653577643629.png]]
XREAD 阻塞方式，读取最新的消息：
![[1653577659166.png]]
在业务开发中，我们可以循环的调用 XREAD 阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下：
![[1653577689129.png]]
注意：当我们指定起始 ID 为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题
STREAM 类型消息队列的 XREAD 命令特点：
- 消息可回溯
- 一个消息可以被多个消费者读取
- 可以阻塞读取
- 有消息漏读的风险
$$
消费者组
$$
消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：
![[1653577801668.png]]
创建消费者组：
![[1653577984924.png]]
<mark style="background: #FFB8EBA6;">key</mark>：队列名称 
<mark style="background: #FFB8EBA6;">groupName</mark>：消费者组名称 
<mark style="background: #FFB8EBA6;">ID</mark>：起始 ID 标示，$代表队列中最后一个消息，0则代表队列中第一个消息 
<mark style="background: #FFB8EBA6;">MKSTREAM</mark>：队列不存在时自动创建队列

其它常见命令：
**删除指定的消费者组**
```shell
XGROUP DESTORY key groupName
```
**给指定的消费者组添加消费者**
```shll
XGROUP CREATECONSUMER key groupname consumername
```
**删除消费者组中的指定消费者**
```shell
XGROUP DELCONSUMER key groupname consumername
```
**从消费者组读取消息：**
```shell
XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]
```
- group：消费组名称
- consumer：消费者名称，如果消费者不存在，会自动创建一个消费者
- count：本次查询的最大数量
- BLOCK milliseconds：当没有消息时最长等待时间
- NOACK：无需手动ACK，获取到消息后自动确认
- STREAMS key：指定队列名称
- ID：获取消息的起始 ID
	- ">": 从下一个未消费的消息开始
	- 其它：根据指定 id 从 pending-list 中获取已消费但未确认的消息，例如0，是从 pending-list 中的第一个消息开始
消费者监听消息的基本思路：
- 每个消费者监听所订阅的消息队列，并且使用阻塞模式监听
- 获取到消息然后进行处理消息
- 如果消息处理发生异常就会触发消息回溯，必须从消息队列的头部依次获取消息，判断是否由异常消息
- 如果存在消息未执行完，则再次推送消息给消费者
![[1653578211854.png]]
列的 XREADGROUP 命令特点：
- 消息可回溯
- 可以多消费者争抢消息，加快消费速度
- 可以阻塞读取
- 没有消息漏读的风险
- 有消息确认机制，保证消息至少被消费一次

最后我们来个小对比
![[1653578560691.png]]

$$
基于Redis的Stream结构作为消息队列，完成异步下单
$$
**需求**
- 创建一个 Stream 类型的消息队列，名为 stream.orders
- 修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId
- 项目启动时，开启一个线程任务，尝试获取 stream. Orders 中的消息，完成下单

> [!NOTE] 修改 lua 脚本
```lua
-- 优惠卷id  
local voucherId = ARGV[1]  
-- 用户id  
local userId = ARGV[2]  
local orderId = ARGV[3]
  
-- 库存的key,前缀可以通过方法参数传过来，也可以直接在lua脚本中写死  
local stockKey = 'seckill:stock:' .. voucherId  
-- 订单key  
local orderKey = 'seckill:order:' .. voucherId  
-- 判断库存是否充足  
local stock = redis.call('get',stockKey)  
if (tonumber(stock) <= 0) then  
    -- 库存不足，返回1  
    return 1  
end  
-- 库存充足，判断是否已经下过单  
if (redis.call('sismember',orderKey,userId) == 1) then  
    -- 用户已下单，返回2  
    return 2  
end  
-- 库存充足，没有下过单，将订单信息保存至set集合,库存减一  
redis.call('incrby',stockKey,-1)  
redis.call('sadd',orderKey,userId)  
-- 将信息保存到消息队列中  
redis.call('xadd','stream.order','*','userId',userId,'voucherId',voucherId,'orderId',orderId)  
-- 成功返回0  
return 0
```

> [!NOTE] VoucherOrderServiceImpl
```java
@Service  
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {  
  
    @Resource  
    private ISeckillVoucherService seckillVoucherService;  
  
    @Resource  
    private StringRedisTemplate stringRedisTemplate;  
  
    @Resource  
    private RedisIdWorker redisIdWorker=new RedisIdWorker(stringRedisTemplate);  
    @Resource  
    private RedissonClient redissonClient;  
  
    //private BlockingQueue<VoucherOrder> orderTasks = new ArrayBlockingQueue<>(1024*1024);//存储订单信息的阻塞队列  
    private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();//线程池，当判断可以下单时，开启异步线程去保存到数据库  
  
    //在类初始化之后执行，因为当这个类初始化好了之后，随时都是有可能要执行的  
    @PostConstruct  
    private void init() {  
        SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());  
    }  
    private static final DefaultRedisScript<Long> SECKILL_SCRIPT;  
    static {  
        SECKILL_SCRIPT = new DefaultRedisScript<>();  
        SECKILL_SCRIPT.setLocation(new ClassPathResource("lua/seckill.lua"));  
        SECKILL_SCRIPT.setResultType(Long.class);  
    }  
    private IVoucherOrderService proxy;//保存代理对象  
    /**  
     * 抢购秒杀券  
     *  
     * @param voucherId  
     * @return  
     */  
    @Override  
    public Result seckillVoucher(Long voucherId)  {  
        Long result=null;  
        Long userId = UserHolder.getUser().getId();  
        Long orderId = redisIdWorker.nextId("order:");  
        //执行lua脚本，判断是否具有秒杀资格  
        try{  
            result=stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), userId.toString(),orderId.toString());  
        }catch (Exception e){  
            log.error("lua脚本执行失败");  
            throw new RuntimeException(e);  
        }        //如果result不为0，则表示没有秒杀资格  
        if (result != null && !result.equals(0L)) {  
            int r=result.intValue();  
            return Result.fail(r == 2 ? "不能重复下单" : "库存不足");  
        }        //异步线程无法获取当前线程的局部变量，也就是说异步线程无法获取代理对象，所以将代理对象提升作用域  
        this.proxy = (IVoucherOrderService) AopContext.currentProxy();  
        //返回订单  
        return Result.ok(orderId);  
    }  
  
    private static final String queueName = "stream.order";  
    //创建一个内部类执行任务  
    private class VoucherOrderHandler implements Runnable{  
  
        @Override  
        public void run() {  
            while (true){//不断地从阻塞队列中获取订单信息  
                try {  
                    List<MapRecord<String, Object, Object>> messageList = stringRedisTemplate.opsForStream().read(  
                            Consumer.from("g1", "c1"),  
                            StreamReadOptions.empty().count(1).block(Duration.ofSeconds(1)),  
                            StreamOffset.create(queueName, ReadOffset.lastConsumed())  
                    );  
                    //判断消息是否获取成功  
                    if(messageList.isEmpty()){  
                        //获取消息失败，再次循环获取  
                        continue;  
                    }  
                    //消息获取成功，可以下单  
                    MapRecord<String, Object, Object> records = messageList.get(0);  
                    Map<Object, Object> messageMap = records.getValue();  
                    VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(messageMap, new VoucherOrder(), true);  
                    handlerVoucherOrder(voucherOrder);  
                    //ACK确认，根据消息队列，消费组，消息标识  
                    stringRedisTemplate.opsForStream().acknowledge(queueName, "g1", records.getId());  
                }catch (Exception e){  
                    //如果发生异常，那消息将不会被确认，所以还要在遍历pending-list依次确认  
                    handlePendingList();  
                }  
            }  
        }  
    }  
    private void handlePendingList(){  
        while(true){  
            try {  
                //从pending-list中获取订单信息  
                List<MapRecord<String, Object, Object>> messageList = stringRedisTemplate.opsForStream().read(  
                        Consumer.from("g1", "c1"),  
                        StreamReadOptions.empty().count(1).block(Duration.ofSeconds(1)),  
                        StreamOffset.create(queueName, ReadOffset.from("0"))  
                );  
                if(messageList.isEmpty()){  
                    break;  
                }  
                MapRecord<String, Object, Object> records = messageList.get(0);  
                Map<Object, Object> messageMap = records.getValue();  
                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(messageMap, new VoucherOrder(), true);  
                handlerVoucherOrder(voucherOrder);  
                stringRedisTemplate.opsForStream().acknowledge(queueName, "g1", records.getId());  
            } catch (Exception e) {  
                try {  
                    Thread.sleep(20);  
                } catch (InterruptedException ex) {  
                    throw new RuntimeException(ex);  
                }  
            }  
        }  
  
    }  
    private void handlerVoucherOrder(VoucherOrder voucherOrder){  
        Long userId = voucherOrder.getUserId();  
        RLock lock = redissonClient.getLock(LOCK_ORDER_KEY + userId);  
        boolean isLock = lock.tryLock();  
        if(!isLock){  
            log.error("只能一人一单");  
            return;  
        }        //获取锁成功，保存至数据库  
        try {  
            this.proxy.createVoucherOrder(voucherOrder);  
        }finally {  
            lock.unlock();//释放锁  
        }  
    }  
    /**  
     * 创建订单  
     *  
     * @return  
     */  
    @Transactional  
    public void createVoucherOrder(VoucherOrder voucherOrder) {  
        Long voucherId = voucherOrder.getVoucherId();  
        Long userId = voucherOrder.getUserId();  
// 1、判断当前用户是否是第一单  
        int count = this.count(new LambdaQueryWrapper<VoucherOrder>()  
                .eq(VoucherOrder::getUserId, userId)  
                .eq(VoucherOrder::getVoucherId,voucherId));  
        if (count >= 1) {  
// 当前用户不是第一单  
            log.error("用户已经购买过了");  
            return;  
        }// 2、用户是第一单，可以下单，秒杀券库存数量减一  
        boolean flag = seckillVoucherService.update(new  
                LambdaUpdateWrapper<SeckillVoucher>()  
                .eq(SeckillVoucher::getVoucherId, voucherId)  
                .gt(SeckillVoucher::getStock, 0)  
                .setSql("stock = stock -1"));  
        if (!flag) {  
            throw new RuntimeException("秒杀券扣减失败");//让事务发生回滚  
        }  
        flag = this.save(voucherOrder);  
        if (!flag) {  
            throw new RuntimeException("创建秒杀券订单失败");  
        }    }  
}
```

## 达人探店
### 发布笔记
探店笔记类似点评网站的评价，往往是图文结合。
对应的表有两个： 
- `tb_blog`：探店笔记表，包含笔记中的标题、文字、图片等 
- `tb_blog_comments`：其他用户对探店笔记的评价
**执行流程**
![[1653578992639.png]]

> [!NOTE] 上传图片--UploadController
```java
@PostMapping("blog")  
public Result uploadImage(@RequestParam("file") MultipartFile image) {  
    try {  
        // 获取原始文件名称  
        String originalFilename = image.getOriginalFilename();  
        // 生成新文件名  
        String fileName = createNewFileName(originalFilename);  
        // 保存文件  
        image.transferTo(new File(SystemConstants.IMAGE_UPLOAD_DIR, fileName));  
        // 返回结果  
        log.debug("文件上传成功，{}", fileName);  
        return Result.ok(fileName);  
    } catch (IOException e) {  
        throw new RuntimeException("文件上传失败", e);  
    }
}
```

> [!NOTE] 实现细节
> 需要修改SystemConstants.IMAGE_UPLOAD_DIR 自己图片所在的地址，在实际开发中图片一般会放在nginx上或者是云存储上。

![[Pasted image 20240205202400.png]]

> [!NOTE] 发布笔记
```java
@RestController  
@RequestMapping("/blog")  
public class BlogController {  
  
    @Resource  
    private IBlogService blogService;  
    @Resource  
    private IUserService userService;  
  
    @PostMapping  
    public Result saveBlog(@RequestBody Blog blog) {  
        // 获取登录用户  
        UserDTO user = UserHolder.getUser();  
        blog.setUserId(user.getId());  
        // 保存探店博文  
        blogService.save(blog);  
        // 返回id  
        return Result.ok(blog.getId());  
    }
}
```

> [!NOTE] 发生异常
> ![[Pasted image 20240205203345.png]]
> 没有 shop_id 这个字段值，因为没有在发布时选择对应的店铺，所以会没有店铺 id
> ![[Pasted image 20240205203635.png]]

### 查看探店笔记
**实现查看发布探店笔记的接口**
![[1653579931626.png]]

> [!NOTE] 查看笔记接口
```java
@GetMapping("/{id}")  
public Result queryBlog(@PathVariable Long id){  
    return blogService.queryBlogById(id);  
}
```

> [!NOTE] BlogServiceImpl
```java
@Service  
public class BlogServiceImpl extends ServiceImpl<BlogMapper, Blog> implements IBlogService {  
    @Resource  
    private IUserService userService;  
    /**  
     * 根据id查询博客  
     * @param id  
     * @return  
     */  
    @Override  
    public Result queryBlogById(Long id) {  
        Blog blog = this.getById(id);  
        if(blog==null){  
            return Result.fail("笔记不存在");  
        }        //查询blog相关的用户信息  
        queryUserByBlog(blog);  
        return Result.ok(blog);  
    }  
  
    /**  
     * 根据博客信息完善用户信息  
     * @param blog  
     */  
    private void queryUserByBlog(Blog blog){  
        Long userId = blog.getUserId();  
        User user = userService.getById(userId);  
        blog.setName(user.getNickName());  
        blog.setIcon(user.getIcon());  
    }  
}
```
### Set 实现点赞功能
![[1653581590453.png]]
**初始代码**
```java
@PutMapping("/like/{id}")  
public Result likeBlog(@PathVariable("id") Long id) {  
    // 修改点赞数量  
    blogService.update()  
            .setSql("liked = liked + 1").eq("id", id).update();  
    return Result.ok();  
}
```
>观察以上代码有什么问题？

- 存在一个问题，就是<mark style="background: #ABF7F7A6;">用户可以无限点赞</mark>，这显然是不合理的，我们要实现一个人最多只能点赞一次，重复点赞只能取消点赞
对于点赞这种高频变化的数据，如果我们使用 MySQL 是十分不理智的，因为 MySQL 慢、并且并发请 MySQL 会影响其它重要业务，容易影响整个系统的性能，继而降低了用户体验。那么如何我们要使用 Redis，那么我们又该选择哪种数据结构才更加合理呢？
这里我推荐使用 <mark style="background: #FF5582A6;">Set</mark> ，因为 Set 类型的数据结构具有
- **不重复**，符合业务的特点，一个用户只能点赞一次
- **高性能**，Set 集合内部实现了高效的数据结构 (Hash 表)
- **灵活性**，Set 集合可以实现一对多，一个用户可以点赞多个博客，符合实际的业务逻辑
当然也可以选择使用 Hash （Hash 占用空间比 Set 更小），如果想要点赞排序也可以选用 Sorted Set

**需求**
- 同一个用户只能点赞一次，再次点击则取消点赞
- 如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段 Blog 类的 isLike 属性）
**实现步骤**
- 给 Blog 类中添加一个 isLike 字段，标示是否被当前用户点赞 (不用在数据库中添加)
- 修改点赞功能，利用 Redis 的 set 集合判断是否点赞过，如果用户 id 存在 set 中说明已经点赞过了，再次点赞就是取消点赞，将 blog 表中的 `like` 字段减一直接将 set 集合中的数据去除，如果用户 id 不存在于 set 集合中，说明还没有点赞过，则将 `like` 字段数值加一，并存入 set 集合中
- 修改根据 id 查询 Blog 的业务，判断当前登录用户是否点赞过，赋值给 isLike 字段
- 修改分页查询 hotBlog 业务，判断当前登录用户是否点赞过，赋值给 isLike 字段

> [!NOTE] BlogController
```java
@RestController  
@RequestMapping("/blog")  
public class BlogController {  
  
    @Resource  
    private IBlogService blogService;  
    @Resource  
    private IUserService userService;  
  
    @PostMapping  
    public Result saveBlog(@RequestBody Blog blog) {  
        // 获取登录用户  
        UserDTO user = UserHolder.getUser();  
        blog.setUserId(user.getId());  
        // 保存探店博文  
        blogService.save(blog);  
        // 返回id  
        return Result.ok(blog.getId());  
    }  
    @GetMapping("/{id}")  
    public Result queryBlog(@PathVariable("id") Long id){  
        return blogService.queryBlogById(id);  
    }  
  
    @PutMapping("/like/{id}")  
    public Result likeBlog(@PathVariable("id") Long id) {  
        // 修改点赞数量  
        return blogService.likeBlog(id);  
    }  
  
  
    @GetMapping("/of/me")  
    public Result queryMyBlog(@RequestParam(value = "current", defaultValue = "1") Integer current) {  
        // 获取登录用户  
        UserDTO user = UserHolder.getUser();  
        // 根据用户查询  
        Page<Blog> page = blogService.query()  
                .eq("user_id", user.getId()).page(new Page<>(current, SystemConstants.MAX_PAGE_SIZE));  
        // 获取当前页数据  
        List<Blog> records = page.getRecords();  
        return Result.ok(records);  
    }  
  
    @GetMapping("/hot")  
    public Result queryHotBlog(@RequestParam(value = "current", defaultValue = "1") Integer current) {  
        return blogService.queryHotBlog(current);  
    }  
}
```

> [!NOTE] BlogServiceImpl
```java
@Service  
public class BlogServiceImpl extends ServiceImpl<BlogMapper, Blog> implements IBlogService {  
    @Resource  
    private IUserService userService;  
    @Resource  
    private StringRedisTemplate stringRedisTemplate;  
    /**  
     * 根据id查询博客  
     * @param id  
     * @return  
     */  
    @Override  
    public Result queryBlogById(Long id) {  
        Blog blog = this.getById(id);  
        if(blog==null){  
            return Result.fail("笔记不存在");  
        }        //查询blog相关的用户信息  
        queryUserByBlog(blog);  
        isBlogLiked(blog);  
        return Result.ok(blog);  
    }  
  
    /**  
     * 判断当前用户是否点赞过  
     * @param id  
     * @return  
     */  
    @Override  
    public Result likeBlog(Long id) {  
        Long userId = UserHolder.getUser().getId();  
        String key=BLOG_LIKED_KEY+id;  
        //判断用户是否点赞过  
        Boolean isMember = stringRedisTemplate.opsForSet().isMember(key, userId.toString());  
        if(BooleanUtil.isFalse(isMember)){  
            //没有点赞过，点赞数加一  
            boolean success = this.update(new LambdaUpdateWrapper<Blog>().eq(Blog::getId, id).setSql("liked=liked+1"));  
            if(success){  
                //保存至redis中  
                stringRedisTemplate.opsForSet().add(key, userId.toString());  
            }  
        }else{  
            //已经点赞过了，点赞数减一  
            boolean success = this.update(new LambdaUpdateWrapper<Blog>().eq(Blog::getId, id).setSql("liked=liked-1"));  
            if(success){  
                //取消点赞，将缓存去除  
                stringRedisTemplate.opsForSet().remove(key);  
            }  
        }  
        return Result.ok();  
    }  
  
    /**  
     * 查询热门博客  
     * @param current  
     * @return  
     */  
    @Override  
    public Result queryHotBlog(Integer current) {  
        //根据点赞数从大到小排序  
        Page<Blog> page = this.query().orderByDesc("liked").page(new Page<>(current, MAX_PAGE_SIZE));  
        //获取当前页数据  
        List<Blog> records = page.getRecords();  
        //如果当前用户未登录，直接返回所有记录，不需要添加用户信息和点赞信息  
        UserDTO user = UserHolder.getUser();  
        if (user==null){  
            return Result.ok(records);  
        }        //为每个blog设置当前用户信息  
        //判断当前用户是否点赞  
        records.forEach(blog->{  
            queryUserByBlog(blog);  
            isBlogLiked(blog);  
        });  
        return Result.ok(records);  
    }  
  
    /**  
     * 当前用户是否点赞  
     * @param blog  
     */  
    private void isBlogLiked(Blog blog){  
        Long userId = UserHolder.getUser().getId();  
        String key = BLOG_LIKED_KEY + userId;  
        Boolean isMember = stringRedisTemplate.opsForSet().isMember(key, userId.toString());  
        blog.setIsLike(BooleanUtil.isTrue(isMember));  
    }  
  
    /**  
     * 根据博客信息完善用户信息  
     * @param blog  
     */  
    private void queryUserByBlog(Blog blog){  
        Long userId = blog.getUserId();  
        User user = userService.getById(userId);  
        blog.setName(user.getNickName());  
        blog.setIcon(user.getIcon());  
    }  
}
```

> [!NOTE] 实现细节
> - 当用户未登录时，直接返回所有记录数，不用注入用户信息和点赞信息
> - 使用博客 id 作为 set 集合的 key, 用户 id 作为 value, 一个用户可以对应多个博客
> 
### SortSet 实现点赞排行榜
在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，比如最早点赞的 TOP5，形成点赞排行榜：
之前的点赞是放到 set 集合，但是 set 集合是不能排序的，所以这个时候，咱们可以采用一个可以排序的 set 集合，就是咱们的 `sortedSet`
![[1653805077118.png]]
在平常我们所使用的软件中（比如微信、QQ、抖音）的点赞功能都会默认按照时间顺序对点赞的用户进行一个排序，后点赞的用户会排在最前面，而 Set 是无需的，无法满足这个需求，虽然 List 有序，但是不唯一，查找效率也比较低，所以也不推荐使用，此时我们就可以选择使用 `SortedSet` 这个数据结构，它完美的满足了我们所有的需求：<mark style="background: #FF5582A6;">唯一、有序、查找效率高</mark>。
相较于Set集合，SortedList有以下不同之处：
1. 对于Set集合我们可以使用 `isMember` 方法判断用户是否存在，对于SortedList我们可以使用`ZSCORE` 方法判断用户是否存在
2. Set 集合没有提供范围查询，无法获排行榜前几名的数据，SortedList 可以使用 `ZRANGE ` 方法实现范围查询
3. 将当前时间作为排序的 `score`,时间在后面的排名越高

如果我们的需求是，后点赞的排在前面，先点赞的排在后面该如何实现？这就需要涉及到 MySQL 的一些相关知识了，在 MySQL 中如果我们使用 in 进行条件查询，我们的查询默认是数据库顺序查询，数据库中的记录默认都是按照 ID 自增的，所以查出来的结果默认是按照 ID 自增排序的，<mark style="background: #ABF7F7A6;">也就是说返回给前端的用户列表信息并不是按照 Redis 中根据时间排序的顺序显示，而是根据用户的 id 进行显示</mark>

> [!NOTE] BlogServiceImpl
```java
@Service  
public class BlogServiceImpl extends ServiceImpl<BlogMapper, Blog> implements IBlogService {  
    @Resource  
    private IUserService userService;  
    @Resource  
    private StringRedisTemplate stringRedisTemplate;  
    /**  
     * 根据id查询博客  
     * @param id  
     * @return  
     */  
    @Override  
    public Result queryBlogById(Long id) {  
        Blog blog = this.getById(id);  
        if(blog==null){  
            return Result.fail("笔记不存在");  
        }        //查询blog相关的用户信息  
        queryUserByBlog(blog);  
        isBlogLiked(blog);  
        return Result.ok(blog);  
    }  
  
    /**  
     * 判断当前用户是否点赞过  
     * @param id  
     * @return  
     */  
    @Override  
    public Result likeBlog(Long id) {  
        Long userId = UserHolder.getUser().getId();  
        String key=BLOG_LIKED_KEY+id;  
        //判断用户是否点赞过  
        Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());  
        if(score==null){  
            //没有点赞过，点赞数加一  
            boolean success = this.update(new LambdaUpdateWrapper<Blog>().eq(Blog::getId, id).setSql("liked=liked+1"));  
            if(success){  
                //保存至redis中  
                stringRedisTemplate.opsForZSet().add(key, userId.toString(),System.currentTimeMillis());  
            }  
        }else{  
            //已经点赞过了，点赞数减一  
            boolean success = this.update(new LambdaUpdateWrapper<Blog>().eq(Blog::getId, id).setSql("liked=liked-1"));  
            if(success){  
                //取消点赞，将缓存去除  
                stringRedisTemplate.opsForZSet().remove(key,userId.toString());  
            }  
        }  
        return Result.ok();  
    }  
  
    /**  
     * 查询热门博客  
     * @param current  
     * @return  
     */  
    @Override  
    public Result queryHotBlog(Integer current) {  
        //根据点赞数从大到小排序  
        Page<Blog> page = this.query().orderByDesc("liked").page(new Page<>(current, MAX_PAGE_SIZE));  
        //获取当前页数据  
        List<Blog> records = page.getRecords();  
        //如果当前用户未登录，直接返回所有记录，不需要添加用户信息和点赞信息  
        UserDTO user = UserHolder.getUser();  
        if (user==null){  
            return Result.ok(records);  
        }        //为每个blog设置当前用户信息  
        //判断当前用户是否点赞  
        records.forEach(blog->{  
            queryUserByBlog(blog);  
            isBlogLiked(blog);  
        });  
        return Result.ok(records);  
    }  
  
    /**  
     * 查询点赞排行前5的用户，根据点赞先后顺序排序后点赞的在前面  
     * @param id  
     * @return  
     */  
    @Override  
    public Result queryBlogLikes(Long id) {  
        Long userId = UserHolder.getUser().getId();  
        String key = BLOG_LIKED_KEY + id;  
        Set<String> top5 = stringRedisTemplate.opsForZSet().range(key, 0, 4);  
        if (top5.isEmpty()){  
            return Result.ok(Collections.emptyList());  
        }        List<Long> ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());  
        String idsStr = StrUtil.join(",", ids);  
        //数据脱敏  
        List<UserDTO> userDTOS = userService.list(new LambdaQueryWrapper<User>().in(User::getId,ids).  
                        last("order by field (id,"+idsStr+")")).stream().  
                map(user -> BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());  
        return Result.ok(userDTOS);  
    }  
  
    /**  
     * 当前用户是否点赞  
     * @param blog  
     */  
    private void isBlogLiked(Blog blog){  
        Long userId = UserHolder.getUser().getId();  
        String key = BLOG_LIKED_KEY + blog.getId();  
        Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());  
        blog.setIsLike(Objects.nonNull(score));  
    }  
  
    /**  
     * 根据博客信息完善用户信息  
     * @param blog  
     */  
    private void queryUserByBlog(Blog blog){  
        Long userId = blog.getUserId();  
        User user = userService.getById(userId);  
        blog.setName(user.getNickName());  
        blog.setIcon(user.getIcon());  
    }  
}
```
## 好友关注
### 关注和取消关注
针对用户的操作：可以对用户进行关注和取消关注功能。
![[1653806140822.png]]

`tb_follow` 表用来表示用户与用户之间的关注联系
![[1653806253817.png]]
**实现思路**
- 前端传递关注用户的 id, 是否关注的信息， 判断是否已经关注过了
	- 如果关注过了，则取消关注，没有关注就关注
- 访问博客页面时，首先要知道该博主是否已经关注过了，如果关注过了就直接显示取消关注

> [!NOTE] FollowController
```java
@RestController  
@RequestMapping("/follow")  
public class FollowController {  
  
    @Resource  
    private IFollowService followService;  
    /**  
     * 用户关注与取关  
     * @param id  
     * @param isFollow  
     * @return  
     */  
    @PutMapping("/{id}/{isFollow}")  
    public Result follow(@PathVariable("id") Long id,@PathVariable("isFollow") Boolean isFollow){  
        return followService.follow(id, isFollow);  
    }  
  
    /**  
     * 判断当前博客用户是否关注  
     * @param id  
     * @return  
     */  
    @GetMapping("/or/not/{id}")  
    public Result isFollow(@PathVariable("id") Long id){  
        return followService.isFollow(id);  
    }  
}
```

> [!NOTE] FollowServiceImpl
```java
@Service  
public class FollowServiceImpl extends ServiceImpl<FollowMapper, Follow> implements IFollowService {  
  
    @Override  
    public Result follow(Long id, Boolean isFollow) {  
        Long userId = UserHolder.getUser().getId();  
        if(isFollow){//判断是否要关注  
            Follow follow=new Follow();  
            follow.setFollowUserId(id);  
            follow.setUserId(userId);  
            this.save(follow);  
        }else{  
            //根据用户id和关注的用户id删除关注记录  
            this.remove(new LambdaQueryWrapper<Follow>().eq(Follow::getUserId,userId).eq(Follow::getFollowUserId,id));  
        }        return Result.ok();  
    }  
  
    @Override  
    public Result isFollow(Long id) {  
        Long userId = UserHolder.getUser().getId();  
        int count = this.count(new LambdaQueryWrapper<Follow>().eq(Follow::getFollowUserId, id).eq(Follow::getUserId, userId));  
        return Result.ok(count >0);  
    }  
}
```
### Set 实现共同关注
![[1653806706296.png]]
想要去看共同关注的好友，需要首先进入到这个页面，这个页面会发起两个请求
1、去查询用户的详情-->根据 id 查询用户信息
2、去查询用户的笔记-->根据用户 id 查询所有笔记，并将笔记进行分页

> [!NOTE] UserController
```java
/**  
 * 根据id查询用户  
 * @param id  
 * @return  
 */  
@GetMapping("/{id}")  
public Result queryUserById(@PathVariable("id") Long id){  
    User user = userService.getById(id);  
    if(user==null){  
        return Result.ok();  
    }    //数据脱敏  
    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);  
    return Result.ok(userDTO);  
}
```

> [!NOTE] BlogController
```java
/**  
 * 根据用户id查询对应的博客  
 * @param current  
 * @param id  
 * @return  
 */  
@GetMapping("/of/user")  
public Result queryBlogByUserId(@RequestParam(value = "current",defaultValue = "1")Integer current,@RequestParam("id") Long id){  
    Page<Blog> page = blogService.query().eq("user_id", id).page(new Page<>(current, MAX_PAGE_SIZE));  
    List<Blog> records = page.getRecords();  
    return Result.ok(records);  
}
```

**接下来我们来看看共同关注如何实现：**
- 我们要实现共同关注，说明要求两个用户关注集合的交集
- 一旦要求交集，补集等集合问题首先应该想到 `Set` 类型的数据结构
- 我们可以将两个用户所关注的对象分别放入一个 `Set` 集合中，一旦要求交集，就可以使用 `SINTER` 命令
- 如果取消关注也需要将对用的用户从 `Set` 集合中删除，关注用户也对应加入 `Set` 集合中
- 如果想要删除 `Set` 集合中的一个元素要使用 `SREM` 命令，不能直接使用 `DEL` 命令，因为 `DEL` 命令会将整个 key 删掉
![[Pasted image 20240207174948.png]]

> [!NOTE] FollowController
```java
@RestController  
@RequestMapping("/follow")  
public class FollowController {  
  
    @Resource  
    private IFollowService followService;  
    /**  
     * 用户关注与取关  
     * @param id  
     * @param isFollow  
     * @return  
     */  
    @PutMapping("/{id}/{isFollow}")  
    public Result follow(@PathVariable("id") Long id,@PathVariable("isFollow") Boolean isFollow){  
        return followService.follow(id, isFollow);  
    }  
  
    /**  
     * 判断当前博客用户是否关注  
     * @param id  
     * @return  
     */  
    @GetMapping("/or/not/{id}")  
    public Result isFollow(@PathVariable("id") Long id){  
        return followService.isFollow(id);  
    }  
  
    @GetMapping("/common/{id}")  
    public Result followCommons(@PathVariable("id") Long id){  
        return followService.followCommons(id);  
    }  
}
```

> [!NOTE] FollowServiceImpl
```java
@Service  
public class FollowServiceImpl extends ServiceImpl<FollowMapper, Follow> implements IFollowService {  
    @Resource  
    private StringRedisTemplate stringRedisTemplate;  
    @Resource  
    private IUserService userService;  
    @Override  
    public Result follow(Long id, Boolean isFollow) {  
        Long userId = UserHolder.getUser().getId();  
        String key = FOLLOW_KEY + userId;  
        if(isFollow){//判断是否要关注  
            Follow follow=new Follow();  
            follow.setFollowUserId(id);  
            follow.setUserId(userId);  
            boolean success = this.save(follow);  
            if(success){  
                stringRedisTemplate.opsForSet().add(key, id.toString());  
            }  
        }else{  
            //根据用户id和关注的用户id删除关注记录  
            boolean success = this.remove(new LambdaQueryWrapper<Follow>().eq(Follow::getUserId, userId).eq(Follow::getFollowUserId, id));  
            if(success){  
                stringRedisTemplate.opsForSet().remove(key, id.toString());  
            }  
        }  
        return Result.ok();  
    }  
  
    @Override  
    public Result isFollow(Long id) {  
        Long userId = UserHolder.getUser().getId();  
        int count = this.count(new LambdaQueryWrapper<Follow>().eq(Follow::getFollowUserId, id).eq(Follow::getUserId, userId));  
        return Result.ok(count >0);  
    }  
  
    @Override  
    public Result followCommons(Long id) {  
        Long userId = UserHolder.getUser().getId();  
        String key1=FOLLOW_KEY+userId;//当前用户的key  
        String key2=FOLLOW_KEY+id;//目标对象的key  
        //求两个集合的交集  
        Set<String> intersect = stringRedisTemplate.opsForSet().intersect(key1, key2);  
        if(intersect.isEmpty()){  
            return Result.ok(Collections.emptyList());  
        }        //将set集合转为list集合,并且进行类型转换，方便查询数据库中的用户信息  
        List<Long> ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());  
        //查询共同关注的用户信息  
        List<UserDTO> userDTOS = userService.listByIds(ids).stream().  
                map(user -> BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());  
        return Result.ok(userDTOS);  
    }  
}
```
![[Pasted image 20240207192614.png]]

### Feed 流关注推送

> [!NOTE] 什么是 Feed 流
> 关注推送也叫做 Feed 流，直译为投喂，为用户持续的提供沉浸式体验，通过无限下拉刷新获取新的消息（类似于 B 站的视频推送功能），Feed 流是一种基于用户个性化需求和兴趣的消息推送方式，常见于社交媒体、新闻应用、音乐应用等互联网平台，Feed 流通过算法和行为数据分析，动态的将用户感兴趣的内容以流的方式呈现在用户界面上

对于传统的模式的内容解锁：我们是需要用户去通过搜索引擎或者是其他的方式去解锁想要看的内容
![[1653808641260.png]]
对于新型的 Feed 流的的效果：不需要我们用户再去推送信息，而是系统分析用户到底想要什么，然后直接把内容推送给用户，从而使用户能够更加的节约时间，不用主动去寻找。
![[1653808993693.png]]

**Feed 流产品有两种常见模式**
- <mark style="background: #ABF7F7A6;">时间排序</mark>：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈
	- 优点：信息全面，不会有缺失。并且实现也相对简单
	- 缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低
- <mark style="background: #ABF7F7A6;">智能排序</mark>：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用户
	- 优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷
	- 缺点：如果算法不精准，可能起到反作用
本例中的个人页面，是基于关注的好友来做 Feed 流，因此采用 <mark style="background: #ABF7F7A6;">Timeline </mark>的模式。该模式的实现方案有三种：
- <mark style="background: #FF5582A6;">拉模式</mark>：也叫做**读扩散**。在拉模式中，终端用户或应用程序主动发送请求来获取最新的数据流。它是一种按需获取数据的方式，用户可以在需要时发出请求来获取新数据。在 Feed 流中，数据提供方将数据发布到实时数据源中，而终端用户或应用程序通过订阅或请求来获取新数据。该模式的核心含义就是：当张三和李四和王五发了消息后，都会保存在自己的邮箱中，假设赵六要读取信息，那么他会从读取他自己的收件箱，此时系统会从他关注的人群中，把他关注人的信息全部都进行拉取，然后在进行排序
	- 优点：比较节约空间，因为赵六在读信息时，并没有重复读取，而且读取完之后可以把他的收件箱进行清除
	- 缺点：比较延迟，当用户读取数据时才去关注的人里边去读取数据，假设用户关注了大量的用户，那么此时就会拉取海量的内容，对服务器压力巨大
![[1653809450816.png]]
- <mark style="background: #FF5582A6;">推模式</mark>：也叫做**写扩散**。在推模式中，数据提供方主动将最新的数据推送给终端用户或应用程序。数据提供方会实时地将数据推送到终端用户或应用程序，而无需等待请求。推模式是没有写邮箱的，当张三写了一个内容，此时会主动的把张三写的内容发送到他的粉丝收件箱中去，假设此时李四再来读取，就不用再去临时拉取了
	- 优点：时效快，不用临时拉取
	- 缺点：内存压力大，假设一个大 V 写信息，很多人关注他，就会写很多分数据到粉丝那边去
![[1653809875208.png]]
- <mark style="background: #FF5582A6;">推拉结合</mark>：也叫做**读写混合**，兼具推和拉两种模式的优点。在推拉结合模式中，数据提供方会主动将最新的数据推送给终端用户或应用程序，同时也支持用户通过拉取的方式来获取数据。这样可以实现实时的数据更新，并且用户也具有按需获取数据的能力。推拉模式是一个折中的方案，站在发件人这一段，如果是个普通的人，那么我们采用写扩散的方式，直接把数据写入到他的粉丝中去，因为普通的人他的粉丝关注量比较小，所以这样做没有压力，如果是大 V，那么他是直接将数据先写入到一份到发件箱里边去，然后再直接写一份到活跃粉丝收件箱里边去，现在站在收件人这端来看，如果是活跃粉丝，那么大 V 和普通的人发的都会直接写入到自己收件箱里边来，而如果是普通的粉丝，由于他们上线不是很频繁，所以等他们上线时，再从发件箱里边去拉信息
![[1653812346852.png]]

当前项目用户量较少，所以我们这里使用推模式，延迟低，内存占用每那么大
**需求**
- 修改新增探店笔记的业务，在保存 blog 到数据库的同时，推送到粉丝的收件箱
- 收件箱满足可以根据时间戳排序，必须用 Redis 的数据结构实现
- 查询收件箱数据时，可以实现分页查询
Feed 流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。
传统了分页在 feed 流是不适用的，因为我们的数据会随时发生变化，假设在 t1 时刻，我们去读取第一页，此时 page = 1 ，size = 5 ，那么我们拿到的就是10~6 这几条记录，假设现在 t2时候又发布了一条记录，此时 t3 时刻，我们来读取第二页，读取第二页传入的参数是 page=2 ，size=5 ，那么此时读取到的第二页实际上是从6 开始，然后是6~2 ，那么我们就读取到了重复的数据，这就是所谓的<mark style="background: #FF5582A6;">索引漂移</mark>，所以 feed 流的分页，不能采用原始方案来做。
![[1653813047671.png]]

由于我们需要实现分页查询功能，这里我们可以选择 ` list ` 或者 `SortedSet` ，而不能使用 `Set` ，因为 `Set` 是无序的， `list` 是有索引的， `SortedSet` 是有序的，那么我们该如何选择呢？
>如果我们选择 list 会存在索引漂移现象（这个在 Vue 中也存在），从而导致读取重复数据，所以我们不能选择使用 list

举个例子：我们从 t1时刻开始，拿第一页数据，拿到了10~6，然后记录下当前最后一次拿取的记录，就是6，t2时刻发布了新的记录，此时这个11放到最顶上，但是不会影响我们之前记录的6，此时 t3时刻来拿第二页，第二页这个时候拿数据，还是从6后一点的5去拿，就拿到了5-1的记录。我们这个地方可以采用 sortedSet 来做，可以进行范围查询，并且还可以记录当前获取数据时间戳最小值，就可以实现滚动分页了
![[1653813462834.png]]
核心的意思：<mark style="background: #FF5582A6;">就是我们在保存完探店笔记后，获得到当前笔记的粉丝，然后把数据推送到粉丝的redis中去。</mark>

> [!NOTE] 写完笔记将消息推送给粉丝
```java
/**  BlogServiceImpl
 * 保存笔记信息，并推送给粉丝  
 * @param blog  
 * @return  
 */  
@Override  
public Result saveBlog(Blog blog) {  
    Long userId = UserHolder.getUser().getId();  
    blog.setUserId(userId);  
    boolean success = this.save(blog);//保存到数据库中  
    if(success){  
        //笔记保存成功，将笔记推送给所有粉丝  
        //获取所有粉丝的信息  
        List<Follow> follows = followService.list(new LambdaQueryWrapper<Follow>().eq(Follow::getFollowUserId, userId));  
        for (Follow follow : follows) {  
            //获取粉丝id  
            Long id = follow.getUserId();  
            //推送笔记到Redis  
            String key=FEED_KEY+id;  
            stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());  
        }  
    }  
    return Result.ok(blog.getId());  
}
```

$$
关注推送页面Feed流分页查询
$$
**需求**
在个人主页的“关注”卡片中，查询并展示推送的 Blog 信息：
- 每次查询完成后，我们要分析出查询出数据的最小时间戳，这个值会作为下一次查询的条件
- 我们需要找到与上一次查询相同的查询个数作为偏移量，下次查询时，跳过这些查询过的数据，拿到我们需要的数据
- 综上：我们的请求参数中就需要携带 `lastId`：上一次查询的最小时间戳和偏移量这两个参数。
- 这两个参数第一次会由前端来指定，以后的查询就根据后台结果作为条件，再次传递到后台。
![[1653819821591.png]]
定义出来具体的返回值实体类
```java
@Data
public class ScrollResult {
    private List<?> list;
    private Long minTime;
    private Integer offset;
}
```

> [!NOTE] 获取 Feed 流分页消息
```java
public Result queryBlogOfFollow(Long max, Integer offset) {  
    //查询收件箱  
    Long userId = UserHolder.getUser().getId();  
    String key = FEED_KEY + userId;  
    Set<ZSetOperations.TypedTuple<String>> typedTuples = stringRedisTemplate.opsForZSet()  
            .reverseRangeByScoreWithScores(key, 0, max, offset, 2);  
    //判断收件箱中是否有数据  
    if(typedTuples.isEmpty()){  
        return Result.ok();  
    }    //收件箱中有数据，则解析数据：blogId,minTime,offset  
    List<Long> ids = new ArrayList<>(typedTuples.size());  
    //记录当前最小值  
    long minTime=0;  
    int os=1;//偏移量  
    for (ZSetOperations.TypedTuple<String> tuple : typedTuples) {  
        //获取id  
        ids.add(Long.valueOf(tuple.getValue()));  
        long time = tuple.getScore().longValue();  
        if(time==minTime){  
            os++;  
        }else{  
            minTime=time;  
            os=1;  
        }  
    }  
    os = minTime == max ? os : os + offset;  
    String idStr = StrUtil.join(",", ids);  
    List<Blog> blogs = this.list(new LambdaQueryWrapper<Blog>().in(Blog::getId, ids).last("order by field(id," + idStr + ")"));  
    for (Blog blog : blogs) {  
        queryUserByBlog(blog);  
        isBlogLiked(blog);  
    }    //封装并返回  
    ScrollResult scrollResult = new ScrollResult();  
    scrollResult.setList(blogs);  
    scrollResult.setOffset(os);  
    scrollResult.setMinTime(minTime);  
    return Result.ok(scrollResult);  
}
```






























